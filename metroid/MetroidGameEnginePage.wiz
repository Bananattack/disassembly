// -------------------
// METROID source code
// -------------------
// MAIN PROGRAMMERS
//     HAI YUKAMI
//   ZARU SOBAJIMA
//    GPZ SENGOKU
//    N.SHIOTANI
//     M.HOUDAI
// (C) 1986 NINTENDO
//
// Disassembled, reconstructed and commented
// by SnowBro [Kent Hansen] <kentmhan@online.no>
// Continued by Dirty McDingus (nmikstas@yahoo.com)
// Can be reassembled using Ophis.
// A work in progress.
//Last updated: 3/9/2010

//Game engine (memory page 7)

in game_engine_page, 0xC000:



//-------------------------------------[ Forward declarations ]--------------------------------------

    let objectanimindextbl = 0x8572
    let frameptrtable = 0x860B
    let placeptrtable = 0x86DF
    let starpalswitch = 0x8AC7
    let samusenterdoor = 0x8B13
    let areapointers = 0x9598
    let arearoutine = 0x95C3
    let enemyhitpointtbl = 0x962B
    let enemyinitdelaytbl = 0x96BB
    let decspriteycoord = 0x988A
    let nmiscreenwrite = 0x9A07
    let endgamepalwrite = 0x9F54
    let specitmstable = 0x9598
    let copymap = 0xA93E
    let soundengine = 0xB3B4

//----------------------------------------[ Start of code ]------------------------------------------

//This routine generates pseudo random numbers and updates those numbers
//every frame. The random numbers are used for several purposes including
//password scrambling and determinig what items, if any, an enemy leaves
//behind after it is killed.
func randomize do
    push x via a
    x = 0x5
    loop
        //2E is increased by #$19 every frame and
        //2F is increased by #$5F every frame.
        [randomnumber1] = [randomnumber1] + 0x5 via a
        [randomnumber2] = [randomnumber2] + 0x13 via a
        x--
    until zero end
    x = pop via a
    a = [randomnumber1]
end

//------------------------------------------[ Startup ]----------------------------------------------

def startup: do
    a = 0x00
    // Clear MMC1 registers.
    unroll 5 do
        [nes.mmc1.chr1] = a
    end
    unroll 5 do
        [nes.mmc1.chr2] = a
    end
    
    // Swap to PRG bank #0 at $8000
    call write_rom_bank

    // x = 0xFF. Setup the stack pointer.
    x--
    s = x

    // Clear system RAM.
    [0x1] = 0x70 via y
    [0x0] = 0x00 via y
    a = y
    loop
        loop
            [[0x0]:y] = a
            y++
        until zero end

        [0x1]--
        break when negative
        x = [0x1]

        compare x to 0x1
    until zero end

    // Clear cartridge RAM.
    [0x1] = 0x7F via y
    [0x0] = 0x0 via y
    //A = 0
    a = y
    loop
        loop
            [[0x0]:y] = a
            y++
        until zero end

        [0x1]--
        x = [0x1]
        compare x to 0x60
    until < end

    //Vertical mirroring.
    //H/V mirroring (As opposed to one-screen mirroring).
    //Switch low PRGROM area during a page switch.
    //16KB PRGROM switching enabled.
    //8KB CHRROM switching enabled.
    [mmcreg0cntrl] = 0b00001110 via a
    
    //Clear bits 3 and 4 of MMC1 register 3.
    [switchupperbits] = 0x0 via a

    //ScrollX = 0
    //ScrollY = 0
    [scroll.x] = 0x0 via y
    [scroll.y] = y
    //Clear hardware scroll.
    [nes.ppu.scroll] = y
    [nes.ppu.scroll] = y
    //Y = #$01
    y++
    //Title screen mode
    [gamemode] = y

    // Clear nametables and sprites.
    call clear_all_nametables
    call clear_all_sprites

    //NMI = enabled
    //Sprite size = 8x8
    //BG pattern table address = $1000
    //SPR pattern table address = $0000
    //PPU address increment = 1
    //Name table address = $2000
    [nes.ppu.ctrl] = 0b10010000 via a
    [video.ctrl] = a
    //Sprites visible = no
    //Background visible = no
    //Sprite clipping = yes
    //Background clipping = no
    //Display type = color
    [video.mask] = 0b00000010 via a

    //Prepare to set PPU to vertical mirroring.
    [video.mirror] = 0x47 via a
    call prepare_vertical_mirror

    //PCM volume = 0 - disables DMC channel
    [nes.apu.dmc.load] = 0x0 via a
    //Enable sound channel 0,1,2,3
    [nes.apu.flag] = 0x0F via a

    //Set title routine and and main routine function-->
    //pointers equal to 0.
    [titleroutine] = 0x00 via y
    [mainroutine] = y
    [randomnumber1] = 0x11 via a
    [randomnumber2] = 0xff via a

    //Y = 1
    y++

    //Prepare to switch page 0 into lower PRGROM.
    [switchpending] = y
    call check_bank_switch

    //Branch always
    goto await_redraw when ~zero

    //The main loop runs all the routines that take place outside of the NMI.
    def main_loop:
        //($C4DE)Check to see if memory page needs to be switched.
        call check_bank_switch
        //($C266)Update Timers 1, 2 and 3.
        call update_timer
        //($C114)Go to main routine for updating game.
        call update_main
        // Increment frame counter.
        [framecount]++
        // Request redraw.
        [video.redraw_pending] = 0x00 via a
        // Wait for redraw to be acknowledged.
    def await_redraw:
        loop
            y = a
            a = [video.redraw_pending]
            break when ~zero
        end

        call randomize
    goto main_loop
end

//-------------------------------------[ Non-Maskable Interrupt ]-------------------------------------

//The NMI is called 60 times a second by the VBlank signal from the PPU. When the
//NMI routine is called, the game should already be waiting for it in the main 
//loop routine in the WaitNMIEnd loop.  It is possible that the main loop routine
//will not be waiting as it is bogged down with excess calculations. This causes
//the game to slow down.

task vblank do
    //Save processor status, A, X and Y on stack.
    push p
    push a
    push x via a
    push y via a
    //Sprite RAM address = 0.
    [nes.ppu.oam.address] = 0x0 via a
    //Transfer page 2 ($200-$2FF) to Sprite RAM.
    [nes.ppu.oam.dma] = 0x2 via a
    // If requested, update the screen.
    if a = [video.redraw_pending] is zero then
        if a = [gamemode] is ~zero then
            //($9A07)Write end message on screen(If appropriate).
            call nmiscreenwrite
        end
        //($C1E0)Check if palette data pending.
        call checkpalwrite
        //($C2CA)check if data needs to be written to PPU.
        call checkppuwrite
        //($C44D)Update $2000 & $2001.
        call writeppuctrl
        //($C29A)Update h/v scroll reg.
        call update_scroll
        //($C215)Read both joypads.
        call readjoypads
    end
    //($B3B4)Update music and SFX.
    call soundengine
    //($C97E)Update Samus' age.
    call updateage
    //NMI = finished.
    [video.redraw_pending] = 0x1 via y

    //Restore Y, X, A, processor status.
    y = pop via a
    x = pop via a
    a = pop
    p = pop
end

//----------------------------------------[ GoMainRoutine ]-------------------------------------------

//This is where the real code of each frame is executed.
//MainRoutine or TitleRoutine (Depending on the value of GameMode)
//is used as an index into a code pointer table, and this routine
//is executed.

def update_main:
    // Check if the title screen is active.
    if a = [gamemode] is ~zero then
        // Jump to $8000, where a routine similar to the one
        // below is executed, only using TitleRoutine instead
        // of MainRoutine as index into a jump table.
        goto 0x8000
    end    
    // If START is pressed,
    if a = [joy1.delta] & 0x10 is ~zero then
        a = [mainroutine]
        compare a to 0x3
        // Unless the game engine is running,
        goto pause when ==
            // If the game is not paused, we're done here.
            compare a to 0x5
            goto done when ~zero
            // Otherwise, the game is paused.
            // Resume game.
            a = 0x3
            // Branch always.
            goto toggle_pause when ~zero
        def pause:
            // Pause game.
            a = 0x5
    def toggle_pause:
        // Switch main routine.
        [mainroutine] = a
        // Toggle game paused.
        [gamepaused] = [gamepaused] ^ 1 via a
        // ($CB92)Silences music while game paused.
        call pausemusic
    end
def done:
    a = [mainroutine]
    //($C27C)Use MainRoutine as index into routine table below.
    call choose_routine word:
        areainit,           //($C801)Area init.
        moreinit,           //($C81D)More area init.
        samusinit,          //($C8D1)Samus init.
        gameengine,         //($C92B)Game engine.
        gameover,           //($C9A6)Display GAME OVER.
        pausemode,          //($C9B1)Pause game.
        gopassword,         //($C9C4)Display password.
        incrementroutine,   //($C155)Just advances to next routine in table.
        samusintro,         //($C9D7)Intro.
        waittimer           //($C494)Delay.

func incrementroutine do
    //Increment to next routine in above table.
    [mainroutine]++
end

//-------------------------------------[ Clear name tables ]------------------------------------------

def clear_all_nametables:
    //($C16D)Always clear name table 0 first.
    call clear_nametable_0
    a = [gamemode]
    //Branch if mode = Play.
    goto clear_nametable_1 when zero
    a = [titleroutine]
    //If running the end game routine, clear-->
    //name table 2, else clear name table 1.
    compare a to 0x1d
    goto clear_nametable_2 when zero
def clear_nametable_1:
    a = 0x2
    //Branch always.
    goto clear_nametable_a when ~zero
def clear_nametable_2:
    a = 0x3
    //Branch always.
    goto clear_nametable_a when ~zero
def clear_nametable_0:
    a = 0x1
def clear_nametable_a: do
    let dest = 0x1
    let fill = 0x0
    [dest] = a
    [fill] = 0xff via a
    // fallthrough
end

func clear_nametable do
    let dest = 0x1
    let fill = 0x0

    // Reset PPU address latch.
    x = [nes.ppu.status]
    // PPU increment = 1.
    [video.ctrl] = [video.ctrl] & 0xfb via a
    // Store control bits in PPU.
    [nes.ppu.ctrl] = a

    // nametable index = [dest] - 1.
    x = [dest]
    x--
    // Set PPU address.
    [nes.ppu.address] = [ppu_high_address_table:x] via a
    [nes.ppu.address] = 0x0 via a
    
    // Loop until the desired name table is cleared.
    // Also clear the associated attribute table.
    x = 0x4
    y = 0x0
    a = [fill]
    loop
        loop
            [nes.ppu.data] = a
            y--
        until zero end
        x--
    until zero end
end

//The following table is used by the above routine for finding
//the high byte of the proper name table to clear.
def ppu_high_address_table: byte: 0x20, 0x24, 0x28, 0x2C

//-------------------------------------[ Erase all sprites ]------------------------------------------

def clear_all_sprites:
    // Stores 0xF0 in memory addresses 0x0200 thru 0x02FF.
    [0x1] = 0x02 via y
    [0x0] = 0x00 via y
    y = 0x0
    a = 0xf0
    loop
        [[0x0]:y] = a
        y++
    until zero end
    a = [gamemode]
    //Exit subroutine if GameMode=Play(#$00)
    goto exit101 when zero
    //($988A)Find proper y coord of sprites.
    goto decspriteycoord

def exit101:
    //Return used by subroutines above and below.
    return

//---------------------------------------[ Remove intro sprites ]-------------------------------------

//The following routine is used in the Intro to remove the sparkle sprites and the crosshairs
//sprites every frame.  It does this by loading the sprite values with #$F4 which moves the 
//sprite to the bottom right of the screen and uses a blank graphic for the sprite.

def removeintrosprites:
    //Start at address $200.
    y = 0x2
    [0x1] = y
    y = 0x0
    //($00) = $0200 (sprite page)
    [0x0] = y
    //Prepare to clear RAM $0200-$025F
    y = 0x5f
    a = 0xf4
def _0011:
    [[0x0]:y] = a
    //Loop unitl $200 thru $25F is filled with #$F4.
    y--
    goto _0011 when ~negative
    a = [gamemode]
    //branch if mode = Play.
    goto exit101 when zero
    //($988A)Find proper y coord of sprites.
    goto decspriteycoord

//-------------------------------------[Clear RAM $33 thru $DF]---------------------------------------

//The routine below clears RAM associated with rooms and enemies.

def clearram_33_df:

    x = 0x33
    a = 0x0
def _0012:
    //Clear RAM addresses $33 through $DF.
    [0x0:x] = a
    x++
    compare x to 0xe0
    //Loop until all desired addresses are cleared.
    goto _0012 when ~carry
    return

//--------------------------------[ Check and prepare palette write ]---------------------------------

def checkpalwrite:

    a = [gamemode]
    //Is game being played? If so, branch to exit.
    goto _0013 when zero
    a = [titleroutine]
    //Is Game at ending sequence? If not, branch
    compare a to 0x1d
    goto _0013 when ~carry
    //($9F54)Write palette data for ending.
    goto endgamepalwrite
def _0013:
    y = [video.palette_pending]
    //Is palette data pending? If so, branch.
    goto _0015 when ~zero
    a = [gamemode]
    //Is game being played? If so, branch to exit.
    goto _0014 when zero
    a = [titleroutine]
    //Is intro playing? If not, branch.
    compare a to 0x15
    goto _0014 when carry
    //($8AC7)Cycles palettes for intro stars twinkle.
    goto starpalswitch
def _0014:
    //Exit when no palette data pending.
    return

//Prepare to write palette data to PPU.

def _0015:
    //Palette # = [video.palette_pending] - 1.
    y--
    a = y
    //* 2, each pal data ptr is 2 bytes (16-bit).
    a = a << 1
    y = a
    //X = low byte of PPU data pointer.
    x = [0x9560:y]
    a = [0x9561:y]
    //Y = high byte of PPU data pointer.
    y = a
    //Clear A.
    a = 0x0
    //Reset palette data pending byte.
    [video.palette_pending] = a

def prepareppuprocess_:

    //Lower byte of pointer to PPU string.
    [0x0] = x
    //Upper byte of pointer to PPU string.
    [0x1] = y
    //($C30C)Write data string to PPU.
    goto processppustring

//----------------------------------------[Read joy pad status ]--------------------------------------

//The following routine reads the status of both joypads

def readjoypads:

    //Load x with #$00. Used to read status of joypad 1.
    x = 0x0
    [0x1] = x
    call readonepad
    //Load x with #$01. Used to read status of joypad 2.
    x++
    [0x1]++

def readonepad:

    //These lines strobe the -->
    y = 0x1
    //joystick to enable the -->
    [nes.joy.out] = y
    //program to read the -->
    y--
    //buttons pressed.
    [nes.joy.out] = y
    
    //Do 8 buttons.
    y = 0x8
def _0016:
    //Store A.
    push a
    //Read button status. Joypad 1 or 2.
    a = [nes.joy.in1:x]
    //Store button press at location $00.
    [0x0] = a
    //Move button push to carry bit.
    a = a >> 1
    //If joystick not connected, -->
    a = a | [0x0]
    //fills joy1.status with all 1s.
    a = a >> 1
    //Restore A.
    a = pop
    //Add button press status to A.
    a = a <<< 1
    //Loop 8 times to get -->
    y--
    //status of all 8 buttons.
    goto _0016 when ~zero

    //Joypad #(0 or 1).
    x = [0x1]
    //Get joypad status of previous refresh.
    y = [joy1.status:x]
    //Store at $00.
    [0x0] = y
    //Store current joypad status.
    [joy1.status:x] = a
    a = a ^ [0x0]
    //Branch if no buttons changed.
    goto _0017 when zero
    a = [0x0]
    //Remove the previous status of the B button.
    a = a & 0xbf
    [0x0] = a
    a = a ^ [joy1.status:x]
def _0017:
    //Save any button changes from the current frame-->
    a = a & [joy1.status:x]
    //and the last frame to the joy change addresses.
    [joy1.delta:x] = a
    //Store any changed buttons in JoyRetrig address.
    [joy1.retrigger:x] = a
    y = 0x20
    //Checks to see if same buttons are being-->
    a = [joy1.status:x]
    //pressed this frame as last frame.-->
    compare a to [0x0]
    //If none, branch.
    goto _0018 when ~zero
    //Decrement RetrigDelay if same buttons pressed.
    [joy1.delay:x]--
    goto _0019 when ~zero
    //Once RetrigDelay=#$00, store buttons to retrigger.
    [joy1.retrigger:x] = a
    y = 0x8
def _0018:
    //Reset retrigger delay to #$20(32 frames)-->
    [joy1.delay:x] = y
def _0019:
    //or #$08(8 frames) if already retriggering.
    return

//-------------------------------------------[ Update timer ]-----------------------------------------

//This routine is used for timing - or for waiting around, rather.
//TimerDelay is decremented every frame. When it hits zero, $2A, $2B and $2C are
//decremented if they aren't already zero. The program can then check
//these variables (it usually just checks $2C) to determine when it's time
//to "move on". This is used for the various sequences of the intro screen,
//when the game is started, when Samus takes a special item, and when GAME
//OVER is displayed, to mention a few examples.

def update_timer:

    //First timer to decrement is Timer2.
    x = 0x1
    [timerdelay]--
    goto dectimer when ~negative
    //TimerDelay hits #$00 every 10th frame.
    a = 0x9
    //Reset TimerDelay after it hits #$00.
    [timerdelay] = a
    //Decrement Timer3 every 10 frames.
    x = 0x2

def dectimer:

    a = [timer1:x]
    //Don't decrease if timer is already zero.
    goto _001A when zero
    [timer1:x]--
def _001A:
    //Timer1 and Timer2 decremented every frame.
    x--
    goto dectimer when ~negative
    return

//-----------------------------------------[ Choose routine ]-----------------------------------------

//This is an indirect jump routine. A is used as an index into a code
//pointer table, and the routine at that position is executed. The programmers
//always put the pointer table itself directly after the JSR to choose_routine,
//meaning that its address can be popped from the stack.

def choose_routine:
    //* 2, each ptr is 2 bytes (16-bit).
    a = a << 1
    //Temp storage.
    [tempy] = y
    //Temp storage.
    [tempx] = x
    y = a
    y++
    //Low byte of ptr table address.
    a = pop
    [codeptr] = a
    //High byte of ptr table address.
    a = pop
    [codeptr+1] = a
    //Low byte of code ptr.
    a = [[codeptr]:y]
    x = a
    y++
    //High byte of code ptr.
    a = [[codeptr]:y]
    [codeptr+1] = a
    [codeptr] = x
    //Restore X.
    x = [tempx]
    //Restore Y.
    y = [tempy]
    goto [codeptr]

//--------------------------------------[ Write to scroll registers ]---------------------------------

def update_scroll:
    //Reset scroll register flip/flop
    a = [nes.ppu.status]
    a = [scroll.x]
    [nes.ppu.scroll] = a
    //X and Y scroll offsets are loaded serially.
    a = [scroll.y]
    [nes.ppu.scroll] = a
    return

//----------------------------------[ Add y index to stored addresses ]-------------------------------

//Add Y to pointer at $0000. 

def addytoptr00:

    a = y
    //Add value stored in Y to lower address-->
    carry = 0
    //byte stored in $00.
    a = a +# [0x0]
    [0x0] = a
    //Increment $01(upper address byte) if carry-->
    goto _001B when ~carry
    //has occurred.
    [0x1]++
def _001B:
    return

//Add Y to pointer at $0002

def addytoptr02:

    a = y
    //Add value stored in Y to lower address-->
    carry = 0
    //byte stored in $02.
    a = a +# [0x2]
    [0x2] = a
    //Increment $01(upper address byte) if carry-->
    goto _001C when ~carry
    //has occurred.
    [0x3]++
def _001C:
    return

//--------------------------------[ Simple divide and multiply routines ]-----------------------------

// Divide by 32.
def adiv32: a = a >> 1 // fallthrough
// Divide by 16.
def adiv16: a = a >> 1 // fallthrough
// Divide by 8.
func adiv8 do
    a = a >> 3
end

// Multiply by 32.
def amul32: a = a << 1 // fallthrough
// Multiply by 16.
def amul16: a = a << 1 // fallthrough
// Multiply by 8.
func amul8 do
    a = a << 3
end

//-------------------------------------[ PPU writing routines ]---------------------------------------

//Checks if any data is waiting to be written to the PPU.
//RLE data is one tile that repeats several times in a row.  RLE-Repeat Last Entry

def checkppuwrite:

    a = [video.ppu_pending]
    //If zero no PPU data to write, branch to exit.
    goto _001D when zero
    a = 0xa1
    //Sets up PPU writer to start at address $07A1.
    [0x0] = a
    a = 0x7
    //$0000 = ptr to PPU data string ($07A1).
    [0x1] = a
    //($C30C)write it to PPU.
    call processppustring
    a = 0x0
    //PPU data string has been written so the data-->
    [ppustrindex] = a
    //stored for the write is now erased.
    [ppudatastring] = a
    [video.ppu_pending] = a
def _001D:
    return

def ppuwrite:

    //Set high PPU address.
    [nes.ppu.address] = a
    y++
    a = [[0x0]:y]
    //Set low PPU address.
    [nes.ppu.address] = a
    y++
    //Get data byte containing rep length & RLE status.
    a = [[0x0]:y]
    //Carry Flag = PPU address increment (0 = 1, 1 = 32).
    a = a << 1
    //($C318)Update PPUCtrl0 according to Carry Flag.
    call setppuinc
    //Carry Flag = bit 6 of byte at ($00),y (1 = RLE).
    a = a << 1
    //Get data byte again.
    a = [[0x0]:y]
    //Keep lower 6 bits as loop counter.
    a = a & 0x3f
    x = a
    //If Carry Flag not set, the data is not RLE.
    goto ppuwriteloop when ~carry
    //Data is RLE, advance to data byte.
    y++

def ppuwriteloop:

    goto _001E when carry
    //Only inc Y if data is not RLE.
    y++
def _001E:
    //Get data byte.
    a = [[0x0]:y]
    //Write to PPU.
    [nes.ppu.data] = a
    //Decrease loop counter.
    x--
    //Keep going until X=0.
    goto ppuwriteloop when ~zero
    y++
    //($C2A8)Point to next data chunk.
    call addytoptr00

//Write data string at ($00) to PPU.

def processppustring:

    //Reset PPU address flip/flop.
    x = [nes.ppu.status]
    y = 0x0
    a = [[0x0]:y]
    //If A is non-zero, PPU data string follows,-->
    goto ppuwrite when ~zero
    //($C29A)Otherwise we're done.
    goto update_scroll

//In: CF = desired PPU address increment (0 = 1, 1 = 32).
//Out: PPU control #0 ($2000) updated accordingly.

def setppuinc:

    //Preserve A.
    push a
    a = [video.ctrl]
    a = a | 0x4
    //PPU increment = 32 only if Carry Flag set,-->
    goto _001F when carry
    //else PPU increment = 1.
    a = a & 0xfb
def _001F:
    [nes.ppu.ctrl] = a
    [video.ctrl] = a
    //Restore A.
    a = pop
    return

//Erase blasted tile on nametable.  Each screen is 16 tiles across and 15 tiles down.
def erasetile:

def game_engine_page_C328:
    y = 0x1
    //data pending = YES.
    [video.ppu_pending] = y
    y--
    a = [[0x2]:y]
    a = a & 0xf
    //# of tiles horizontally.
    [0x5] = a
    a = [[0x2]:y]
    //($C2BF)/ 16.
    call adiv16
    //# of tiles vertically.
    [0x4] = a
    x = [ppustrindex]
def _0020:
    a = [0x1]
    //($C36B)write PPU high address to $07A1,PPUStrIndex.
    call writeppubyte
    a = [0x0]
    //($C36B)write PPU low address to $07A1,PPUStrIndex.
    call writeppubyte
    //data length.
    a = [0x5]
    [0x6] = a
    //($C36B)write PPU string length to $07A1,PPUStrIndex.
    call writeppubyte
def _0021:
    y++
    //Get new tile to replace old tile.
    a = [[0x2]:y]
    //($C36B)Write it to $07A1,PPUStrIndex, inc x.
    call writeppubyte
    [0x6]--
    //Branch if more horizontal tiles to replace.
    goto _0021 when ~zero
    [ppustrindex] = x
    [0x6] = y
    y = 0x20
    //($C2A8)Move to next name table line.
    call addytoptr00
    //Store index to find next tile info.
    y = [0x6]
    [0x4]--
    //Branch if more lines need to be changed on name table.
    goto _0020 when ~zero
    //($c376)Finish writing PPU string and exit.
    call endppustring

def writeppubyte:

    //Store data byte at end of PPUDataString.
    [ppudatastring:x] = a

def nextppubyte:

    //PPUDataString has increased in size by 1 byte.
    x++
    //PPU byte writer can only write a maximum of #$4F bytes
    compare x to 0x4f
    //If PPU string not full, branch to get more data.
    goto _0022 when ~carry
    x = [ppustrindex]

def endppustring:

    //If PPU string is already full, or all PPU bytes loaded,-->
    a = 0x0
    //add #$00 as last byte to the PPU byte string.
    [ppudatastring:x] = a
    a = pop
    //Remove last return address from stack and jump out of-->
    a = pop
def _0022:
    //PPU writing routines.
    return

//The following routine is only used by the intro routine to load the sprite 
//palette data for the twinkling stars. The following memory addresses are used:
//$00-$01 Destination address for PPU write, $02-$03 Source address for PPU data,
//$04 Temp storage for PPU data byte, $05 PPU data string counter byte,
//$06 Temp storage for index byte.

def prepppupalettestring:

    y = 0x1
    //Indicate data waiting to be written to PPU.
    [video.ppu_pending] = y
    y--
    //Branch always
    goto _0026 when zero

def _0023:
    //$04 now contains next data byte to be put into the PPU string.
    [0x4] = a
    //High byte of staring address to write PPU data
    a = [0x1]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //Low byte of starting address to write PPU data.
    a = [0x0]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //A now contains next data byte to be put into the PPU string.
    a = [0x4]
    //($C3C6)Break control byte into two bytes.
    call separatecontrolbits

    //Check to see if RLE bit is set in control byte.-->
    compare a & [0x4]
    //If not set, branch to load byte. Else increment index-->
    goto writepalettestringbyte when ~overflow
    //to find repeating data byte.
    y++

def writepalettestringbyte:

    //Check if RLE bit is set (again). if set, load same-->
    compare a & [0x4]
    //byte over and over again until counter = #$00.
    goto _0024 when overflow
    //Non-repeating data byte. Increment for next byte.
    y++
def _0024:
    a = [[0x2]:y]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //Temporarily store data index.
    [0x6] = y
    //PPU address increment = 1.
    y = 0x1
    //If MSB set in control bit, it looks like this routine might-->
    compare a & [0x4]
    //have been used for a software control verticle mirror, but
    goto _0025 when ~negative
                    //the starting address has already been written to the PPU-->
                    //string so this section has no effect whether the MSB is set-->
                    //or not. The PPU is always incremented by 1.
    //PPU address increment = 32.
    y = 0x20
def _0025:
    //($C2A8)Set next PPU write address.(Does nothing, already set).
    call addytoptr00
    //Restore data index to Y.
    y = [0x6]
    //Decrement counter byte.
    [0x5]--
    //If more bytes to write, branch to write another byte.
    goto writepalettestringbyte when ~zero
    //Store total length, in bytes, of PPUDataString.
    [ppustrindex] = x
    //Move to next data byte(should be #$00).
    y++

def _0026:
    //X now contains current length of PPU data string.
    x = [ppustrindex]
    a = [[0x2]:y]
    //Is PPU string done loading (#$00)? If so exit,-->
    goto _0023 when ~zero
    //($C376)else branch to process PPU byte.
    call endppustring

def separatecontrolbits:

    //Store current byte
    [0x4] = a
    a = a & 0xbf
    //Remove RLE bit and save control bit in PPUDataString.
    [ppudatastring:x] = a
    a = a & 0x3f
    //Extract counter bits and save them for use above.
    [0x5] = a
    //($C36E)
    goto nextppubyte

//----------------------------------------[ Math routines ]-------------------------------------------

def twoscompliment:

def game_engine_page_C3D4:
    a = a ^ 0xff
    //Generate twos compliment of value stored in A.
    carry = 0
    a = a +# 0x1
    return

//The following two routines add a Binary coded decimal (BCD) number to another BCD number.
//A base number is stored in $03 and the number in A is added/subtracted from $03.  $01 and $02 
//contain the lower and upper digits of the value in A respectively.  If an overflow happens after
//the addition/subtraction, the carry bit is set before the routine returns.

def base10add:

    //($C41D)Separate upper 4 bits and lower 4 bits.
    call extractnibbles
    //Add lower nibble to number.
    a = a +# [0x1]
    compare a to 0xa
    //If result is greater than 9, add 5 to create-->
    goto _0027 when ~carry
    //valid result(skip #$0A thru #$0F).
    a = a +# 0x5
def _0027:
    carry = 0
    //Add upper nibble to number.
    a = a +# [0x2]
    [0x2] = a
    a = [0x3]
    //Keep upper 4 bits of HealthLo/HealthHi in A.
    a = a & 0xf0
    a = a +# [0x2]
    goto _0029 when ~carry
def _0028:
    //If upper result caused a carry, add #$5F to create-->
    a = a +# 0x5f
    //valid result. Set carry indicating carry to next digit.
    carry = 1
    return
def _0029:
    //If result of upper nibble add is greater than #$90,-->
    compare a to 0xa0
    //Branch to add #$5F to create valid result.
    goto _0028 when carry
    return

def base10subtract:

    //($C41D)Separate upper 4 bits and lower 4 bits.
    call extractnibbles
    //Subtract lower nibble from number.
    a = a -# [0x1]
    [0x1] = a
    //If result is less than zero, add 10 to create-->
    goto _002A when carry
    //valid result.
    a = a +# 0xa
    [0x1] = a
    a = [0x2]
    //Adjust $02 to account for borrowing.
    a = a +# 0xf
    [0x2] = a
def _002A:
    //Keep upper 4 bits of HealthLo/HealthHi in A.
    a = [0x3]
    a = a & 0xf0
    carry = 1
    //If result is greater than zero, branch to finish.
    a = a -# [0x2]
    goto _002B when carry
    //Add 10 to create valid result.
    a = a +# 0xa0
    carry = 0
def _002B:
    //Combine A and $01 to create final value.
    a = a | [0x1]
    return

def extractnibbles:

    push a
    //Lower 4 bits of value to change HealthLo/HealthHi by.
    a = a & 0xf
    [0x1] = a
    a = pop
    //Upper 4 bits of value to change HealthLo/HealthHi by.
    a = a & 0xf0
    [0x2] = a
    a = [0x3]
    //Keep lower 4 bits of HealthLo/HealthHi in A.
    a = a & 0xf
    return

//---------------------------[ NMI and PPU control routines ]--------------------------------

// Wait for the NMI to end.

def waitnmipass:
    
    //($C434)Indicate currently in NMI.
    call clearnmistat
def _002C:
    a = [video.redraw_pending]
    //Wait for NMI to end.
    goto _002C when zero
    return

def clearnmistat:

    //Clear NMI byte to indicate the game is-->
    a = 0x0
    //currently running NMI routines.
    [video.redraw_pending] = a
    return

def screenoff:

    a = [video.mask]
    //BG & SPR visibility = off
    a = a & 0xe7

def writeandwait:

def _002D:
    //Update value to be loaded into PPU control register.
    [video.mask] = a

def waitnmipass_:

    //($C434)Indicate currently in NMI.
    call clearnmistat
def _002E:
    a = [video.redraw_pending]
    //Wait for NMI to end before continuing.
    goto _002E when zero
    return

def screenon:

    a = [video.mask]
    //BG & SPR visibility = on
    a = a | 0x1e
    //Branch always
    goto _002D when ~zero

//Update the actual PPU control registers.

def writeppuctrl: do
    a = [video.ctrl]
    [nes.ppu.ctrl] = a
    // Update PPU control registers.
    a = [video.mask]
    [nes.ppu.mask] = a
    // Setup vertical or horizontal mirroring.
    a = [video.mirror]
    call prepare_ppu_mirror
    // fallthrough
end

// Exit subroutines.
def exit_sub:
    return

//Turn off both screen and NMI.
def screennmioff:
    a = [video.mask]
    //BG & SPR visibility = off
    a = a & 0xe7
    //($C43D)Wait for end of NMI.
    call writeandwait
    //Prepare to turn off NMI in PPU.
    a = [video.ctrl]
    //NMI = off
    a = a & 0x7f
    [video.ctrl] = a
    //Actually load PPU register with NMI off value.
    [nes.ppu.ctrl] = a
    return

//The following routine does not appear to be used.

    //Enable VBlank.
    a = [video.ctrl]
    a = a | 0x80
    //Write PPU control register 0 and PPU status byte.
    [video.ctrl] = a
    [nes.ppu.ctrl] = a
    //Turn sprites and screen on.
    a = [video.mask]
    a = a | 0x1e
    //Branch always.
    goto _002D when ~zero

def vboffandhorzwrite:
 
    a = [video.ctrl]
    //Horizontal write, disable VBlank.
    a = a & 0x7b
def _002F:
    //Save new values in the PPU control register-->
    [nes.ppu.ctrl] = a
    //and PPU status byte.
    [video.ctrl] = a
    return

def nmion:

def _0030:
    a = [nes.ppu.status]
    //Wait for end of VBlank.
    a = a & 0x80
    goto _0030 when ~zero
    a = [video.ctrl]
    //Enable VBlank interrupts.
    a = a | 0x80
    //Branch always.
    goto _002F when ~zero

//--------------------------------------[ Timer routines ]--------------------------------------------

//The following routines set the timer and decrement it. The timer is set after Samus dies and
//before the GAME OVER message is dispayed.  The timer is also set while the item pickup music
//is playing.

def waittimer:

    //Exit if timer hasn't hit zero yet
    a = [timer3]
    goto _0031 when ~zero
    //Set GameOver as next routine.
    a = [nextroutine]
    compare a to 0x4
    //Set GoPassword as main routine.
    goto setmainroutine when zero
    compare a to 0x6
    goto setmainroutine when zero
    //($D92C)Assume power up was picked up and GameEngine-->
    call startmusic
    //is next routine. Start area music before exiting.
    a = [nextroutine]

def setmainroutine:

    //Set next routine to run.
    [mainroutine] = a
def _0031:
    return

def settimer:

    //Set Timer3. Frames to wait is value stored in A*10.
    [timer3] = a
    //Save routine to jump to after Timer3 expires.
    [nextroutine] = x
    //Next routine to run is WaitTimer.
    a = 0x9
    //Branch always.
    goto setmainroutine when ~zero

//-----------------------------------[ PPU mirroring routines ]---------------------------------------

def prepare_vertical_mirror: do
    nop
    nop
    //Prepare to set PPU for vertical mirroring.
    a = 0x47
    // fallthrough
end

func update_ppu_mirror do
    //Move bit 3 to bit 0 position, and remove all other bits.
    //Store at address $00.
    [0x0] = a >> 3 & 0x1 via a
    //Load MMCReg0Cntrl and replace bit 0 with stored bit at [0x00].
    [mmcreg0cntrl] = [mmcreg0cntrl] & 0xfe | [0x0] via a
    //Load new configuration data serially into MMC1Reg0.
    unroll 4 do
        [nes.mmc1.ctrl] = a
        a = a >> 1
    end
    [nes.mmc1.ctrl] = a
end

def prepare_ppu_mirror: do
    a = [video.mirror]
    // Set mirroring through MMC1 chip.
    goto update_ppu_mirror
end

//-----------------------------[ Switch bank and init bank routines ]---------------------------------

//This is how the bank switching works... Every frame, the routine below
//is executed. First, it checks the value of SwitchPending. If it is zero,
//the routine will simply exit. If it is non-zero, it means that a bank
//switch has been issued, and must be performed. SwitchPending then contains
//the bank to switch to, plus one.

def check_bank_switch:
    y = [switchpending]
    //Exit if zero(no bank switch issued). else Y contains bank#+1.
    goto _0032 when zero
    //($C4E8)Perform bank switch.
    call perform_bank_switch
    //($C510)Initialize bank switch data.
    goto init_bank

def perform_bank_switch:
    //Reset(so that the bank switch won't be performed-->
    //every succeeding frame too).
    [switchpending] = 0 via a
    //Y now contains the bank to switch to.
    y--
    [currentbank] = y

def switch_rom_bank:
    //Bank to switch to is stored at location $00.
    [0x0] = y via a
    //Load upper two bits for Reg 3 (they should always be 0).
    //Extract bits 3 and 4 and add them to the current-->
    //bank to switch to.
    //Store any new bits set in 3 or 4(there should be none).
    [switchupperbits] = [switchupperbits] & 0x18 | [0x0] via a

//Loads the lower memory page with the bank specified in A.
def write_rom_bank:
    unroll 4 do
        [nes.mmc1.prg] = a
        a = a >> 1
    end
    [nes.mmc1.prg] = a
    //Restore A with current bank number before exiting.
    a = [0x0]
def _0032:
    return

//Calls the proper routine according to the bank number in A.
def init_bank:
    //*2 For proper table offset below.
    y = a << 1 via a
    //Load appropriate subroutine address into $0A and $0B.
    [0xa] = [init_bank_table:y] via a
    [0xb] = [init_bank_table+1:y] via a
    //Jump to appropriate initialization routine.
    goto [0xa]

def init_bank_table:
    word: initbank0, initbank1, initbank2, initbank3, initbank4, initbank5, exit_sub, exit_sub, exit_sub

//Title screen memory page.

def initbank0:

    y = 0x0
    //Ensure game is not paused.
    [gamepaused] = y
    //Y=1.
    y++
    //Game is at title routines.
    [gamemode] = y
    //($C45D)Waits for NMI to end then turns it off.
    call screennmioff
    //($A93E)Copy game map from ROM to cartridge RAM $7000-$73FF
    call copymap
    //($C158)Erase name table data.
    call clear_all_nametables

    y = 0xa0
def _0033:
    a = [0x98bf:y]
    //Loads sprite info for stars into RAM $6E00 thru 6E9F.
    [0x6dff:y] = a
    y--
    goto _0033 when ~zero

    //($C5D7)Load title GFX.
    call inittitlegfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

//Brinstar memory page.

def initbank1:

    a = 0x0
    //GameMode = play.
    [gamemode] = a
    //($C45D)Disable screen and Vblank.
    call screennmioff
    a = [mainroutine]
    //Is game engine running? if so, branch.-->
    compare a to 0x3
    //Else do some housekeeping first.
    goto _0034 when zero
    a = 0x0
    //Run InitArea routine next.
    [mainroutine] = a
    //Start in Brinstar.
    [inarea] = a
    //Make sure game is not paused.
    [gamepaused] = a
    //($C1D4)Clear game engine memory addresses.
    call clearram_33_df
    //($C578)Clear Samus' stats memory addresses.
    call clearsamusstats
def _0034:
    y = 0x0
    //($C4EF)Load Brinstar memory page into lower 16Kb memory.
    call switch_rom_bank
    //($C604)Load Brinstar GFX.
    call initbrinstargfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

def clearsamusstats:

    y = 0xf
    //Clears Samus stats(Health, full tanks, game timer, etc.).
    a = 0x0
def _0035:
    //Load $100 thru $10F with #$00.
    [0x100:y] = a
    y--
    //Loop 16 times.
    goto _0035 when ~negative
    return

//Norfair memory page.

def initbank2:

    //GameMode = play.
    a = 0x0
    [gamemode] = a
    //($C45D)Disable screen and Vblank.
    call screennmioff
    //($C622)Load Norfair GFX.
    call initnorfairgfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

//Tourian memory page.

def initbank3:

    //GameMode = play.
    a = 0x0
    [gamemode] = a
    //($C45D)Disable screen and Vblank.
    call screennmioff
    y = 0xd
def _0036:
    //Load info from table below into-->
    a = [metroiddata:y]
    //$77F0 thru $77FD.
    [0x77f0:y] = a
    y--
    goto _0036 when ~negative
    //($C645)Load Tourian GFX.
    call inittouriangfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

//Table used by above subroutine and loads the initial data used to describe
//metroid's behavior in the Tourian section of the game.

def metroiddata:

    byte: 0xf8, 0x8, 0x30, 0xd0, 0x60, 0xa0, 0x2, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

//Kraid memory page.

def initbank4:

    //GameMode = play.
    a = 0x0
    [gamemode] = a
    //($C45D)Disable screen and Vblank.
    call screennmioff
    //($C677)Load Kraid GFX.
    call initkraidgfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

//Ridley memory page.

def initbank5:

    //GameMode = play.
    a = 0x0
    [gamemode] = a
    //($C45D)Disable screen and Vblank.
    call screennmioff
    //($C69F)Loag Ridley GFX.
    call initridleygfx
    //($C487)Turn on VBlank interrupts.
    goto nmion

def initendgfx:

    a = 0x1
    //Game is at title/end game.
    [gamemode] = a
    //($C6C2)Load end game GFX.
    goto initgfx6

def inittitlegfx:

    //Entry 21 in GFXInfo table.
    y = 0x15
    //($C7AB)Load pattern table GFX.
    call loadgfx

def loadsamusgfx:

    //Entry 0 in GFXInfo table.
    y = 0x0
    //($C7AB)Load pattern table GFX.
    call loadgfx
    a = [justinbailey]
    //Branch if wearing suit
    goto _0037 when zero
    //Entry 27 in GFXInfo table.
    y = 0x1b
    //($C7AB)Switch to girl gfx
    call loadgfx
def _0037:
    //Entry 20 in GFXInfo table.
    y = 0x14
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 23 in GFXInfo table.
    y = 0x17
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 24 in GFXInfo table.
    y = 0x18
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initbrinstargfx:

    //Entry 3 in GFXInfo table.
    y = 0x3
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 4 in GFXInfo table.
    y = 0x4
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 5 in GFXInfo table.
    y = 0x5
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 6 in GFXInfo table.
    y = 0x6
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initnorfairgfx:

    //Entry 4 in GFXInfo table.
    y = 0x4
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 5 in GFXInfo table.
    y = 0x5
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 7 in GFXInfo table.
    y = 0x7
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 8 in GFXInfo table.
    y = 0x8
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 9 in GFXInfo table.
    y = 0x9
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def inittouriangfx:

    //Entry 5 in GFXInfo table.
    y = 0x5
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 10 in GFXInfo table.
    y = 0xa
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 11 in GFXInfo table.
    y = 0xb
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 12 in GFXInfo table.
    y = 0xc
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 13 in GFXInfo table.
    y = 0xd
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 14 in GFXInfo table.
    y = 0xe
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 26 in GFXInfo table.
    y = 0x1a
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 28 in GFXInfo table.
    y = 0x1c
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initkraidgfx:

    //Entry 4 in GFXInfo table.
    y = 0x4
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 5 in GFXInfo table.
    y = 0x5
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 10 in GFXInfo table.
    y = 0xa
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 15 in GFXInfo table.
    y = 0xf
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 16 in GFXInfo table.
    y = 0x10
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 17 in GFXInfo table.
    y = 0x11
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initridleygfx:

    //Entry 4 in GFXInfo table.
    y = 0x4
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 5 in GFXInfo table.
    y = 0x5
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 10 in GFXInfo table.
    y = 0xa
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 18 in GFXInfo table.
    y = 0x12
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 19 in GFXInfo table.
    y = 0x13
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initgfx6:

    //Entry 1 in GFXInfo table.
    y = 0x1
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 2 in GFXInfo table.
    y = 0x2
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 25 in GFXInfo table.
    y = 0x19
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

def initgfx7:

    //Entry 23 in GFXInfo table.
    y = 0x17
    //($C7AB)Load pattern table GFX.
    call loadgfx
    //Entry 22 in GFXInfo table.
    y = 0x16
    //($C7AB)Load pattern table GFX.
    goto loadgfx

//The table below contains info for each tile data block in the ROM.
//Each entry is 7 bytes long. The format is as follows:
//byte 0: ROM bank where GFX data is located.
//byte 1-2: 16-bit ROM start address (src).
//byte 3-4: 16-bit PPU start address (dest).
//byte 5-6: data length (16-bit).

def gfxinfo:

    //[SPR]Samus, items.        Entry 0.
    byte: 0x6
    word: 0x8000, 0x0, 0x9a0
    //[SPR]Samus in ending.        Entry 1.
    byte: 0x4
    word: 0x8d60, 0x0, 0x520
    //[BGR]Partial font, "The End".    Entry 2.
    byte: 0x1
    word: 0x8d60, 0x1000, 0x400
    //[BGR]Brinstar rooms.        Entry 3.
    byte: 0x6
    word: 0x9da0, 0x1000, 0x150
    //[BGR]Misc. objects.        Entry 4.
    byte: 0x5
    word: 0x8d60, 0x1200, 0x450
    //[BGR]More Brinstar rooms.    Entry 5.
    byte: 0x6
    word: 0x9ef0, 0x1800, 0x800
    //[SPR]Brinstar enemies.        Entry 6.
    byte: 0x1
    word: 0x9160, 0xc00, 0x400
    //[BGR]Norfair rooms.        Entry 7.
    byte: 0x6
    word: 0xa6f0, 0x1000, 0x260
    //[BGR]More Norfair rooms.    Entry 8.
    byte: 0x6
    word: 0xa950, 0x1700, 0x70
    //[SPR]Norfair enemies.        Entry 9.
    byte: 0x2
    word: 0x8d60, 0xc00, 0x400
    //[BGR]Tourian rooms.        Entry 10.
    byte: 0x6
    word: 0xa9c0, 0x1000, 0x2e0
    //[BGR]More Tourian rooms.    Entry 11.
    byte: 0x6
    word: 0xaca0, 0x1200, 0x600
    //[BGR]Mother Brain room.    Entry 12.
    byte: 0x6
    word: 0xb2a0, 0x1900, 0x90
    //[BGR]Misc. object.        Entry 13.
    byte: 0x5
    word: 0x91b0, 0x1d00, 0x300
    //[SPR]Tourian enemies.        Entry 14.
    byte: 0x2
    word: 0x9160, 0xc00, 0x400
    //[BGR]More Tourian rooms.    Entry 15.
    byte: 0x6
    word: 0xb330, 0x1700, 0xc0
    //[BGR]Misc. object and fonts.    Entry 16.
    byte: 0x4
    word: 0x9360, 0x1e00, 0x200
    //[SPR]Miniboss I enemies.    Entry 17.
    byte: 0x3
    word: 0x8d60, 0xc00, 0x400
    //[BGR]More Tourian Rooms.    Entry 18.
    byte: 0x6
    word: 0xb3f0, 0x1700, 0xc0
    //[SPR]Miniboss II enemies.    Entry 19.
    byte: 0x3
    word: 0x9160, 0xc00, 0x400
    //[SPR]Inrto/End sprites.    Entry 20.
    byte: 0x6
    word: 0x89a0, 0xc00, 0x100
    //[BGR]Title.            Entry 21.
    byte: 0x6
    word: 0x8be0, 0x1400, 0x500
    //[BGR]Solid tiles.        Entry 22.
    byte: 0x6
    word: 0x9980, 0x1fc0, 0x40
    //[BGR]Complete font.        Entry 23.
    byte: 0x6
    word: 0xb4c0, 0x1000, 0x400
    //[BGR]Complete font.        Entry 24.
    byte: 0x6
    word: 0xb4c0, 0xa00, 0xa0
    //[BGR]Solid tiles.        Entry 25.
    byte: 0x6
    word: 0x9980, 0xfc0, 0x40
    //[BGR]Complete font.        Entry 26.
    byte: 0x6
    word: 0xb4c0, 0x1d00, 0x2a0
    //[SPR]Suitless Samus.        Entry 27.
    byte: 0x6
    word: 0x90e0, 0x0, 0x7b0
    //[BGR]Exclaimation point.    Entry 28.
    byte: 0x6
    word: 0x9890, 0x1f40, 0x10

//--------------------------------[ Pattern table loading routines ]---------------------------------

//Y contains the GFX header to fetch from the table above, GFXInfo.

def loadgfx:

    a = 0xff
def _0038:
    //Every time y decrements, the entry into the table-->
    carry = 0
    //is increased by 7.  When y is less than 0, A points-->
    a = a +# 0x7
    //to the last byte of the entry in the table.
    y--
    goto _0038 when ~negative
    //Transfer offset into table to Y.
    y = a

    x = 0x6
def _0039:
    a = [gfxinfo:y]
    //Copy entries from GFXInfo to $00-$06.
    [0x0:x] = a
    y--
    x--
    goto _0039 when ~negative

    //ROM bank containing the GFX data.
    y = [0x0]
    //($C4EF)Switch to that bank.
    call switch_rom_bank
    a = [video.ctrl]
    a = a & 0xfb
    //Set the PPU to increment by 1.
    [video.ctrl] = a
    [nes.ppu.ctrl] = a
    //($C7D5)Copy graphics into pattern tables.
    call copygfxblock
    y = [currentbank]
    //($C4FE)Switch back to the "old" bank.
    goto switch_rom_bank

//Writes tile data from ROM to VRAM, according to the gfx header data
//contained in $00-$06.

def copygfxblock:

    a = [0x5]
    //If $05 is #$00, decrement $06 before beginning.
    goto gfxcopyloop when ~zero
    [0x6]--

def gfxcopyloop:

    a = [0x4]
    //Set PPU to proper address for GFX block write.
    [nes.ppu.address] = a
    a = [0x3]
    [nes.ppu.address] = a
    //Set offset for GFX data to 0.
    y = 0x0
def _003A:
    a = [[0x1]:y]
    //Copy GFX data byte from ROM to Pattern table.
    [nes.ppu.data] = a
    //Decrement low byte of data length.
    [0x5]--
    //Branch if high byte does not need decrementing.
    goto _003B when ~zero
    a = [0x6]
    //If copying complete, branch to exit.
    goto _003C when zero
    //Decrement when low byte has reached 0.
    [0x6]--
def _003B:
    //Increment to next byte to copy.
    y++
    goto _003A when ~zero
    //After 256 bytes loaded, increment upper bits of-->
    [0x2]++
    //Source and destination addresses.
    [0x4]++
    //(&C7DB)Repeat copy routine.
    goto gfxcopyloop
def _003C:
    return

//-------------------------------------------[ AreaInit ]---------------------------------------------

def areainit:

    a = 0x0
    //Clear ScrollX.
    [scroll.x] = a
    //Clear ScrollY.
    [scroll.y] = a
    a = [video.ctrl]
    //Sets nametable address = $2000.
    a = a & 0xfc
    [video.ctrl] = a
    //Increment MainRoutine to MoreInit.
    [mainroutine]++
    a = [joy1.status]
    //Stores status of both the A and B buttons.
    a = a & 0xc0
    //Appears to never be accessed.
    [abstatus] = a
    //($C1A3)Clear all sprite info.
    call clear_all_sprites
    //Prepare to load Brinstar memory page.
    a = 0x10
    //($CA18)Check to see if ok to switch lower memory page.
    call check_engine_running

//------------------------------------------[ MoreInit ]---------------------------------------------

def moreinit:

    y = 0x1
    //Palette data pending = yes.
    [video.palette_pending] = y
    x = 0xff
    //$75 Not referenced ever again in the game.
    [sparemem75] = x
    //X=0.
    x++
    //Not playing ending scenes.
    [atending] = x
    //Samus not in door.
    [doorstatus] = x
    //Samus is not inside a door.
    [samusdoordata] = x
    //No projectiles need to be updated.
    [updatingprojectile] = x
    //A=0.
    a = x

def _003D:
    //Check to see if more RAM to clear in $7A thru $DE.
    compare x to 0x65
    goto _003E when carry
    //Clear RAM $7A thru $DE.
    [0x7a:x] = a
def _003E:
    //Check to see if more RAM to clear in $300 thru $3FE.
    compare x to 0xff
    goto _003F when carry
    //Clear RAM $300 thru $3FE.
    [objaction:x] = a
def _003F:
    x++
    //Loop until all required RAM is cleared.
    goto _003D when ~zero

    //($C439)Turn off Background and visibility.
    call screenoff
    //($C158)Clear screen data.
    call clear_all_nametables
    //($C1A3)Erase all sprites from sprite RAM.
    call clear_all_sprites
    //($C8BB)
    call destroyenemies

    //Clear data about doors on the name tables.
    [dooronnametable3] = x
    [dooronnametable0] = x
    //X=1.
    x++
    //Not accessed by game.
    [sparemem30] = x
    //X=2.
    x++
    //Set initial scroll direction as left.
    [scroll.dir] = x

    //Get Samus start x pos on map.
    a = [0x95d7]
    [mapposx] = a
    //Get Samus start y pos on map.
    a = [0x95d8]
    [mapposy] = a

    //Get ??? Something to do with palette switch
    a = [0x95da]
    [paltoggle] = a
    a = 0xff
    //Room number = $FF(undefined room).
    [roomnumber] = a
    //copy pointers from ROM to RAM
    call copyptrs
    //($E720)Put room number at current map pos in $5A.
    call getroomnum
def _0040:
    //($EA2B)
    call setuproom
    //load room number
    y = [roomnumber]
    y++
    goto _0040 when ~zero

    y = [cartramptr+1]
    [0x1] = y
    y = [cartramptr]
    [0x0] = y
    a = [video.ctrl]
    //PPU increment = 1
    a = a & 0xfb
    [video.ctrl] = a
    [nes.ppu.ctrl] = a
    //reset PPU addr flip/flop
    y = [nes.ppu.status]

// Copy room RAM #0 ($6000) to PPU Name Table #0 ($2000)

    y = 0x20
    [nes.ppu.address] = y
    y = 0x0
    [nes.ppu.address] = y
    //prepare to write 4 pages
    x = 0x4
def _0041:
    a = [[0x0]:y]
    [nes.ppu.data] = a
    y++
    goto _0041 when ~zero
    [0x1]++
    x--
    goto _0041 when ~zero

    [0x91] = x
    //X = 1
    x++
    [video.palette_pending] = x
    //Not accessed by game.
    [sparemem30] = x
    //SamusInit is next routine to run.
    [mainroutine]++
    goto screenon

// CopyPtrs
// ========
// Copy 7 16-bit pointers from $959A thru $95A7 to $3B thru $48.

def copyptrs:

    x = 0xd
def _0042:
    a = [areapointers+2:x]
    [roomptrtable:x] = a
    x--
    goto _0042 when ~negative
    return

// DestroyEnemies
// ==============

def destroyenemies:

    a = 0x0
    x = a
def _0043:
    compare x to 0x48
    goto _0044 when carry
    [0x97:x] = a
def _0044:
    [enstatus:x] = a
    push a
    a = pop
    x++
    goto _0043 when ~zero
    //Samus had no Metroid stuck to her.
    [metroidonsamus] = x
    goto 0x95ab

// SamusInit
// =========
// Code that sets up Samus, when the game is first started.

def samusinit:

    a = 0x8
    //SamusIntro will be executed next frame.
    [mainroutine] = a
    //440 frames to fade in Samus(7.3 seconds).
    a = 0x2c
    [timer3] = a
    //($CBFD)Start the intro music.
    call intromusic
    y = sa_fadein0
    //Set Samus status as fading onto screen.
    [objaction] = y
    x = 0x0
    [samusblink] = x
    //X = $FF
    x--
    [0x728] = x
    [0x730] = x
    [0x732] = x
    [0x738] = x
    //Set end timer bytes to #$FF as-->
    [endtimerlo] = x
    //escape timer not currently active.
    [endtimerhi] = x
    [0x8b] = x
    [0x8e] = x
    y = 0x27
    a = [inarea]
    a = a & 0xf
    //Branch if Samus starting in Brinstar.
    goto _0045 when zero
    //If not in Brinstar, change scroll direction from left-->
    [scroll.dir] = [scroll.dir] >> 1
    //to down. and set PPU for horizontal mirroring.
    y = 0x2f
def _0045:
    [video.mirror] = y
    [maxmissilepickup] = y
    [maxenergypickup] = y
    //Samus' initial vertical position
    a = [0x95d9]
    [objecty] = a
    //Samus' initial horizontal position
    a = 0x80
    [objectx] = a
    a = [video.ctrl]
    //Set Samus' name table position to current name table-->
    a = a & 0x1
    //active in PPU.
    [objecthi] = a
    a = 0x0
    //Starting health is-->
    [healthlo] = a
    //set to 30 units.
    a = 0x3
    [healthhi] = a
def _0046:
    return

//------------------------------------[ Main game engine ]--------------------------------------------

def gameengine:

    //($E1F1)Scroll doors, if needed. 2 routine calls scrolls-->
    call scrolldoor
    //($E1F1)twice as fast as 1 routine call.
    call scrolldoor

    a = [narpassword]
    goto _0047 when zero
    //The following code is only accessed if -->
    a = 0x3
    //NARPASSWORD has been entered at the -->
    [healthhi] = a
    //password screen. Gives you new health,-->
    a = 0xff
    //missiles and every power-up every frame.
    [samusgear] = a
    a = 0x5
    [missilecount] = a

def _0047:
    //($CB29)Update Samus, enemies and room tiles.
    call updateworld
    a = [minibosskilldelay]
    //Check if mini boss was just killed or powerup aquired.-->
    a = a | [powerupdelay]
    //If not, branch.
    goto _0048 when zero

    a = 0x0
    //Reset delay indicators.
    [minibosskilldelay] = a
    [powerupdelay] = a
    //Set timer for 240 frames(4 seconds).
    a = 0x18
    //GameEngine routine to run after delay expires
    x = 0x3
    //($C4AA)Set delay timer and game engine routine.
    call settimer

def _0048:
    //Check is Samus is dead.
    a = [objaction]
    //Is Samus dead?-->
    compare a to sa_dead2
    //exit if not.
    goto _0046 when ~zero
    //Is Samus still exploding?-->
    a = [animdelay]
    //Exit if still exploding.
    goto _0046 when ~zero
    //Turn off music.
    call silencemusic
    a = [motherbrainstatus]
    //Is mother brain already dead? If so, branch.
    compare a to 0xa
    goto _0049 when zero
    //Set timer for 40 frames (.667 seconds).
    a = 0x4
    //GameOver routine to run after delay expires.
    x = 0x4
    //($C4AA)Set delay timer and run game over routine.
    goto settimer

def _0049:
    //Next routine to run is GameOver.
    [mainroutine]++
    return

//----------------------------------------[ Update age ]----------------------------------------------

//This is the routine which keeps track of Samus' age. It is called in the
//NMI. Basically, this routine just increments a 24-bit variable every
//256th frame. (Except it's not really 24-bit, because the lowest age byte
//overflows at $D0.)

def updateage:

    a = [gamemode]
    //Exit if at title/password screen.
    goto _004B when ~zero
    a = [mainroutine]
    //Is game engine running?
    compare a to 0x3
    //If not, don't update age.
    goto _004B when ~zero
    //Only update age when FrameCount is zero-->
    x = [framecount]
    //(which is approx. every 4.266666666667 seconds).
    goto _004B when ~zero
    //Minor Age = Minor Age + 1.
    [samusage:x]++
    a = [samusage]
    //Has Minor Age reached $D0?-->
    compare a to 0xd0
    //If not, we're done.-->
    goto _004B when ~carry
    //Else reset minor age.
    a = 0x0
    [samusage] = a
def _004A:
    compare x to 0x3
    //Loop to update middle age and possibly major age.
    goto _004B when carry
    x++
    [samusage:x]++
    //Branch if middle age overflowed, need to increment-->
    goto _004A when zero
def _004B:
    //major age too. Else exit.
    return

//-------------------------------------------[ Game over ]--------------------------------------------

def gameover:

    //GameOver is the next routine to run.
    a = 0x1c
    [titleroutine] = a
    a = 0x1
    //Prepare to switch to title memory page.
    [switchpending] = a
    //($C439)Turn screen off.
    goto screenoff

//------------------------------------------[ Pause mode ]--------------------------------------------

def pausemode:

    //Load buttons currently being pressed on joypad 2.
    a = [joy2.status]
    a = a & 0x88
    //both A & UP pressed?-->
    a = a ^ 0x88
    //Exit if not.
    goto exit14 when ~zero
    y = [endtimerhi]
    //Is escape timer active?-->
    y++
    //Sorry, can't quit if this is during escape scence.
    goto exit14 when ~zero
    //Clear pause game indicator.
    [gamepaused] = a
    //Display password is the next routine to run.
    [mainroutine]++

def exit14:

    //Exit for routines above and below.
    return

//------------------------------------------[ GoPassword ]--------------------------------------------

def gopassword:

    //DisplayPassword is next routine to run.
    a = 0x19
    [titleroutine] = a
    a = 0x1
    //Prepare to switch to intro memory page.
    [switchpending] = a
    a = [noisesfxflag]
    //Silence music.
    a = a | 0x1
    [noisesfxflag] = a
    //($C439)Turn off screen.
    goto screenoff

//-----------------------------------------[ Samus intro ]--------------------------------------------

def samusintro:

    //($C1A3)Clear all sprites off screen.
    call clear_all_sprites
    //Load Samus' fade in status.
    y = [objaction]
    a = [timer3]
    //Branch if Intro still playing.
    goto _004C when ~zero
    
//Fade in complete.
    //Make sure item room music is not playing.
    [itemroommusicstatus] = a
    //Samus facing forward and can't be hurt.
    a = sa_begin
    [objaction] = a
    //($D92C)Start main music.
    call startmusic
    //($CB73)Select proper Samus palette.
    call selectsamuspal
    a = 0x3
    //Game engine will be called next frame.
    [mainroutine] = a

//Still fading in.
def _004C:
    //When 310 frames left of intro, display Samus.
    compare a to 0x1f
    //Branch if not time to start drawing Samus.
    goto exit14 when carry
    //sa_FadeIn0 is beginning of table.
    compare a to [samusfadeintimetbl-20:y]
    //Every time Timer3 equals one of the entries in the table-->
    goto _004D when ~zero
    //below, change the palette used to color Samus.
    [objaction]++
    [video.palette_pending] = y
def _004D:
    //Is game currently on an odd frame?-->
    a = [framecount]
    //If not, branch to exit.
    a = a >> 1
    //Only display Samus on odd frames [the blink effect].
    goto exit14 when ~carry
    //Samus front animation is animation to display.-->
    a = an_samusfront
    //($CF6B)while fading in.
    call setsamusanim
    a = 0x0
    //Samus sprites start at Sprite00RAM.
    [spritepagepos] = a
    //Samus RAM is first set of RAM.
    [pageindex] = a
    //($DE47)Draw Samus on screen.
    goto animdrawobject

//The following table marks the time remaining in Timer3 when a palette change should occur during
//the Samus fade-in sequence. This creates the fade-in effect.

def samusfadeintimetbl:

    byte: 0x1e, 0x14, 0xb, 0x4, 0xff

//---------------------------------[ Check if game engine running ]-----------------------------------

def check_engine_running:
    y = [mainroutine]
    // Unless Samus is fading in or the wait timer is active,
    if compare y to 0x7 is ~= then
        // Is game engine running?
        compare y to 0x3
        // If yes, switch banks.
        goto switch_bank when zero
    end
    // Exit if can't switch bank.
    return

//-----------------------------------------[ Switch bank ]--------------------------------------------

//Switch to appropriate area bank
def switch_bank:
    //Save current area Samus is in.
    [inarea] = a
    a = a & 0xf
    //Use 4 LSB to load switch pending offset from BankTable table.
    y = a
    //Base is $CA30.
    a = [switch_bank_table:y]
    //Store switch data.
    [switchpending] = a
    //($C4DE)Switch lower 16KB to appropriate memory page.
    goto check_bank_switch

//Table used by above subroutine.
//Each value is the area bank number plus one.
def switch_bank_table:
    byte: 0x2 //Brinstar.
    byte: 0x3 //Norfair.
    byte: 0x5 //Kraid hideout.
    byte: 0x4 //Tourian.
    byte: 0x6 //Ridley hideout.

//----------------------------------[ Saved game routines (not used) ]--------------------------------

def accesssavedgame:

    //Save two copies of A. Why? Who knows. This code is-->
    push a
    //Never implemented. A contains data slot to work on.
    push a
    //($CA96)Get index to this save game Samus data info.
    call getgamedataindex
    a = [erasegame]
    //Is MSB set? If so, erase saved game data. Else branch.
    goto _0050 when ~negative
    a = a & 0x1
    //Clear MSB so saved game data is not erased again.
    [erasegame] = a
    //($CAA1)Erase selected saved game data.
    call eraseallgamedata
    //Indicate this saved game has been erased.-->
    a = 0x1
    //Saved game 0=$780C, saved game 1=$781C, saved game 2=$782C.
    [0x7800:y] = a
def _0050:
    a = [mainroutine]
    //If initializing the area at the start of the game, branch-->
    compare a to 0x1
    //to load Samus' saved game info.
    goto _0053 when zero

def savegamedata:

    //Save game based on current area Samus is in. Don't know why.
    a = [inarea]
    //($CAC6)Find index to unique item history for this saved game.
    call saveddatabaseaddr
    //Prepare to save unique item history which is 64 bytes in length.
    y = 0x3f
def _0051:
    a = [numberofuniqueitems:y]
    //Save unique item history in appropriate saved game slot.
    [[0x0]:y] = a
    y--
    //Loop until unique item history transfer complete.
    goto _0051 when ~negative
    //Prepare to save Samus' data.
    y = [samusdataindex]
    x = 0x0
def _0052:
    a = [samusstat00:x]
    //Save Samus' data in appropriate saved game slot.
    [samusdata:y] = a
    y++
    x++
    compare x to 0x10
    //Loop until Samus' data transfer complete.
    goto _0052 when ~zero

def loadgamedata:

def _0053:
    //Restore A to find appropriate saved game to load.
    a = pop
    //($CAC6)Find index to unique item history for this saved game.
    call saveddatabaseaddr
    //Prepare to load unique item history which is 64 bytes in length.
    y = 0x3f
def _0054:
    a = [[0x0]:y]
    //Loop until unique item history is loaded.
    [numberofuniqueitems:y] = a
    y--
    goto _0054 when ~negative
    //Branch always.
    goto _0055 when negative
    push a
def _0055:
    //Prepare to load Samus' data.
    y = [samusdataindex]
    x = 0x0
def _0056:
    a = [samusdata:y]
    //Load Samus' data from appropriate saved game slot.
    [samusstat00:x] = a
    y++
    x++
    compare x to 0x10
    //Loop until Samus' data transfer complete.
    goto _0056 when ~zero
    a = pop
    return

def getgamedataindex:

    a = [dataslot]
    //A contains the save game slot to work on (0 1 or 2).-->
    a = a << 1
    //This number is transferred to the upper four bits to-->
    a = a << 1
    //find the offset for Samus' data for this particular-->
    a = a << 1
    //saved game (#$00, #$10 or #$20).
    a = a << 1
    [samusdataindex] = a
    return

def eraseallgamedata:

    //Always start at saved game 0. Erase all 3 saved games.
    a = 0x0
    //($CAC6)Find index to unique item history for this saved game.
    call saveddatabaseaddr
    //Prepare to erase saved game info at $6A00 and above.
    [0x3]++
    //Fill saved game data with #$00.
    y = 0x0
    a = y
def _0057:
    //Erase unique item histories from $69B4 to $69FF.
    [[0x0]:y] = a
    compare y to 0x40
    //IF 64 bytes alrady erased, no need to erase any more-->
    goto _0058 when carry
    //in the $6A00 and above range.
    [[0x2]:y] = a
def _0058:
    y++
    //Lop until all saved game data is erased.
    goto _0057 when ~zero
    //Load proper index to desired Samus data to erase.
    y = [samusdataindex]
    x = 0x0
    a = x
def _0059:
    //Erase Samus' data.
    [samusdata:y] = a
    y++
    x++
    compare x to 0xc
    //Loop until all data is erased.
    goto _0059 when ~zero
    return

//This routine finds the base address of the unique item history for the desired saved game (0, 1 or 2).
//The memory set aside for each unique item history is 64 bytes and occupies memory addresses $69B4 thru
//$6A73.

def saveddatabaseaddr:

    //Save contents of A.
    push a
    //Load saved game data slot to load.
    a = [dataslot]
    //*2. Table values below are two bytes.
    a = a << 1
    x = a
    a = [saveddatatable:x]
    //Load $0000 and $0002 with base addresses from-->
    [0x0] = a
    //table below($69B4).
    [0x2] = a
    a = [saveddatatable+1:x]
    [0x1] = a
    [0x3] = a
    //Restore A.
    a = pop
    //Discard upper four bits in A.
    a = a & 0xf
    //X used for counting loop.
    x = a
    //Exit if at saved game 0.  No further calculations required.
    goto _005C when zero
def _005A:
    a = [0x0]
    carry = 0
    a = a +# 0x40
    //Loop to add #$40 to base address of $69B4 in order to find-->
    [0x0] = a
    //the proper base address for this saved game data. (save-->
    goto _005B when ~carry
    //slot 0 = $69B4, save slot 1 = $69F4, save slot 2 = $6A34).
    [0x1]++
def _005B:
    x--
    goto _005A when ~zero
def _005C:
    return

//Table used by above subroutine to find base address to load saved game data from. The slot 0
//starts at $69B4, slot 1 starts at $69F4 and slot 2 starts at $6A34.
def saveddatatable:
    //($69B4)Base for save game slot 0.
    word: itmehistory
    //($69B4)Base for save game slot 1.
    word: itmehistory
    //($69B4)Base for save game slot 2.
    word: itmehistory

//----------------------------------------[ Choose ending ]-------------------------------------------

//Determine what type of ending is to be shown, based on Samus' age
def chooseending:
    y = 0x1
def _005D:
    //If SamusAge+2 anything but #$00, load worst-->
    a = [samusage+2]
    //ending(more than 37 hours of gameplay).
    goto _005E when ~zero
    a = [samusage+1]
    //Loop four times to determine-->
    compare a to [agetable-1:y]
    //ending type from table below.
    goto _005E when carry
    y++
    compare y to 0x5
    goto _005D when ~zero
def _005E:
    //Store the ending # (1..5), 5=best ending
    [endingtype] = y
    a = 0x0
    //Was the best or 2nd best ending achieved?
    compare y to 0x4
    //Branch if not (suit stays on)
    goto _005F when ~carry
    a = 0x1
def _005F:
    //Suit OFF, baby!
    [justinbailey] = a
    return

//Table used by above subroutine to determine ending type.
def agetable:
    //Max. 37 hours
    byte: 0x7a
    //Max. 6.7 hours
    byte: 0x16
    //Max. 3.0 hours
    byte: 0xa
    //Best ending. Max. 1.2 hours
    byte: 0x4

//--------------------------------[ Clear screen data (not used) ]------------------------------------

def clearscreendata:
    //($C439)Turn off screen.
    call screenoff
    //Fill current nametable with #$FF.
    [0x0] = 0xff via a
    call clear_nametable
    //($C1A3)Clear sprite data.
    goto clear_all_sprites

//----------------------------------------------------------------------------------------------------

// ===== THE REAL GUTS OF THE GAME ENGINE! =====

def updateworld:
    //Set start of sprite RAM to $0200.
    x = 0x0
    [spritepagepos] = x

    //($F345)Display of enemies.
    call updateenemies
    //($D4BF)Display of bullets/missiles/bombs.
    call updateprojectiles
    //($CC0D)Display/movement of Samus.
    call updatesamus
    //($95C3)Area specific routine.
    call arearoutine
    //($D7B3)Display of elevators.
    call updateelevator
    //($D9D4)Display of Ridley & Kraid statues.
    call updatestatues
    //destruction of enemies
    call game_engine_page_FA9D
    //update of Mellow/Memu enemies
    call game_engine_page_FC65
    call game_engine_page_F93B
    //destruction of green spinners
    call game_engine_page_FBDD
    //($8B13)Check if Samus entered a door.
    call samusenterdoor
    //display of doors
    call 0x8b79
    //tile de/regeneration
    call updatetiles
    //Samus <--> enemies crash detection
    call game_engine_page_F034
    //($E0C1)Display of status bar.
    call displaybar
    call game_engine_page_FAF2
    call checkmissiletoggle
    //display of special items
    call updateitems
    call game_engine_page_FDE3

//Clear remaining sprite RAM
    x = [spritepagepos]
    a = 0xf4
def _0060:
    [sprite00ram:x] = a
    //X = X + 4
    call xplus4
    goto _0060 when ~zero
    return

// SelectSamusPal
// ==============
// Select the proper palette for Samus based on:
// - Is Samus wearing Varia (protective suit)?
// - Is Samus firing missiles or regular bullets?
// - Is Samus with or without suit?

def selectsamuspal:

    a = y
    push a
    a = [samusgear]
    a = a << 1
    a = a << 1
    //CF contains Varia status (1 = Samus has it)
    a = a << 1
    //A = 1 if Samus is firing missiles, else 0
    a = [missiletoggle]
    //Bit 0 of A = 1 if Samus is wearing Varia
    a = a <<< 1
    a = a +# 0x2
    //In suit?
    y = [justinbailey]
    //Branch if yes
    goto _0061 when zero
    carry = 0
    //Add #$17 to the pal # to reach "no suit"-palettes
    a = a +# 0x17
def _0061:
    //Palette will be written next NMI
    [video.palette_pending] = a
    a = pop
    y = a
    return

//----------------------------------[ Initiate SFX and music routines ]-------------------------------

//Initiate sound effects.

def silencemusic:
                //The sound flags are stored in memory-->
    //starting at $0680. The following is a-->
    a = 0x1
    //list of sound effects played when the-->
    goto sfx_setx0 when ~zero
                    //flags are set:
def pausemusic:
                //
    //$0680: These SFX use noise channel.
    a = 0x2
    //Bit 7 - No sound.
    goto sfx_setx0 when ~zero
                    //Bit 6 - ScrewAttack.
def sfx_samuswalk:
                //Bit 5 - MissileLaunch.
    //Bit 4 - BombExplode.
    a = 0x8
    //Bit 3 - SamusWalk.
    goto sfx_setx0 when ~zero
                    //Bit 2 - SpitFlame.
def sfx_bombexplode:
            //Bit 1 - No sound.
    //Bit 0 - No sound.
    a = 0x10
    goto sfx_setx0 when ~zero
                    //$0681: These SFX use sq1 channel.
def sfx_missilelaunch:
            //Bit 7 - MissilePickup.
    //Bit 6 - EnergyPickup.
    a = 0x20
                    //Bit 5 - Metal.
def sfx_setx0:
                //Bit 4 - BulletFire.
    //Bit 3 - OutOfHole.
    x = 0x0
    //Bit 2 - EnemyHit.
    goto sfx_setsoundflag when zero
                    //Bit 1 - SamusJump.
def sfx_outofhole:
                //Bit 0 - WaveFire.
    a = 0x8
    //$0682: Not used.
    goto sfx_setx1 when ~zero
                    //
def sfx_bomblaunch:
                //$0683: These SFX use tri channel.
    //Bit 7 - SamusDie.
    a = 0x1
    //Bit 6 - DoorOpenClose.
    goto sfx_setx3 when ~zero
                    //Bit 5 - MetroidHit.
def sfx_samusjump:
                //Bit 4 - StatueRaise.
    //Bit 3 - Beep.
    a = 0x2
    //Bit 2 - BigEnemyHit.
    goto sfx_setx1 when ~zero
                    //Bit 1 - SamusBall.
def sfx_enemyhit:
                //Bit 0 - BombLaunch.
    a = 0x4
    //$0684: These SFX use multi channels.
    goto sfx_setx1 when ~zero
                    //Bit 7 - FadeInMusic        (music).
def sfx_bulletfire:
                //Bit 6 - PowerUpMusic        (music).
    //Bit 5 - EndMusic  (Page 0 only)(music).
    a = 0x10
    //Bit 4 - IntroMusic(Page 0 only)(music).
    goto sfx_setx1 when ~zero
                    //Bit 3 - not used        (SFX).
def sfx_metal:
                //Bit 2 - SamusHit        (SFX).
    //Bit 1 - BossHit        (SFX).
    a = 0x20
    //Bit 0 - IncorrectPassword    (SFX).
    goto sfx_setx1 when ~zero
                    //
def sfx_energypickup:
            //$0685: Music flags. The music flags start different-->
    //music depending on what memory page is loaded. The-->
    a = 0x40
    //following lists what bits start what music for each-->
    goto sfx_setx1 when ~zero
                    //memory page.
def sfx_missilepickup:
            //
    //Page 0: Intro/ending.
    a = 0x80
                    //Bit 7 - Not used.
def sfx_setx1:
                //Bit 6 - TourianMusic.
    //Bit 5 - ItemRoomMusic.
    x = 0x1
    //Bit 4 - Not used.
    goto sfx_setsoundflag when ~zero
                    //Bit 3 - Not used.
def sfx_wavefire:
                //Bit 2 - Not used.
    //Bit 1 - Not used.
    a = 0x1
    //Bit 0 - Not used.
    goto sfx_setx1 when ~zero
                    //
def sfx_screwattack:
            //Page 1: Brinstar.
    //Bit 7 - Not used.
    a = 0x40
    //Bit 6 - TourianMusic.
    goto sfx_setx0 when ~zero
                    //Bit 5 - ItemRoomMusic.
def sfx_bigenemyhit:
            //Bit 4 - Not used.
    //Bit 3 - Not used.
    a = 0x4
    //Bit 2 - Not used.
    goto sfx_setx3 when ~zero
                    //Bit 1 - Not used.
def sfx_metroidhit:
                //Bit 0 - BrinstarMusic.
    a = 0x20
    //Page 2: Norfair.
    goto sfx_setx3 when ~zero
                    //Bit 7 - Not used.
def sfx_bosshit:
                //Bit 6 - TourianMusic.
    //Bit 5 - ItemRoomMusic.
    a = 0x2
    //Bit 4 - Not used.
    goto sfx_setx4 when ~zero
                    //Bit 3 - NorfairMusic.
def sfx_door:
                //Bit 2 - Not used.
def game_engine_page_CBDA:
    //Bit 1 - Not used.
    a = 0x40
    //Bit 0 - Not used.
    goto sfx_setx3 when ~zero
                    //
def sfx_samushit:
                //Page 3: Tourian.
    //Bit 7 - Not used.
    a = 0x4
    //Bit 6 - TourianMusic
    goto sfx_setx4 when ~zero
                    //Bit 5 - ItemRoomMusic.
def sfx_samusdie:
                //Bit 4 - Not used.
    //Bit 3 - Not used.
    a = 0x80
    //Bit 2 - EscapeMusic.
    goto sfx_setx3 when ~zero
                    //Bit 1 - MotherBrainMusic
def sfx_setx2:
                //Bit 0 - Not used.
    x = 0x2
                    //Page 4: Kraid.
def sfx_setsoundflag:
            //Bit 7 - RidleyAreaMusic.
    //Bit 6 - TourianMusic.
    a = a | [0x680:x]
    //Bit 5 - ItemRoomMusic.
    [0x680:x] = a
    //Bit 4 - KraidAreaMusic.
    return
                    //Bit 3 - Not used.
def sfx_samusball:
                //Bit 2 - Not used.
    //Bit 1 - Not used.
    a = 0x2
    //Bit 0 - Not used.
    goto sfx_setx3 when ~zero
                    //
def sfx_beep:
                //Page 5: Ridley.
    //Bit 7 - RidleyAreaMusic.
    a = 0x8
                    //Bit 6 - TourianMusic.
def sfx_setx3:
                //Bit 5 - ItemRoomMusic.
    //Bit 4 - KraidAreaMusic.
    x = 0x3
    //Bit 3 - Not used.
    goto sfx_setsoundflag when ~zero
                    //Bit 2 - Not used.
//Initiate music                //Bit 1 - Not used.
                    //Bit 0 - Not used.
def powerupmusic:
                //
    a = 0x40
    goto sfx_setx4 when ~zero
                    //
def intromusic:
                //
    a = 0x80
                    //
def sfx_setx4:
                //
    x = 0x4
    goto sfx_setsoundflag when ~zero
                    //
def motherbrainmusic:
            //
def game_engine_page_CC03:
    a = 0x2
    goto sfx_setx5 when ~zero
                    //
def tourianmusic:
                //
def game_engine_page_CC07:
    a = 0x40
                    //
def sfx_setx5:
                //
    x = 0x5
    goto sfx_setsoundflag when ~zero

//--------------------------------------[ Update Samus ]----------------------------------------------

def updatesamus:

    //Samus data is located at index #$00.
    x = 0x0
    [pageindex] = x
    //x=1.
    x++
    //Indicate Samus is the object being updated.
    [issamus] = x
    //($CC1A)Find proper Samus handler routine.
    call gosamushandler
    //Update of Samus complete.
    [issamus]--
    return

def gosamushandler:
    a = [objaction]
    //Branch if Samus is standing.
    goto samusstand when negative
    //($C27C)Goto proper Samus handler routine.
    call choose_routine
        //($CC36)Standing.
        word: samusstand
        //($CCC2)Running.
        word: samusrun
        //($D002)Jumping.
        word: samusjump
        //($D0E1)Rolling.
        word: samusroll
        //($D198)Pointing up.
        word: samuspntup
        //($D3A8)Inside door while screen scrolling.
        word: samusdoor
        //($D002)Jumping while pointing up.
        word: samusjump
        //($D41A)Dead.
        word: samusdead
        //($D41F)More dead.
        word: samusdead2
        //($D423)Samus on elevator.
        word: samuselevator

//---------------------------------------[ Samus standing ]-------------------------------------------

def samusstand:

    //Status of joypad 1.
    a = [joy1.status]
    //Remove SELECT & START status bits.
    a = a & 0xcf
    //Branch if no buttons pressed.
    goto _0062 when zero
    //($CF5D)Set no horiontal movement and single frame animation.
    call clearhorzmvmtanimdata
    a = [joy1.status]
def _0062:
    //Keep status of DOWN/LEFT/RIGHT.
    a = a & 0x7
    //Branch if any are pressed.
    goto _0063 when ~zero
    a = [joy1.delta]
    //Check if UP was pressed last frame.-->
    a = a & 0x8
    //If not, branch.
    goto _0065 when zero
def _0063:
    //($E1E1)Find which directional button is pressed.
    call bitscan
    //Is down pressed?-->
    compare a to 0x2
    //If so, branch.
    goto _0064 when carry
    //1=left, 0=right.
    [samusdir] = a
def _0064:
    x = a
    //Load proper Samus status from table below.
    a = [actiontable:x]
    //Save Samus status.
    [objaction] = a
def _0065:
    a = [joy1.delta]
    //Check if fire was just pressed or needs to retrigger.
    a = a | [joy1.retrigger]
    a = a << 1
    //Branch if FIRE not pressed.
    goto _0066 when ~negative
    //($D1EE)Shoot left/right.
    call fireweapon
def _0066:
    //Check if jump was just pressed.
    compare a & [joy1.delta]
    //Branch if JUMP not pressed.
    goto _0067 when ~negative
    a = sa_jump
    //Set Samus status as jumping.
    [objaction] = a
def _0067:
    //Prepare to set animation delay to 4 frames.
    a = 0x4
    //($CD6D)Set Samus control data and animation.
    call setsamusdata
    a = [objaction]
    //Is Samus inside a door, dead or pointing up and jumping?-->
    compare a to sa_door
    //If so, branch to exit.
    goto _0068 when carry
    //Select routine below.
    call choose_routine
        //($C45C)Rts.
        word: exit_sub
        //($CC98)Samus is running.
        word: setsamusrun
        //($CFC3)Samus is jumping.
        word: setsamusjump
        //($D0B5)Samus is in a ball.
        word: setsamusroll
        //($CF77)Samus is pointing up.
        word: setsamuspntup

//Table used by above subroutine.
def actiontable:
    //Run right.
    byte: sa_run
    //Run left.
    byte: sa_run
    byte: sa_roll
    byte: sa_pntup

//----------------------------------------------------------------------------------------------------

def setsamusexplode:

    a = 0x50
    [samusjumpdsplcmnt] = a
    a = an_explode
    call setsamusanim
    [objectcounter] = a
def _0068:
    return

def setsamusrun:

def game_engine_page_CC98:
    a = 0x9
    [walksounddelay] = a
    x = 0x0
    a = [animresetindex]
    compare a to an_samusstand
    goto _0069 when zero
    x++
    compare a to 0x27
    goto _0069 when zero
    a = 0x4
    call setsamusnextanim
def _0069:
    a = [runanimationtbl:x]
    [animresetindex] = a
    x = [samusdir]
def game_engine_page_CCB7:
    a = [runaccelerationtbl:x]
    [samushorzaccel] = a
    return

def runanimationtbl:
    byte: an_samusrun
    byte: an_samusrunpntup

def runaccelerationtbl:

def game_engine_page_CCC0:
    //Accelerate right.
    byte: 0x30
    //Accelerate left.
    byte: 0xd0

// SamusRun
// ========

def samusrun:

    x = [samusdir]
    a = [samusgravity]
    goto _0070 when zero
    y = [samusjumpdsplcmnt]
    compare a & [objvertspeed]
    goto _006A when negative
    compare y to 0x18
    goto _006D when carry
    a = an_samusjump
    [animresetindex] = a
    //branch always
    goto _006D when ~carry
def _006A:
    compare y to 0x18
    goto _006D when ~carry
    a = [animresetindex]
    compare a to an_samusfirejump
    goto _006B when zero
    a = an_samussalto
    [animresetindex] = a
def _006B:
    compare y to 0x20
    goto _006D when ~carry
    a = [joy1.status]
    a = a & 0x8
    goto _006C when zero
    a = an_samusjumppntup
    [animresetindex] = a
def _006C:
    compare a & [joy1.status]
    goto _006D when negative
    //($D147)
    call stopvertmovement
def _006D:
    a = an_samusrun
    compare a to [animresetindex]
    goto _006E when ~zero
    a = an_samusjump
    [animresetindex] = a
def _006E:
    a = [samusinlava]
    goto _006F when zero
    a = [joy1.delta]
    //branch if JUMP pressed
    goto game_engine_page_CD40 when negative
def _006F:
    call 0xcf88
    call game_engine_page_D09C
    call game_engine_page_CF2E
    a = 0x2
    //branch always
    goto setsamusdata when ~zero
def _0070:
    a = [samusonelevator]
    goto _0071 when ~zero
    call game_engine_page_CCB7
def _0071:
    call 0xcdbf
    //time to play walk sound?
    [walksounddelay]--
    //branch if not
    goto _0072 when ~zero
    a = 0x9
    //# of frames till next walk sound trigger
    [walksounddelay] = a
    call sfx_samuswalk
def _0072:
    call game_engine_page_CF2E
    a = [joy1.delta]
    //branch if JUMP not pressed
    goto _0073 when ~negative
def game_engine_page_CD40:
    call game_engine_page_CFC3
    a = 0x12
    [samushorzspeedmax] = a
    goto game_engine_page_CD6B

def _0073:
    a = a | [joy1.retrigger]
    a = a << 1
    //branch if FIRE not pressed
    goto _0074 when ~negative
    call game_engine_page_CDD7
def _0074:
    a = [joy1.status]
    a = a & 0x3
    goto _0075 when ~zero
    call game_engine_page_CF55
    goto game_engine_page_CD6B

def _0075:
    //($E1E1)
    call bitscan
    compare a to [samusdir]
    goto game_engine_page_CD6B when zero
    [samusdir] = a
    call game_engine_page_CC98
def game_engine_page_CD6B:
    a = 0x3

//---------------------------------------[ Set Samus data ]-------------------------------------------

//The following function sets various animation and control data bytes for Samus.

def setsamusdata:

    //($DC8F)Update animation if needed.
    call updateobjanim
    //($CD9C)Check if screw attack active to change palette.
    call isscrewattackactive
    //If screw attack not active, branch to skip palette change.
    goto _0076 when carry
    a = [framecount]
    a = a >> 1
    //Every other frame, change Samus palette while screw-->
    a = a & 0x3
    //Attack is active.
    a = a | 0xa0
    [objectcntrl] = a
def _0076:
    //($CDFA)Check if Samus hit, blinking or Health low.
    call checkhealthstatus
    //($E269)Check if Samus is in lava or moving.
    call lavaandmovecheck
    //Is a Metroid stuck to Samus?-->
    a = [metroidonsamus]
    //If not, branch.
    goto _0077 when zero
    //Metroid on Samus. Turn Samus blue.
    a = 0xa1
    [objectcntrl] = a
def _0077:
    //($CD92)Mirror Samus, if necessary.
    call setmirrorcntrlbit
    //($DE4A)Display Samus.
    goto drawframe

//---------------------------------[ Set mirror control bit ]-----------------------------------------

def setmirrorcntrlbit:

    //Facing left=#$01, facing right=#$00.
    a = [samusdir]
    //($C2C5)*16. Move bit 0 to bit 4 position.
    call amul16
    a = a | [objectcntrl]
    //Use SamusDir bit to set mirror bit.
    [objectcntrl] = a
    return

//------------------------------[ Check if screw attack is active ]-----------------------------------

def isscrewattackactive:

    //Assume screw attack is not active.
    carry = 1
    y = [objaction]
    //Is Samus running?-->
    y--
    //If not, branch to exit.
    goto _0079 when ~zero
    a = [samusgear]
    //Does Samus have screw attack?-->
    a = a & gr_screwattack
    //If not, branch to exit.
    goto _0079 when zero
    a = [animresetindex]
    //Is Samus summersaulting?-->
    compare a to an_samussalto
    //If so, branch to clear carry(screw attack active).
    goto _0078 when zero
    compare a to an_samusjump
    //Is Samus jumping?-->
    carry = 1
    //If not, branch to exit.
    goto _0079 when ~zero
    //If Samus is jumping and still moving upwards, screw-->
    compare a & [objvertspeed]
    //attack is active.
    goto _0079 when ~negative
def _0078:
    //Screw attack will still be active if not spinning, but-->
    compare a to [animindex]
def _0079:
    //jumping while running and still moving upwards.
    return

//----------------------------------------------------------------------------------------------------

    a = [joy1.status]
    a = a & 0x8
    a = a >> 1
    a = a >> 1
    a = a >> 1
    x = a
    a = [runanimationtbl:x]
    compare a to [animresetindex]
    goto _0079 when zero
    call setsamusanim
    a = pop
    a = pop
    goto game_engine_page_CD6B

def game_engine_page_CDD7:
    //($D1EE)Shoot left/right.
    call fireweapon
    a = [joy1.status]
    a = a & 0x8
    goto _007A when ~zero
    a = an_samusfirerun
    [animindex] = a
    return

def _007A:
    a = [animindex]
    carry = 1
    a = a -# [animresetindex]
    a = a & 0x3
    x = a
    a = [table05:x]
    goto setsamusnextanim

// Table used by above subroutine

def table05:

    byte: 0x3f
    byte: 0x3b
    byte: 0x3d
    byte: 0x3f

def checkhealthstatus:

    a = [samushit]
    //Has Samus been hit?-->
    a = a & 0x20
    //If not, branch to check if still blinking from recent hit.
    goto _007D when zero
    a = 0x32
    //Samus has been hit. Set blink for 32 frames.
    [samusblink] = a
    a = 0xff
    [damagepushdirection] = a
    a = [0x73]
    [0x77] = a
    goto _007C when zero
    goto _007B when ~negative
    call sfx_samushit
def _007B:
    a = [samushit]
    a = a & 0x8
    a = a >> 1
    a = a >> 1
    a = a >> 1
    [damagepushdirection] = a
def _007C:
    a = 0xfd
    [objvertspeed] = a
    //Samus is hit. Store Samus hit gravity.
    a = 0x38
    [samusgravity] = a
    call issamusdead
    goto _007D when ~zero
    goto checkhealthbeep

def _007D:
    a = [samusblink]
    goto checkhealthbeep when zero
    [samusblink]--
    x = [damagepushdirection]
    x++
    goto _0080 when zero
    /// 16
    call adiv16
    compare a to 0x3
    goto _007E when carry
    y = [samushorzaccel]
    goto _0080 when ~zero
    call game_engine_page_CF4E
def _007E:
    x--
    goto _007F when ~zero
    //($C3D4)
    call twoscompliment
def _007F:
    [objhorzspeed] = a
def _0080:
    a = [0x77]
    goto checkhealthbeep when ~negative
    a = [framecount]
    a = a & 0x1
    goto checkhealthbeep when ~zero
    y = a
    [animdelay] = y
    y = 0xf7
    [animframe] = y

def checkhealthbeep:

    y = [healthhi]
    y--
    goto _0081 when negative
    goto _0082 when ~zero
    a = [healthlo]
    compare a to 0x70
    goto _0082 when carry
// health < 17
def _0081:
    a = [framecount]
    a = a & 0xf
    //Only beep every 16th frame.
    goto _0082 when ~zero
    call sfx_beep
def _0082:
    a = 0x0
    [samushit] = a
    return

//----------------------------------------[ Is Samus dead ]-------------------------------------------

def issamusdead:

    a = [objaction]
    compare a to sa_dead
    //Samus is dead. Zero flag is set.
    goto exit3 when zero
    compare a to sa_dead2
    goto exit3 when zero
    //Samus not dead. Clear zero flag.
    compare a to 0xff

def exit3:
  
    //Exit for routines above and below.
    return

//----------------------------------------[ Subtract health ]-----------------------------------------

def subtracthealth:

    //Check to see if health needs to be changed.-->
    a = [healthlochange]
    //If not, branch to exit.
    a = a | [healthhichange]
    goto exit3 when zero
    //($CE84)Check if Samus is already dead.
    call issamusdead
    //Samus is dead. Branch to clear damage values.
    goto cleardamage when zero
    //If end escape timer is running, Samus cannot be hurt.
    y = [endtimerhi]
    y++
    //Branch if end escape timer not active.
    goto _0083 when zero

def cleardamage:

    //($F323)Clear health change values.
    goto clearhealthchange

def _0083:
    //If mother brain is in the process of dying, receive-->
    a = [motherbrainstatus]
    //no damage.
    compare a to 0x3
    goto cleardamage when carry

    a = [samusgear]
    //Check is Samus has Varia.
    a = a & gr_varia
    goto _0084 when zero
    //If Samus has Varia, divide damage by 2.
    [healthlochange] = [healthlochange] >> 1
    [healthhichange] = [healthhichange] >> 1
    //If HealthHi moved a bit into the carry flag while-->
    goto _0084 when ~carry
    //dividing, add #$4F to HealthLo for proper-->
    a = 0x4f
    //division results.
    a = a +# [healthlochange]
    [healthlochange] = a

def _0084:
    //Prepare to subtract from HealthLo.
    a = [healthlo]
    [0x3] = a
    //Amount to subtract from HealthLo.
    a = [healthlochange]
    carry = 1
    //($C3FB)Perform base 10 subtraction.
    call base10subtract
    //Save results.
    [healthlo] = a

    //Prepare to subtract from HealthHi.
    a = [healthhi]
    [0x3] = a
    //Amount to subtract from HealthHi.
    a = [healthhichange]
    //($C3FB)Perform base 10 subtraction.
    call base10subtract
    //Save Results.
    [healthhi] = a

    a = [healthlo]
    //Is Samus health at 0?  If so, branch to-->
    a = a & 0xf0
    //begin death routine.
    a = a | [healthhi]
    goto _0085 when zero
    //Samus not dead. Branch to exit.
    goto _0086 when carry

def _0085:
    //Samus is dead.
    a = 0x0
    [healthlo] = a
    //Set health to #$00.
    [healthhi] = a
    a = sa_dead
    //Death handler.
    [objaction] = a
    //($CBE2)Start Samus die SFX.
    call sfx_samusdie
    //($CC8B)Set Samus exlpode routine.
    goto setsamusexplode

//----------------------------------------[ Add health ]----------------------------------------------

def addhealth:

    //Prepare to add to HealthLo.
    a = [healthlo]
    [0x3] = a
    //Amount to add to HealthLo.
    a = [healthlochange]
    carry = 0
    //($C3DA)Perform base 10 addition.
    call base10add
    //Save results.
    [healthlo] = a

    //Prepare to add to HealthHi.
    a = [healthhi]
    [0x3] = a
    //Amount to add to HealthHi.
    a = [healthhichange]
    //($C3DA)Perform base 10 addition.
    call base10add
    //Save results.
    [healthhi] = a

    a = [tankcount]
    //($C2C5)*16. Move tank count to upper 4 bits.
    call amul16
    //Set lower 4 bits.
    a = a | 0xf
    compare a to [healthhi]
    //Is life less than max? if so, branch.
    goto _0086 when carry
    //Life is more than max amount.
    a = a & 0xf9
    [healthhi] = a
    //Set life to max amount.
    a = 0x99
    [healthlo] = a
def _0086:
    //($F323)
    goto clearhealthchange

//----------------------------------------------------------------------------------------------------

def game_engine_page_CF2E:
    a = [samushit]
    a = a >> 1
    a = a & 0x2
    goto _0089 when zero
    goto _0087 when carry
    a = [samushorzaccel]
    goto _0089 when negative
    goto _0088 when ~negative
def _0087:
    a = [samushorzaccel]
    goto _0088 when negative
    goto _0089 when ~zero
def _0088:
    //($C3D4)
    call twoscompliment
    [samushorzaccel] = a

def clearhorzmvmntdata:

    y = 0x0
def game_engine_page_CF4E:
    //Set Samus Horizontal speed and horizontal-->
    [objhorzspeed] = y
    //linear counter to #$00.
    [horzcntrlinear] = y
def _0089:
    return

def stophorzmovement:

def game_engine_page_CF55:
    //Is Samus moving horizontally?-->
    a = [samushorzaccel]
    //If so, branch to stop movement.
    goto clearhorzmvmtanimdata when ~zero
    //($CB96)Play walk SFX.
    call sfx_samuswalk

def clearhorzmvmtanimdata:

    //($CF81)Clear horizontal movement and animation delay data.
    call nohorzmovenodelay
    //Samus is standing.
    [objaction] = y
    a = [joy1.status]
    //Is The up button being pressed?-->
    a = a & 0x8
    //If so, branch.
    goto _008A when ~zero
    //Set Samus animation for standing.
    a = an_samusstand

def setsamusanim:

    //Set new animation reset index.
    [animresetindex] = a

def setsamusnextanim:

    //Set new animation data index.
    [animindex] = a
    a = 0x0
    //New animation to take effect immediately.
    [animdelay] = a
    return

def setsamuspntup:

def game_engine_page_CF77:
def _008A:
    a = sa_pntup
    //Samus is pointing up.
    [objaction] = a
    a = an_samuspntup
    //($CF6B)Set new animation values.
    call setsamusanim

def nohorzmovenodelay:

    //($CFB7)Clear all horizontal movement data.
    call clearhorzdata
    //Clear animation delay data.
    [animdelay] = y
    return

    a = [joy1.status]
    a = a & 0x3
    goto _008B when zero
    //($E1E1)
    call bitscan
    x = a
    call game_engine_page_CCB7
    a = [samusgravity]
    goto _008C when negative
    a = [animresetindex]
    compare a to an_samussalto
    goto _008C when zero
    [samusdir] = x
    a = [table06+1:x]
    goto setsamusanim

def _008B:
    a = [samusgravity]
    goto _008C when negative
    goto _008C when zero
    a = [animresetindex]
    compare a to an_samusjump
    goto _008C when ~zero

def clearhorzdata:

def game_engine_page_CFB7:
    //($CF4C)Clear horizontal speed and linear counter.
    call clearhorzmvmntdata
    //Clear horizontal acceleration data.
    [samushorzaccel] = y
def _008C:
    return

def game_engine_page_CFBE:
    y = an_samusjumppntup
    goto _008D

def setsamusjump:

def game_engine_page_CFC3:
    y = an_samusjump
def _008D:
    [animresetindex] = y
    y--
    [animindex] = y
    a = 0x4
    [animdelay] = a
    a = 0x0
    [samusjumpdsplcmnt] = a
    a = 0xfc
    [objvertspeed] = a
    x = [objaction]
    x--
    //branch if Samus is standing still
    goto _008E when ~zero
    a = [samusgear]
    a = a & gr_screwattack
    //branch if Samus doesn't have Screw Attack
    goto _008E when zero
    a = 0x0
    [0x686] = a
    call sfx_screwattack
def _008E:
    call sfx_samusjump
    //gravity (high value -> low jump)
    y = 0x18
    a = [samusgear]
    a = a & gr_highjump
    //branch if Samus doesn't have High Jump
    goto _008F when zero
    //lower gravity value -> high jump!
    y = 0x12
def _008F:
    [samusgravity] = y
    return

def samusjump:

    a = [samusjumpdsplcmnt]
    compare a & [objvertspeed]
    //branch if falling down
    goto _0090 when ~negative
    compare a to 0x20
    //branch if jumped less than 32 pixels upwards
    goto _0090 when ~carry
    compare a & [joy1.status]
    //branch if JUMP button still pressed
    goto _0090 when negative
    //($D147)Stop jump (start falling).
    call stopvertmovement
def _0090:
    call 0xd055
    call game_engine_page_CF2E
    a = [joy1.status]
    //UP pressed?
    a = a & 0x8
    //branch if not
    goto _0091 when zero
    a = an_samusjumppntup
    [animresetindex] = a
    //"jumping & pointing up" handler
    a = sa_pntjump
    [objaction] = a
def _0091:
    call game_engine_page_D09C
    a = [samusinlava]
    goto _0092 when zero
    a = [joy1.delta]
    //branch if JUMP not pressed
    goto _0092 when ~negative
    call game_engine_page_CFC3
    goto game_engine_page_CD6B

def _0092:
    a = [samusgravity]
    goto _0094 when ~zero
    a = [objaction]
    compare a to sa_pntjump
    goto _0093 when ~zero
    call game_engine_page_CF77
    goto _0094 when ~zero
def _0093:
    call game_engine_page_CF55
def _0094:
    a = 0x3
    //($CD6D)Set Samus control data and animation.
    goto setsamusdata

    x = 0x1
    y = 0x0
    a = [joy1.status]
    a = a >> 1
    //branch if RIGHT pressed
    goto _0095 when carry
    x--
    a = a >> 1
    //branch if LEFT not pressed
    goto _0098 when ~carry
    x--
    y++
def _0095:
    compare y to [samusdir]
    goto _0098 when zero
    a = [objaction]
    compare a to sa_pntjump
    goto _0096 when ~zero
    a = [animresetindex]
    compare a to [table04:y]
    goto _0097 when ~zero
    a = [table04+1:y]
    goto _0097

def _0096:
    a = [animresetindex]
    compare a to [table06:y]
    goto _0097 when ~zero
    a = [table06+1:y]
def _0097:
    call setsamusanim
    a = 0x8
    [animdelay] = a
    [samusdir] = y
def _0098:
    [objhorzspeed] = x
def _0099:
    return

// Table used by above subroutine

def table06:

    byte: 0xc
    byte: 0xc
    byte: 0xc
def table04:

    byte: 0x35
    byte: 0x35
    byte: 0x35

def game_engine_page_D09C:
    a = [joy1.delta]
    a = a | [joy1.retrigger]
    a = a << 1
    //exit if FIRE not pressed
    goto _0099 when ~negative
    a = [animresetindex]
    compare a to an_samusjumppntup
    goto _009A when ~zero
    goto game_engine_page_D275

def _009A:
    call game_engine_page_D210
    a = an_samusfirejump
    goto setsamusanim

def setsamusroll:

def game_engine_page_D0B5:
    a = [samusgear]
    a = a & gr_marumari
    //branch if Samus doesn't have Maru Mari
    goto _009B when zero
    a = [samusgravity]
    goto _009B when ~zero

//Turn Samus into ball
    x = [samusdir]
    a = an_samusroll
    [animresetindex] = a
    a = an_samusrunjump
    [animindex] = a
    a = [game_engine_page_CCC0:x]
    [samushorzaccel] = a
    a = 0x1
    [0x686] = a
    goto sfx_samusball

def _009B:
    a = sa_stand
    [objaction] = a
    return

// SamusRoll
// =========

def samusroll:

    a = [joy1.delta]
    //UP pressed?
    a = a & 0x8
    //branch if yes
    goto _009C when ~zero
    //JUMP pressed?
    compare a & [joy1.delta]
    //branch if no
    goto _009D when ~negative
def _009C:
    a = [joy1.status]
    //DOWN pressed?
    a = a & 0x4
    //branch if yes
    goto _009D when ~zero
//break out of "ball mode"
    a = [objrady]
    carry = 0
    a = a +# 0x8
    [objrady] = a
    call checkmoveup
    //branch if not possible to stand up
    goto _009D when ~carry
    x = 0x0
    call game_engine_page_E8BE
    [0x5] = x
    a = 0xf5
    [0x4] = a
    call game_engine_page_FD8F
    call game_engine_page_D638
    call game_engine_page_CF55
    [animindex]--
    //($D147)
    call stopvertmovement
    a = 0x4
    goto game_engine_page_D144

def _009D:
    a = [joy1.delta]
    //($E1E1)
    call bitscan
    compare a to 0x2
    goto _009E when carry
    [samusdir] = a
    a = an_samusroll
    call setsamusanim
def _009E:
    x = [samusdir]
    call game_engine_page_CCB7
    call game_engine_page_CF2E
    call checkbomblaunch
    a = [joy1.status]
    a = a & 0x3
    goto _009F when ~zero
    call game_engine_page_CFB7
def _009F:
    a = 0x2
def game_engine_page_D144:
    //($CD6D)Set Samus control data and animation.
    goto setsamusdata

def stopvertmovement:

    y = 0x0
    [objvertspeed] = y
    [vertcntrlinear] = y
    return

// CheckBombLaunch
// ===============
// This routine is called only when Samus is rolled into a ball.
// It does the following:
// - Checks if Samus has bombs
// - If so, checks if the FIRE button has been pressed
// - If so, checks if there are any object "slots" available
//   (only 3 bullets/bombs can be active at the same time)
// - If so, a bomb is launched.

def checkbomblaunch:

    a = [samusgear]
    a = a >> 1
    //exit if Samus doesn't have Bombs
    goto _00A1 when ~carry
    a = [joy1.delta]
    a = a | [joy1.retrigger]
    //bit 7 = status of FIRE button
    a = a << 1
    //exit if FIRE not pressed
    goto _00A1 when ~negative
    a = [objvertspeed]
    a = a | [samusonelevator]
    goto _00A1 when ~zero
    //try object slot D
    x = 0xd0
    a = [objaction:x]
    //launch bomb if slot available
    goto _00A0 when zero
    //try object slot E
    x = 0xe0
    a = [objaction:x]
    //launch bomb if slot available
    goto _00A0 when zero
    //try object slot F
    x = 0xf0
    a = [objaction:x]
    //no bomb slots available, exit
    goto _00A1 when ~zero
// launch bomb... give it same coords as Samus
def _00A0:
    a = [objecthi]
    [objecthi:x] = a
    a = [objectx]
    [objectx:x] = a
    a = [objecty]
    carry = 0
    //4 pixels further down than Samus' center
    a = a +# 0x4
    [objecty:x] = a
    a = wa_laybomb
    [objaction:x] = a
    call sfx_bomblaunch
def _00A1:
    return

def samuspntup:

    a = [joy1.status]
    //UP still pressed?
    a = a & 0x8
    //branch if yes
    goto _00A2 when ~zero
    //stand handler
    a = sa_stand
    [objaction] = a
def _00A2:
    a = [joy1.status]
    //DOWN, LEFT, RIGHT pressed?
    a = a & 0x7
    //branch if no
    goto _00A4 when zero
    //($E1E1)
    call bitscan
    compare a to 0x2
    goto _00A3 when carry
    [samusdir] = a
def _00A3:
    x = a
    a = [table07:x]
    [objaction] = a
def _00A4:
    a = [joy1.delta]
    a = a | [joy1.retrigger]
    a = a << 1
    //branch if FIRE not pressed
    goto _00A5 when ~negative
    //($D1EE)Shoot up.
    call fireweapon
def _00A5:
    compare a & [joy1.delta]
    //branch if JUMP not pressed
    goto _00A6 when ~negative
    a = sa_pntjump
    [objaction] = a
def _00A6:
    a = 0x4
    //($CD6D)Set Samus control data and animation.
    call setsamusdata
    a = [objaction]
    call choose_routine
        word: game_engine_page_CF55
        word: game_engine_page_CC98
        //($C45C)rts
        word: exit_sub
        word: game_engine_page_D0B5
        //($C45C)rts
        word: exit_sub
        //($C45C)rts
        word: exit_sub
        word: game_engine_page_CFBE
        //($C45C)rts
        word: exit_sub
        //($C45C)rts
        word: exit_sub
        //($C45C)rts
        word: exit_sub

// Table used by above subroutine
def table07:
    byte: sa_run
    byte: sa_run
    byte: sa_roll

def fireweapon:

    a = [joy1.status]
    a = a & 0x8
    goto game_engine_page_D210 when zero
    goto game_engine_page_D275

def game_engine_page_D1F7:
    y = 0xd0
def _00A7:
    a = [objaction:y]
    goto _00A8 when zero
    call yplus16
    goto _00A7 when ~zero
    y++
    return

def _00A8:
    [0x30a:y] = a
    a = [missiletoggle]
    goto _00A9 when zero
    compare y to 0xd0
def _00A9:
    return

def game_engine_page_D210:
    a = [metroidonsamus]
    goto _00AA when ~zero
    call game_engine_page_D1F7
    goto _00AA when ~zero
    call game_engine_page_D2EB
    call game_engine_page_D359
    call game_engine_page_D38E
    a = 0xc
    [0x30f:y] = a
    x = [samusdir]
    //get bullet speed
    a = [table99:x]
    //-4 or 4, depending on Samus' direction
    [objhorzspeed:y] = a
    a = 0x0
    [objvertspeed:y] = a
    a = 0x1
    [objectonscreen:y] = a
    call checkmissilelaunch
    a = [objaction:y]
    a = a << 1
    a = a | [samusdir]
    a = a & 0x3
    x = a
    a = [table08:x]
    [0x5] = a
    a = 0xfa
    [0x4] = a
    call game_engine_page_D306
    a = [samusgear]
    a = a & gr_longbeam
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a >>> 1
    a = a | [0x61f]
    [0x61f] = a
    x = [objaction:y]
    x--
    goto _00AA when ~zero
    call sfx_bulletfire
def _00AA:
    y = 0x9
def game_engine_page_D26B:
    a = y
    goto setsamusnextanim

def table08:

    byte: 0xc
    byte: 0xf4
    byte: 0x8
    byte: 0xf8

def table99:

    byte: 0x4
    byte: 0xfc

def game_engine_page_D275:
    a = [metroidonsamus]
    goto _00AB when ~zero
    call game_engine_page_D1F7
    goto _00AB when ~zero
    call game_engine_page_D2EB
    call game_engine_page_D38A
    call game_engine_page_D38E
    a = 0xc
    [0x30f:y] = a
    a = 0xfc
    [objvertspeed:y] = a
    a = 0x0
    [objhorzspeed:y] = a
    a = 0x1
    [objectonscreen:y] = a
    call game_engine_page_D340
    x = [samusdir]
    a = [table09+4:x]
    [0x5] = a
    a = [objaction:y]
    a = a & 0x1
    x = a
    a = [table09+6:x]
    [0x4] = a
    call game_engine_page_D306
    a = [samusgear]
    a = a & gr_longbeam
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a >>> 1
    a = a | [0x61f]
    [0x61f] = a
    a = [objaction:y]
    compare a to 0x1
    goto _00AB when ~zero
    call sfx_bulletfire
def _00AB:
    x = [samusdir]
    y = [table09:x]
    a = [samusgravity]
    goto _00AC when zero
    y = [table09+2:x]
def _00AC:
    a = [objaction]
    compare a to 0x1
    goto _00AD when zero
    goto game_engine_page_D26B

// Table used by above subroutine

def table09:

    byte: 0x26
    byte: 0x26
    byte: 0x34
    byte: 0x34
    byte: 0x1
    byte: 0xff
    byte: 0xec
    byte: 0xf0

def game_engine_page_D2EB:
    a = y
    x = a
    [objaction:x]++
    a = 0x2
    [objrady:y] = a
    [objradx:y] = a
    a = an_bullet

def setprojectileanim:

    [animresetindex:x] = a
    [animindex:x] = a
    a = 0x0
    [animdelay:x] = a
def _00AD:
    return

def game_engine_page_D306:
    x = 0x0
    call game_engine_page_E8BE
    a = y
    x = a
    call game_engine_page_FD8F
    a = x
    y = a
    goto game_engine_page_D638

def checkmissilelaunch:

    a = [missiletoggle]
    //exit if Samus not in "missile fire" mode
    goto exit4 when zero
    compare y to 0xd0
    goto exit4 when ~zero
    x = [samusdir]
    a = [missileanims:x]
def _00AE:
    call setbulletanim
    call sfx_missilelaunch
    //missile handler
    a = wa_missile
    [objaction:y] = a
    a = 0xff
    //# of frames projectile should last
    [0x30f:y] = a
    [missilecount]--
    //exit if not the last missile
    goto exit4 when ~zero
// Samus has no more missiles left
    //put Samus in "regular fire" mode
    [missiletoggle]--
    //update Samus' palette to reflect this
    goto selectsamuspal

def missileanims:

    byte: an_missileright
    byte: an_missileleft

def game_engine_page_D340:
    a = [missiletoggle]
    goto exit4 when zero
    compare y to 0xd0
    goto exit4 when ~zero
    a = 0x8f
    goto _00AE when ~zero

def setbulletanim:

    [animindex:y] = a
    [animresetindex:y] = a
    a = 0x0
    [animdelay:y] = a
def exit4:
    return

def game_engine_page_D359:
    a = [samusdir]
def _00AF:
    [0x502:y] = a
    compare a & [samusgear]
    //branch if Samus doesn't have Wave Beam
    goto exit4 when ~overflow
    a = [missiletoggle]
    goto exit4 when ~zero
    a = 0x0
    [0x501:y] = a
    [0x304:y] = a
    a = y
    /// 32
    call adiv32
    a = 0x0
    goto _00B0 when carry
    a = 0xc
def _00B0:
    [0x500:y] = a
    a = wa_wavebeam
    [objaction:y] = a
    a = an_wavebeam
    call setbulletanim
    goto sfx_wavefire

def game_engine_page_D38A:
    a = 0x2
    goto _00AF when ~zero
def game_engine_page_D38E:
    a = [missiletoggle]
    goto exit4 when ~zero
    a = [samusgear]
    //branch if Samus doesn't have Ice Beam
    goto exit4 when ~negative
    a = wa_icebeam
    [objaction:y] = a
    a = [0x61f]
    a = a | 0x1
    [0x61f] = a
    goto sfx_bulletfire

// SamusDoor
// =========

def samusdoor:

    a = [doorstatus]
    compare a to 0x5
    goto _00B7 when ~carry
    // move Samus out of door, how far depends on initial value of DoorDelay
    [doordelay]--
    goto moveoutdoor when ~zero
    // done moving
    a = a << 1
    goto _00B1 when ~carry
    a = a >> 1
    [doorstatus] = a
    goto _00B7 when ~zero
def _00B1:
    call 0xd48c
    call game_engine_page_ED65
    call 0x95ab
    a = [itemroommusicstatus]
    goto _00B3 when zero
    push a
    //start music
    call game_engine_page_D92C
    a = pop
    goto _00B3 when ~negative
    a = 0x0
    [itemroommusicstatus] = a
    goto _00B3 when zero
def _00B2:
    a = 0x80
    [itemroommusicstatus] = a
def _00B3:
    a = [kraidridleypresent]
    goto _00B4 when zero
    call game_engine_page_CC07
    a = 0x0
    [kraidridleypresent] = a
    //branch always
    goto _00B2 when zero
def _00B4:
    a = [samusdoordata]
    a = a & 0xf
    [objaction] = a
    a = 0x0
    [samusdoordata] = a
    [doorstatus] = a
    //($D147)
    call stopvertmovement

def moveoutdoor:

    a = [samusdoordir]
    //branch if door leads to the right
    goto _00B6 when zero
    y = [objectx]
    goto _00B5 when ~zero
    //toggle 9th bit of Samus' X coord
    call togglesamushi
def _00B5:
    [objectx]--
    goto _00B7

def _00B6:
    [objectx]++
    goto _00B7 when ~zero
    //toggle 9th bit of Samus' X coord
    call togglesamushi
def _00B7:
    //($CDFA)Check if Samus hit, blinking or Health low.
    call checkhealthstatus
    call setmirrorcntrlbit
    //display Samus
    goto drawframe

def samusdead:

def d41a:
    a = 0x1
    //($CD6D)Set Samus control data and animation.
    goto setsamusdata

def samusdead2:

    [animdelay]--
    return

// SamusElevator
// =============

def samuselevator:

    a = [elevatorstatus]
    compare a to 0x3
    goto _00B8 when zero
    compare a to 0x8
    goto _00BE when ~zero
def _00B8:
    a = [0x32f]
    goto _00BB when negative
    a = [objecty]
    carry = 1
    //A = Samus' Y position on the visual screen
    a = a -# [scroll.y]
    compare a to 0x84
    //if ScreenY < $84, don't scroll
    goto _00B9 when ~carry
    //otherwise, attempt to scroll
    call scrolldown
def _00B9:
    y = [objecty]
    //wrap-around required?
    compare y to 239
    goto _00BA when ~zero
    //toggle 9th bit of Samus' Y coord
    call togglesamushi
    //ObjectY will now be 0
    y = 0xff
def _00BA:
    y++
    [objecty] = y
    goto game_engine_page_D47E

def _00BB:
    a = [objecty]
    carry = 1
    //A = Samus' Y position on the visual screen
    a = a -# [scroll.y]
    compare a to 0x64
    //if ScreenY >= $64, don't scroll
    goto _00BC when carry
    //otherwise, attempt to scroll
    call scrollup
def _00BC:
    y = [objecty]
    //wraparound required? (branch if not)
    goto _00BD when ~zero
    //toggle 9th bit of Samus' Y coord
    call togglesamushi
    //ObjectY will now be 239
    y = 240
def _00BD:
    y--
    [objecty] = y
    goto game_engine_page_D47E

def _00BE:
    y = 0x0
    [objvertspeed] = y
    compare a to 0x5
    goto _00BF when zero
    compare a to 0x7
    goto _00BF when zero
def game_engine_page_D47E:
    a = [framecount]
    a = a >> 1
    goto _00C0 when ~carry
def _00BF:
    //($CD92)Mirror Samus, if necessary.
    call setmirrorcntrlbit
    a = 0x1
    goto animdrawobject
def _00C0:
    return

    x = 0x60
    carry = 1
def _00C1:
    call 0xd4b4
    a = x
    a = a -# 0x20
    x = a
    goto _00C1 when ~negative
    //($EB85)
    call getnametable
    y = a
    x = 0x18
def _00C2:
    call 0xd4a8
    a = x
    carry = 1
    a = a -# 0x8
    x = a
    goto _00C2 when ~zero
    a = y
    compare a to [0x72c:x]
    goto _00C3 when ~zero
    a = 0xff
    [0x728:x] = a
def _00C3:
    return

    a = [0x405:x]
    a = a & 0x2
    goto _00C4 when ~zero
    [enstatus:x] = a
def _00C4:
    return

// UpdateProjectiles
// =================

def updateprojectiles:

    x = 0xd0
    call dooneprojectile
    x = 0xe0
    call dooneprojectile
    x = 0xf0
def dooneprojectile:

    [pageindex] = x
    a = [objaction:x]
    call choose_routine
        //($C45C) rts
        word: exit_sub
        //regular beam
        word: updatebullet
        //wave beam
        word: updatewavebullet
        //ice beam
        word: updateicebullet
        //bullet/missile explode
        word: bulletexplode
        //lay bomb
        word: game_engine_page_D65E
        //lay bomb
        word: game_engine_page_D670
        //lay bomb
        word: game_engine_page_D691
        //lay bomb
        word: game_engine_page_D65E
        //bomb countdown
        word: game_engine_page_D670
        //bomb explode
        word: game_engine_page_D691
        //missile
        word: updatebullet

def updatebullet:

    a = 0x1
    [updatingprojectile] = a
    call game_engine_page_D5FC
    call game_engine_page_D5DA
    call game_engine_page_D609
def checkbulletstat:

    x = [pageindex]
    goto _00C5 when ~carry
    a = [samusgear]
    a = a & gr_longbeam
    //branch if Samus has Long Beam
    goto drawbullet when ~zero
    //decrement bullet timer
    [0x30f:x]--
    goto drawbullet when ~zero
    //timer hit 0, kill bullet
    a = 0x0
    [objaction:x] = a
    //branch always
    goto drawbullet when zero
def _00C5:
    a = [objaction:x]
    goto _00C6 when zero
    call game_engine_page_D5E4
def drawbullet:

    a = 0x1
    call animdrawobject
def _00C6:
    [updatingprojectile]--
    return

def _00C7:
    [0x500:x]++
def game_engine_page_D522:
    [0x500:x]++
    a = 0x0
    [0x501:x] = a
    //branch always
    goto _00C8 when zero

def updatewavebullet:

    a = 0x1
    [updatingprojectile] = a
    call game_engine_page_D5FC
    call game_engine_page_D5DA
    a = [0x502:x]
    a = a & 0xfe
    y = a
    a = [table0a:y]
    [0xa] = a
    a = [table0a+1:y]
    [0xb] = a
def _00C8:
    y = [0x500:x]
    a = [[0xa]:y]
    compare a to 0xff
    goto _00C9 when ~zero
    [0x500:x] = a
    goto game_engine_page_D522

def _00C9:
    compare a to [0x501:x]
    goto _00C7 when zero
    [0x501:x]++
    y++
    a = [[0xa]:y]
    call 0x8296
    x = [pageindex]
    [objvertspeed:x] = a
    a = [[0xa]:y]
    call 0x832f
    x = [pageindex]
    [objhorzspeed:x] = a
    y = a
    a = [0x502:x]
    a = a >> 1
    goto _00CA when ~carry
    a = y
    //($C3D4)
    call twoscompliment
    [objhorzspeed:x] = a
def _00CA:
    call game_engine_page_D609
    goto _00CB when carry
    call game_engine_page_D624
def _00CB:
    goto checkbulletstat

def table0a:

    //pointer to table #1 below
    word: table0c
    //pointer to table #2 below
    word: table0d

// Table #1 (size: 25 bytes)

def table0c:

    byte: 0x1
    byte: 0xf3
    byte: 0x1
    byte: 0xd3
    byte: 0x1
    byte: 0x93
    byte: 0x1
    byte: 0x13
    byte: 0x1
    byte: 0x53
    byte: 0x1
    byte: 0x73
    byte: 0x1
    byte: 0x73
    byte: 0x1
    byte: 0x53
    byte: 0x1
    byte: 0x13
    byte: 0x1
    byte: 0x93
    byte: 0x1
    byte: 0xd3
    byte: 0x1
    byte: 0xf3
    byte: 0xff

// Table #2 (size: 25 bytes)

def table0d:

    byte: 0x1
    byte: 0xb7
    byte: 0x1
    byte: 0xb5
    byte: 0x1
    byte: 0xb1
    byte: 0x1
    byte: 0xb9
    byte: 0x1
    byte: 0xbd
    byte: 0x1
    byte: 0xbf
    byte: 0x1
    byte: 0xbf
    byte: 0x1
    byte: 0xbd
    byte: 0x1
    byte: 0xb9
    byte: 0x1
    byte: 0xb1
    byte: 0x1
    byte: 0xb5
    byte: 0x1
    byte: 0xb7
    byte: 0xff

// UpdateIceBullet
// ===============

def updateicebullet:

    a = 0x81
    [objectcntrl] = a
    goto updatebullet

// BulletExplode
// =============
// bullet/missile explode

def bulletexplode:

    a = 0x1
    [updatingprojectile] = a
    a = [0x303:x]
    carry = 1
    a = a -# 0xf7
    goto _00CC when ~zero
    //kill bullet
    [objaction:x] = a
def _00CC:
    goto drawbullet

def game_engine_page_D5DA:
    a = [0x30a:x]
    goto exit5 when zero
    a = 0x0
    [0x30a:x] = a
def game_engine_page_D5E4:
    a = 0x1d
    y = [objaction:x]
    compare y to wa_bulletexplode
    goto exit5 when zero
    compare y to wa_missile
    goto _00CD when ~zero
    a = an_missileexplode
def _00CD:
    call setprojectileanim
    a = wa_bulletexplode
def _00CE:
    [objaction:x] = a
def exit5:
    return

def game_engine_page_D5FC:
    a = [objectonscreen:x]
    a = a >> 1
    goto exit5 when carry
def _00CF:
    a = 0x0
    //branch always
    goto _00CE when zero
def _00D0:
    goto game_engine_page_E81E

// bullet <--> background crash detection

def game_engine_page_D609:
    call getobjcoords
    y = 0x0
    //get tile # that bullet touches
    a = [[0x4]:y]
    compare a to 0xa0
    goto game_engine_page_D624 when carry
    call 0x95c0
    compare a to 0x4e
    goto _00D0 when zero
    call game_engine_page_D651
    goto _00D2 when ~carry
    carry = 0
    goto isblasttile

def game_engine_page_D624:
    x = [pageindex]
    a = [objhorzspeed:x]
    [0x5] = a
    a = [objvertspeed:x]
    [0x4] = a
    call game_engine_page_E8BE
    call game_engine_page_FD8F
    goto _00CF when ~carry
def game_engine_page_D638:
    a = [0x8]
    [objecty:x] = a
    a = [0x9]
    [objectx:x] = a
    a = [0xb]
    a = a & 0x1
    //branch always
    goto _00D1 when ~negative
def toggleobjecthi:

    a = [objecthi:x]
    a = a ^ 0x1
def _00D1:
    [objecthi:x] = a
def _00D2:
    return

def game_engine_page_D651:
    y = [inarea]
    compare y to 0x10
    goto _00D3 when zero
    compare a to 0x70
    goto _00D4 when carry
def _00D3:
    compare a to 0x80
def _00D4:
    return

def game_engine_page_D65E:
    a = an_bombtick
    call setprojectileanim
    //fuse length :-)
    a = 0x18
    [0x30f:x] = a
    //bomb update handler
    [objaction:x]++
def drawbomb:

    a = 0x3
    goto animdrawobject

def game_engine_page_D670:
    a = [framecount]
    a = a >> 1
    //only update counter on odd frames
    goto _00D6 when ~carry
    [0x30f:x]--
    goto _00D6 when ~zero
    a = 0x37
    y = [objaction:x]
    compare y to 0x9
    goto _00D5 when ~zero
    a = an_bombexplode
def _00D5:
    call setprojectileanim
    [objaction:x]++
    call sfx_bombexplode
def _00D6:
    goto drawbomb

def game_engine_page_D691:
    [0x30f:x]++
    call game_engine_page_D6A7
    x = [pageindex]
    a = [0x303:x]
    carry = 1
    a = a -# 0xf7
    goto _00D7 when ~zero
    //kill bomb
    [objaction:x] = a
def _00D7:
    goto drawbomb

def game_engine_page_D6A7:
    call getobjcoords
    a = [0x4]
    [0xa] = a
    a = [0x5]
    [0xb] = a
    x = [pageindex]
    y = [0x30f:x]
    y--
    goto _00D9 when zero
    y--
    goto _00DA when ~zero
    a = 0x40
    call game_engine_page_D78B
    a = x
    goto _00D8 when ~zero
    a = [0x4]
    a = a & 0x20
    goto exit6 when zero
def _00D8:
    a = [0x5]
    a = a & 0x3
    compare a to 0x3
    goto _00D9 when ~zero
    a = [0x4]
    compare a to 0xc0
    goto _00D9 when ~carry
    a = [scroll.dir]
    a = a & 0x2
    goto exit6 when ~zero
    a = 0x80
    call game_engine_page_D78B
def _00D9:
    call game_engine_page_D76A
def exit6:
    return

def _00DA:
    y--
    goto _00DD when ~zero
    a = 0x40
    call game_engine_page_D77F
    a = x
    goto _00DB when ~zero
    a = [0x4]
    a = a & 0x20
    goto exit6 when ~zero
def _00DB:
    a = [0x5]
    a = a & 0x3
    compare a to 0x3
    goto _00DC when ~zero
    a = [0x4]
    compare a to 0xc0
    goto _00DC when ~carry
    a = [scroll.dir]
    a = a & 0x2
    goto exit6 when ~zero
    a = 0x80
    call game_engine_page_D77F
def _00DC:
    goto game_engine_page_D76A

def _00DD:
    y--
    goto _00E0 when ~zero
    a = 0x2
    call game_engine_page_D78B
    a = x
    goto _00DE when ~zero
    a = [0x4]
    a = a >> 1
    goto exit7 when ~carry
def _00DE:
    a = [0x4]
    a = a & 0x1f
    compare a to 0x1e
    goto _00DF when ~carry
    a = [scroll.dir]
    a = a & 0x2
    goto exit7 when zero
    a = 0x1e
    call game_engine_page_D77F
    a = [0x5]
    a = a ^ 0x4
    [0x5] = a
def _00DF:
    goto game_engine_page_D76A

def _00E0:
    y--
    goto exit7 when ~zero
    a = 0x2
    call game_engine_page_D77F
    a = x
    goto _00E1 when ~zero
    a = [0x4]
    a = a >> 1
    goto exit7 when carry
def _00E1:
    a = [0x4]
    a = a & 0x1f
    compare a to 0x2
    goto game_engine_page_D76A when carry
    a = [scroll.dir]
    a = a & 0x2
    goto exit7 when zero
    a = 0x1e
    call game_engine_page_D78B
    a = [0x5]
    a = a ^ 0x4
    [0x5] = a
def game_engine_page_D76A:
    a = x
    push a
    y = 0x0
    a = [[0x4]:y]
    call game_engine_page_D651
    goto _00E2 when ~carry
    compare a to 0xa0
    goto _00E2 when carry
    call game_engine_page_E9C2
def _00E2:
    a = pop
    x = a
def exit7:
    return

def game_engine_page_D77F:
    carry = 0
    a = a +# [0xa]
    [0x4] = a
    a = [0xb]
    a = a +# 0x0
    goto game_engine_page_D798

def game_engine_page_D78B:
    [0x0] = a
    a = [0xa]
    carry = 1
    a = a -# [0x0]
    [0x4] = a
    a = [0xb]
    a = a -# 0x0
def game_engine_page_D798:
    a = a & 0x7
    a = a | 0x60
    [0x5] = a
def _00E3:
    return

def getobjcoords:

    x = [pageindex]
    a = [objecty:x]
    [0x2] = a
    a = [objectx:x]
    [0x3] = a
    a = [objecthi:x]
    [0xb] = a
    goto makewramptr

def updateelevator:
    x = 0x20
    [pageindex] = x
    a = [objaction:x]
    call choose_routine
        //($C45C) rts
        word: exit_sub
        word: elevatoridle
        word: game_engine_page_D80E
        word: elevatormove
        word: elevatorscroll
        word: game_engine_page_D8A3
        word: game_engine_page_D8BF
        word: game_engine_page_D8A3
        word: elevatormove
        word: elevatorstop

def elevatoridle:

    a = [samusonelevator]
    goto showelevator when zero
    a = 0x4
    //elevator direction in bit 7 (1 = up)
    compare a & [0x32f]
    goto _00E4 when ~negative
    //btn_UP
    a = a << 1
def _00E4:
    a = a & [joy1.status]
    goto showelevator when zero
    // start elevator!
    //($D147)
    call stopvertmovement
    [animdelay] = y
    [samusgravity] = y
    a = y
    [objvertspeed:x] = a
    [objaction:x]++
    a = sa_elevator
    [objaction] = a
    a = an_samusfront
    call setsamusanim
    a = 128
    //center
    [objectx] = a
    a = 112
    //center
    [objecty] = a
def showelevator:

    a = [framecount]
    a = a >> 1
    //only display elevator at odd frames
    goto _00E3 when ~carry
    //display elevator
    goto drawframe

def game_engine_page_D80E:
    a = [scroll.x]
    goto _00E5 when ~zero
    a = [video.mirror]
    a = a | 0x8
    [video.mirror] = a
    a = [scroll.dir]
    a = a & 0x1
    [scroll.dir] = a
    [objaction:x]++
    goto showelevator

def _00E5:
    a = 0x80
    [objectx] = a
    a = [objectx:x]
    carry = 1
    a = a -# [scroll.x]
    goto _00E6 when negative
    call scrollleft
    goto showelevator

def _00E6:
    call scrollright
    goto showelevator

def elevatormove:

    a = [0x30f:x]
    //branch if elevator going down
    goto _00E8 when ~negative
    // move elevator up one pixel
    y = [objecty:x]
    goto _00E7 when ~zero
    call toggleobjecthi
    y = 240
def _00E7:
    y--
    a = y
    [objecty:x] = a
    goto _00E9

    // move elevator down one pixel
def _00E8:
    [objecty:x]++
    a = [objecty:x]
    compare a to 240
    goto _00E9 when ~zero
    call toggleobjecthi
    a = 0x0
    [objecty:x] = a
def _00E9:
    compare a to 0x83
    //move until Y coord = $83
    goto _00EA when ~zero
    [objaction:x]++
def _00EA:
    goto showelevator

def elevatorscroll:

    a = [scroll.y]
    //scroll until ScrollY = 0
    goto elevscrollroom when ~zero
    a = 0x4e
    [animresetindex] = a
    a = 0x41
    [animindex] = a
    a = 0x5d
    [animresetindex:x] = a
    a = 0x50
    [animindex:x] = a
    [objaction:x]++
    a = 0x40
    [timer1] = a
    goto showelevator

def elevscrollroom:

    a = [0x30f:x]
    //branch if elevator going down
    goto _00EB when ~negative
    call scrollup
    goto showelevator

def _00EB:
    call scrolldown
    goto showelevator

def game_engine_page_D8A3:
    [objaction:x]++
    a = [objaction:x]
    //ElevatorMove
    compare a to 0x8
    goto _00EC when ~zero
    a = 0x23
    [0x303:x] = a
    a = an_samusfront
    call setsamusanim
    goto showelevator

def _00EC:
    a = 0x1
    goto animdrawobject

def game_engine_page_D8BF:
    a = [0x30f:x]
    y = a
    //Leads-To-Ending elevator?
    compare a to 0x8f
    goto _00ED when ~zero
    // Samus made it! YAY!
    a = 0x7
    [mainroutine] = a
    [atending]++
    y = 0x0
    [0x33] = y
    y++
    //switch to bank 0
    [switchpending] = y
    //ending
    a = 0x1d
    [titleroutine] = a
    return

def _00ED:
    a = y
    goto _00EF when ~negative
    y = 0x0
    compare a to 0x84
    goto _00EE when ~zero
    y++
def _00EE:
    a = y
def _00EF:
    a = a | 0x10
    call check_engine_running
    a = [paltoggle]
    a = a ^ 0x7
    [paltoggle] = a
    y = [inarea]
    compare y to 0x12
    goto _00F0 when ~carry
    a = 0x1
def _00F0:
    [video.palette_pending] = a
    call waitnmipass_
    call selectsamuspal
    //($LD92C)Start music.
    call startmusic
    call screenon
    call copyptrs
    call destroyenemies
    x = 0x20
    [pageindex] = x
    a = 0x6b
    [animresetindex] = a
    a = 0x5f
    [animindex] = a
    a = 0x7a
    [animresetindex:x] = a
    a = 0x6e
    [animindex:x] = a
    [objaction:x]++
    a = 0x40
    [timer1] = a
    return

def startmusic:

def game_engine_page_D92C:
    a = [elevatorstatus]
    compare a to 0x6
    goto _00F1 when ~zero
    a = [0x32f]
    goto _00F2 when negative
def _00F1:
    //Load proper bit flag for area music.
    a = [0x95cd]
    y = [itemroommusicstatus]
    goto _00F3 when negative
    goto _00F3 when zero
def _00F2:
    a = 0x81
    [itemroommusicstatus] = a
    //Set flag to play item room music.
    a = 0x20

def _00F3:
    a = a | [musicinitflag]
    //Store music flag info.
    [musicinitflag] = a
    return

def elevatorstop:

    a = [scroll.y]
    //scroll until ScrollY = 0
    goto _00F5 when ~zero
    a = sa_stand
    [objaction] = a
    call game_engine_page_CF55
    //#$20
    x = [pageindex]
    //ElevatorIdle
    a = 0x1
    [objaction:x] = a
    a = [0x30f:x]
    //switch elevator direction
    a = a ^ 0x80
    [0x30f:x] = a
    goto _00F4 when negative
    call togglescroll
    [video.mirror] = a
def _00F4:
    goto showelevator
def _00F5:
    goto elevscrollroom

def samusonelevatororenemy:

def game_engine_page_D976:
    a = 0x0
    //Assume Samus is not on an elevator or on a frozen enemy.
    [samusonelevator] = a
    [onfrozenenemy] = a
    y = a
    x = 0x50
    call game_engine_page_F186
def _00F6:
    a = [enstatus:x]
    compare a to 0x4
    goto _00F7 when ~zero
    call game_engine_page_F152
    call game_engine_page_F1BF
    call game_engine_page_F1FA
    goto _00F7 when carry
    call game_engine_page_D9BA
    goto _00F7 when ~zero
def d99a:
    //Samus is standing on a frozen enemy.
    [onfrozenenemy]++
    goto _00F8 when ~zero
def _00F7:
    call xminus16
    goto _00F6 when ~negative
def _00F8:
    a = [elevatorstatus]
    goto _00F9 when zero
    y = 0x0
    x = 0x20
    call game_engine_page_DC82
    goto _00F9 when carry
    call game_engine_page_D9BA
    goto _00F9 when ~zero
    //Samus is standing on elevator.
    [samusonelevator]++
def _00F9:
    return

def game_engine_page_D9BA:
    a = [0x10]
    a = a & 0x2
    goto _00FA when ~zero
    y = [0x11]
    y++
    compare y to [0x4]
    goto exit8 when zero
def _00FA:
    a = [samushit]
    a = a & 0x38
    a = a | [0x10]
    a = a | 0x40
    [samushit] = a
def exit8:
    return

// UpdateStatues
// =============

def updatestatues:

    a = 0x60
    [pageindex] = a
    y = [0x360]
    //exit if no statue present
    goto exit8 when zero
    y--
    goto _00FB when ~zero
    call game_engine_page_DAB0
    y = 0x1
    call game_engine_page_DAB0
    goto _00FB when carry
    [0x360]++
def _00FB:
    y = [0x360]
    compare y to 0x2
    goto _00FE when ~zero
    a = [kraidstatuestatus]
    goto _00FC when ~negative
    y = 0x2
    call game_engine_page_DAB0
def _00FC:
    a = [0x687c]
    goto _00FD when ~negative
    y = 0x3
    call game_engine_page_DAB0
def _00FD:
    goto _00FE when carry
    [0x360]++
def _00FE:
    x = 0x60
    call game_engine_page_DA1A
    x = 0x61
    call game_engine_page_DA1A
    goto game_engine_page_DADA

def game_engine_page_DA1A:
    call game_engine_page_DA3D
    call game_engine_page_DA7C
    a = x
    a = a & 0x1
    y = a
    a = [game_engine_page_DA3B:y]
    [0x363] = a
    a = [0x681b:x]
    goto _00FF when zero
    goto _00FF when negative
    a = [framecount]
    a = a >> 1
    //only display statue at odd frames
    goto _0100 when ~carry
def _00FF:
    //display statue
    goto drawframe

def game_engine_page_DA39:
    byte: 0x88
    byte: 0x68
def game_engine_page_DA3B:
    byte: 0x65
    byte: 0x66

def game_engine_page_DA3D:
    a = [0x304:x]
    goto _0100 when negative
    a = 0x1
    [0x304:x] = a
    a = [0x30f:x]
    a = a & 0xf
    goto _0100 when zero
    [0x304:x]++
    [0x30f:x]--
    a = [0x30f:x]
    a = a & 0xf
    goto _0100 when ~zero
    a = [0x304:x]
    a = a | 0x80
    [0x304:x] = a
    [0x681b:x] = a
    [0x304:x]++
    a = x
    push a
    a = a & 0x1
    push a
    y = a
    call game_engine_page_DAB0
    a = pop
    y = a
    y++
    y++
    call game_engine_page_DAB0
    a = pop
    x = a
def _0100:
    return

def game_engine_page_DA7C:
    a = [0x30f:x]
    [0x36d] = a
    a = x
    a = a & 0x1
    y = a
    a = [game_engine_page_DA39:y]
    [0x36e] = a
    a = [0x681b:x]
    goto _0101 when zero
    goto _0101 when negative
    a = [0x304:x]
    compare a to 0x1
    goto _0101 when ~zero
    a = [0x306:x]
    goto _0101 when zero
    [0x30f:x]--
    a = [0x683]
    a = a | 0x10
    [0x683] = a
def _0101:
    a = 0x0
    [0x306:x] = a
    return

def game_engine_page_DAB0:
    a = [table0e:y]
    [0x5c8] = a
    a = [0x36c]
    a = a << 1
    a = a << 1
    a = a | [table1b:y]
    [0x5c9] = a
    a = 0x9
    [0x5c3] = a
    a = 0xc0
    [pageindex] = a
    call drawtileblast
    a = 0x60
    [pageindex] = a
    return

// Table used by above subroutine

def table0e:

    byte: 0x30
    byte: 0xac
    byte: 0xf0
    byte: 0x6c
def table1b:

    byte: 0x61
    byte: 0x60
    byte: 0x60
    byte: 0x60

def game_engine_page_DADA:
    a = [0x54]
    goto exit0 when negative
    a = [doorstatus]
    goto exit0 when ~zero
    a = [kraidstatuestatus]
    a = a & [0x687c]
    goto exit0 when ~negative
    [0x54] = a
    x = 0x70
    y = 0x8
def _0102:
    a = 0x3
    [0x500:x] = a
    a = y
    a = a << 1
    [0x507:x] = a
    a = 0x4
    [tiletype:x] = a
    a = [0x36c]
    a = a << 1
    a = a << 1
    a = a | 0x62
    [tilewramhi:x] = a
    a = y
    a = a << 1
    a = a +# 0x8
    [tilewramlo:x] = a
    call xminus16
    y--
    goto _0102 when ~zero
def exit0:
    return

// CheckMissileToggle
// ==================
// Toggles between bullets/missiles (if Samus has any missiles).

def checkmissiletoggle:

    a = [missilecount]
    //exit if Samus has no missiles
    goto exit0 when zero
    a = [joy1.delta]
    a = a | [joy1.retrigger]
    a = a & 0x20
    //exit if SELECT not pressed
    goto exit0 when zero
    a = [missiletoggle]
    //0 = fire bullets, 1 = fire missiles
    a = a ^ 0x1
    [missiletoggle] = a
    goto selectsamuspal

// MakeBitMask
// ===========
// in: Y = bit index
// out: A = bit Y set, other 7 bits zero

def makebitmask:

    carry = 1
    a = 0x0
def _0103:
    a = a <<< 1
    y--
    goto _0103 when ~negative
def _0104:
    return

// UpdateItems
// ===========

def updateitems:

    a = 0x40
    [pageindex] = a
    //Check first item slot.
    x = 0x0
    //($DB42)Check current item slot.
    call checkoneitem
    //Check second item slot.
    x = 0x8

def checkoneitem:

    //First or second item slot index(#$00 or #$08).
    [itemindex] = x
    y = [poweruptype:x]
    //Is no item present in item slot(#$FF)?-->
    y++
    //If so, branch to exit.
    goto _0104 when zero

    a = [powerupycoord:x]
    [0x34d] = a
    a = [powerupxcoord:x]
    [0x34e] = a
    a = [powerupnametable:x]
    [0x34c] = a
    call getobjcoords
    x = [itemindex]
    y = 0x0
    a = [[0x4]:y]
    compare a to 0xa0
    goto _0104 when ~carry
    a = [poweruptype:x]
    a = a & 0xf
    a = a | 0x50
    [0x343] = a
    a = [framecount]
    a = a >> 1
    a = a & 0x3
    a = a | 0x80
    [objectcntrl] = a
    a = [spritepagepos]
    push a
    a = [0x74f:x]
    //display special item
    call drawframe
    a = pop
    compare a to [spritepagepos]
    goto exit9 when zero
    x = a
    y = [itemindex]
    a = [poweruptype:y]
    y = 0x1
    compare a to 0x7
    goto _0105 when zero
    y--
    compare a to 0x6
    goto _0105 when zero
    compare a to 0x2
    goto _0106 when ~zero
def _0105:
    a = y
    [sprite01ram+2:x] = a
    a = 0xff
def _0106:
    push a
    x = 0x0
    y = 0x40
    call game_engine_page_DC7F
    a = pop
    goto exit9 when carry
    y = a
    call powerupmusic
    x = [itemindex]
    y++
    goto _0107 when zero
    a = [powerupnametable:x]
    [0x8] = a
    a = [poweruptype:x]
    [0x9] = a
    call game_engine_page_DC1C
def _0107:
    a = [poweruptype:x]
    y = a
    compare y to 0x8
    goto _010B when carry
    compare y to 0x6
    goto _0108 when ~carry
    a = [samusgear]
    a = a & 0x3f
    [samusgear] = a
def _0108:
    call makebitmask
    a = a | [samusgear]
    [samusgear] = a
def _0109:
    a = 0xff
    [powerupdelay] = a
    [poweruptype:x] = a
    y = [itemroommusicstatus]
    goto _010A when zero
    y = 0x1
def _010A:
    [itemroommusicstatus] = y
    goto selectsamuspal
def exit9:
    return

def _010B:
    goto _010C when zero
    a = 5
    call addtomaxmissiles
    //branch always
    goto _0109 when ~zero
def _010C:
    a = [tankcount]
    //has Samus got 6 energy tanks?
    compare a to 0x6
    //then she can't have any more
    goto _010D when zero
    //otherwise give her a new tank
    [tankcount]++
def _010D:
    a = [tankcount]
    //shift into upper nibble
    call amul16
    a = a | 0x9
    [healthhi] = a
    a = 0x99
    //health is now FULL!
    [healthlo] = a
    //branch always
    goto _0109 when ~zero

def game_engine_page_DC1C:
    a = [mapposx]
    [0x7] = a
    a = [mapposy]
    [0x6] = a
    a = [scroll.dir]
    a = a >> 1
    push p
    goto _010E when zero
    goto _010F when ~carry
    a = [scroll.x]
    goto _010F when zero
    [0x7]--
    goto _010F when carry
def _010E:
    goto _010F when ~carry
    a = [scroll.y]
    goto _010F when zero
    [0x6]--
def _010F:
    a = [video.ctrl]
    a = a ^ [0x8]
    a = a & 0x1
    p = pop
    carry = 0
    goto _0110 when zero
    a = a +# [0x7]
    [0x7] = a
    goto game_engine_page_DC51

def _0110:
    a = a +# [0x6]
    [0x6] = a
def game_engine_page_DC51:
    //($DC67)
    call createitemid
def game_engine_page_DC54:
    y = [numberofuniqueitems]
    a = [0x6]
    [uniqueitemhistory:y] = a
    a = [0x7]
    [uniqueitemhistory+1:y] = a
    y++
    y++
    [numberofuniqueitems] = y
    return

//------------------------------------------[ Create item ID ]-----------------------------------------

//The following routine creates a unique two byte item ID number for that item.  The description
//of the format of the item ID number is as follows:
//
//IIIIIIXX XXXYYYYY. I = item type, X = X coordinate on world map, Y = Y coordinate
//on world map.  The items have the following values of IIIIII:
//High jump     = 000001
//Long beam     = 000010 (Not considered a unique item).
//Screw attack  = 000011
//Maru Mari     = 000100
//Varia suit    = 000101
//Wave beam     = 000110 (Not considered a unique item).
//Ice beam      = 000111 (Not considered a unique item).
//Energy tank   = 001000
//Missiles      = 001001
//Missile door  = 001010
//Bombs         = 001100
//Mother brain  = 001110
//1st Zeebetite = 001111
//2nd Zeebetite = 010000
//3rd Zeebetite = 010001
//4th Zeebetite = 010010
//5th Zeebetite = 010011
//
//The results are stored in $06(upper byte) and $07(lower byte).

def createitemid:

    //Load x map position of item.
    a = [0x7]
    //($C2C$)*32. Move lower 3 bytes to upper 3 bytes.
    call amul32
    //combine Y coordinates into data byte.
    a = a | [0x6]
    //Lower data byte complete. Save in $06.
    [0x6] = a
    [0x7] = [0x7] >> 1
    //Move upper two bits of X coordinate to LSBs.
    [0x7] = [0x7] >> 1
    [0x7] = [0x7] >> 1
    //Load item type bits.
    a = [0x9]
    //Move the 6 bits of item type to upper 6 bits of byte.
    a = a << 1
    a = a << 1
    //Add upper two bits of X coordinate to byte.
    a = a | [0x7]
    //Upper data byte complete. Save in #$06.
    [0x7] = a
    return

//-----------------------------------------------------------------------------------------------------

def game_engine_page_DC7F:
    call game_engine_page_F186
def game_engine_page_DC82:
    call game_engine_page_F172
    call game_engine_page_F1A7
    goto game_engine_page_F1FA

//The following table is used to rotate the sprites of both Samus and enemies when they explode.

def exploderotationtbl:

    //No sprite flipping.
    byte: 0x0
    //Flip sprite vertically.
    byte: 0x80
    //Flip sprite vertically and horizontally.
    byte: 0xc0
    //Flip sprite horizontally.
    byte: 0x40

// UpdateObjAnim
// =============
// Advance to object's next frame of animation

def updateobjanim:

    x = [pageindex]
    y = [animdelay:x]
    //is it time to advance to the next anim frame?
    goto _0111 when zero
    //nope
    [animdelay:x]--
    //exit if still not zero (don't update animation)
    goto _0113 when ~zero
def _0111:
    //set initial anim countdown value
    [animdelay:x] = a
    y = [animindex:x]
def _0112:
    //($8572)Load frame number.
    a = [objectanimindextbl:y]
    //has end of anim been reached?
    compare a to 0xff
    goto _0114 when zero
    //store frame number
    [animframe:x] = a
    //inc anim index
    y++
    a = y
    //store anim index
    [animindex:x] = a
def _0113:
    return

def _0114:
    //reset anim frame index
    y = [animresetindex:x]
    //do first frame of animation
    goto _0112

    push a
    a = 0x0
    [0x6] = a
    a = pop
    goto _0115 when ~negative
    [0x6]--
def _0115:
    carry = 0
    return

//--------------------------------[ Get sprite control byte ]-----------------------------------------

//The sprite control byte extracted from the frame data has the following format: AABBXXXX.
//Where AA are the two bits used to control the horizontal and verticle mirroring of the
//sprite and BB are the two bits used control the sprite colors. XXXX is the entry number
//in the PlacePtrTbl used to place the sprite on the screen.

def getspritecntrldata:

    y = 0x0
    //Clear index into placement data.
    [0xf] = y
    //Load control byte from frame pointer data.
    a = [[0x0]:y]
    //Store value in $04 for processing below.
    [0x4] = a
    //Keep a copy of the value in x as well.
    x = a
    //($C2BF)Move upper 4 bits to lower 4 bits.
    call adiv16
    a = a & 0x3
    //The following lines take the upper 4 bits in the-->
    [0x5] = a
    //control byte and transfer bits 4 and 5 into $05 bits 0-->
    a = x
    //and 1(sprite color bits).  Bits 6 and 7 are-->
    a = a & 0xc0
    //transferred into $05 bits 6 and 7(sprite flip bits).-->
    a = a | 0x20
    //bit 5 is then set(sprite always drawn behind background).
    a = a | [0x5]
    [0x5] = a
    //Extract bit from control byte that controls the
    a = [objectcntrl]
    //object mirroring.
    a = a & 0x10
    a = a << 1
    a = a << 1
    //Move it to the bit 6 position and use it to flip the-->
    a = a ^ [0x4]
    //horizontal mirroring of the sprite if set.
    [0x4] = a
    a = [objectcntrl]
    //If MSB is set in ObjectCntrl, use its flip bits(6 and 7).
    goto _0116 when ~negative
    [objectcntrl] = [objectcntrl] << 1
    //($E038)Use object flip bits as priority over sprite flip bits.
    call spriteflipbitsoveride
def _0116:
    //Discard upper nibble so only entry number into-->
    a = x
    //PlacePtrTbl remains.
    a = a & 0xf
    //*2. pointers in PlacePntrTbl are 2 bytes in size.
    a = a << 1
    //Transfer to X to use as an index to find proper-->
    x = a
    //placement data segment.
    return

//-----------------------------------------------------------------------------------------------------

def game_engine_page_DCF5:
    //($DF2D)Clear object control byte.
    call clearobjectcntrl
    a = pop
    a = pop
    x = [pageindex]
def game_engine_page_DCFC:
    a = [inarea]
    compare a to 0x13
    goto _0117 when ~zero
    a = [endataindex:x]
    compare a to 0x4
    goto _011B when zero
    compare a to 0x2
    goto _011B when zero
def _0117:
    a = [0x40c:x]
    a = a << 1
    goto game_engine_page_DD75 when negative
    call game_engine_page_F74B
    [0x0] = a
    call 0x80b0
    a = a & 0x20
    [endataindex:x] = a
    a = 0x5
    [enstatus:x] = a
    a = 0x60
    [0x40d:x] = a
    a = [randomnumber1]
    compare a to 0x10
    goto game_engine_page_DD5B when ~carry
def _0118:
    a = a & 0x7
    y = a
    a = [itemdroptbl:y]
    [enanimframe:x] = a
    compare a to 0x80
    goto _011A when ~zero
    y = [maxmissilepickup]
    compare y to [currentmissilepickups]
    goto game_engine_page_DD5B when zero
    a = [maxmissiles]
    goto game_engine_page_DD5B when zero
    [currentmissilepickups]++
def _0119:
    return

def _011A:
    y = [maxenergypickup]
    compare y to [currentenergypickups]
    goto game_engine_page_DD5B when zero
    [currentenergypickups]++
    compare a to 0x89
    goto _0119 when ~zero
    [0x0] = [0x0] >> 1
    goto _0119 when carry

def game_engine_page_DD5B:
    x = [pageindex]
    a = [inarea]
    compare a to 0x13
    goto _011C when zero
def _011B:
    //($FA18)Free enemy data slot.
    goto killobject

def _011C:
    a = [randomnumber1]
    y = 0x0
    [currentenergypickups] = y
    [currentmissilepickups] = y
    y++
    [maxmissilepickup] = y
    [maxenergypickup] = y
    goto _0118 when ~zero

def game_engine_page_DD75:
    call powerupmusic
    a = [inarea]
    a = a & 0xf
    [minibosskilldelay] = a
    a = a >> 1
    y = a
    [maxmissiles:y] = a
    a = 75
    call addtomaxmissiles
    goto game_engine_page_DD5B when ~zero

def game_engine_page_DD8B:
    x = [pageindex]
    a = [enanimframe:x]
    compare a to 0xf7
    goto _011F when ~zero
    //($DF2D)Clear object control byte.
    goto clearobjectcntrl

// AddToMaxMissiles
// ================
// Adds A to both MissileCount & MaxMissiles, storing the new count
// (255 if it overflows)

def addtomaxmissiles:

    //Temp storage of # of missiles to add.
    push a
    carry = 0
    a = a +# [missilecount]
    goto _011D when ~carry
    a = 0xff
def _011D:
    [missilecount] = a
    a = pop
    carry = 0
    a = a +# [maxmissiles]
    goto _011E when ~carry
    a = 0xff
def _011E:
    [maxmissiles] = a
    return

def _011F:
    a = [enyroompos:x]
    //Y coord
    [0xa] = a
    a = [enxroompos:x]
    //X coord
    [0xb] = a
    a = [ennametable:x]
    //hi coord
    [0x6] = a
    a = [enanimframe:x]
    a = a << 1
    y = a
    a = [[0x41]:y]
    goto _0120 when ~carry
    a = [[0x43]:y]
def _0120:
    [0x0] = a
    y++
    a = [[0x41]:y]
    goto _0121 when ~carry
    a = [[0x43]:y]
def _0121:
    [0x1] = a
    //($DCC3)Get place pointer index and sprite control data.
    call getspritecntrldata
    y = a
    a = [[0x45]:y]
    [0x2] = a
    y++
    a = [[0x45]:y]
    [0x3] = a
    y = 0x0
    compare x to 0x2
    goto _0122 when ~zero
    x = [pageindex]
    [encounter:x]++
    a = [encounter:x]
    push a
    a = a & 0x3
    x = a
    a = [0x5]
    a = a & 0x3f
    a = a | [exploderotationtbl:x]
    [0x5] = a
    a = pop
    compare a to 0x19
    goto _0122 when ~zero
    goto game_engine_page_DCF5

def _0122:
    x = [pageindex]
    y++
    a = [[0x0]:y]
    [enrady:x] = a
    //($DE3D)Reduce temp y radius by #$10.
    call reduceyradius
    y++
    a = [[0x0]:y]
    [enradx:x] = a
    [0x9] = a
    y++
    [0x11] = y
    //($DFDF)Determine if object is within screen boundaries.
    call isobjectvisible
    a = x
    a = a << 1
    [0x8] = a
    x = [pageindex]
    a = [0x405:x]
    a = a & 0xfd
    a = a | [0x8]
    [0x405:x] = a
    a = [0x8]
    goto _0124 when zero
    goto game_engine_page_DEDE

//----------------------------------------[ Item drop table ]-----------------------------------------

//The following table determines what, if any, items an enemy will drop when it is killed.

def itemdroptbl:

    //Missile.
    byte: 0x80
    //Energy.
    byte: 0x81
    //No item.
    byte: 0x89
    //Missile.
    byte: 0x80
    //Energy.
    byte: 0x81
    //No item.
    byte: 0x89
    //Energy.
    byte: 0x81
    //No item.
    byte: 0x89

//------------------------------------[ Object drawing routines ]-------------------------------------

//The following function effectively sets an object's temporary y radius to #$00 if the object
//is 4 tiles tall or less.  If it is taller, #$10 is subtracted from the temporary y radius.

def reduceyradius:

    carry = 1
    //Subtract #$10 from object y radius.
    a = a -# 0x10
    //If number is still a positive number, branch to store value.
    goto _0123 when carry
    //Number is negative.  Set Y radius to #$00.
    a = 0x0
def _0123:
    //Store result and return.
    [0x8] = a
    return

def animdrawobject:

def game_engine_page_DE47:
    //($DC8F)Update animation if needed.
    call updateobjanim

def drawframe:

    //Get index to proper object to work with.
    x = [pageindex]
    a = [animframe:x]
    //Is the frame valid?-->
    compare a to 0xf7
    //Branch if yes.
    goto _0125 when ~zero
def _0124:
    //($DF2D)Clear object control byte.
    goto clearobjectcntrl
def _0125:
    //Is the animation of Samus facing forward?-->
    compare a to 0x7
    //If not, branch.
    goto _0126 when ~zero

    //Ensure object mirroring bit is clear so Samus'-->
    a = [objectcntrl]
    //sprite appears properly when going up and down-->
    a = a & 0xef
    //elevators.
    [objectcntrl] = a

def _0126:
    a = [objecty:x]
    [0xa] = a
    //Copy object y and x room position and name table-->
    a = [objectx:x]
    //data into $0A, $0B and $06 respectively.
    [0xb] = a
    a = [objecthi:x]
    [0x6] = a
    //Load A with index into FramePtrTable.
    a = [animframe:x]
    //*2. Frame pointers are two bytes.
    a = a << 1
    //X is now the index into the FramePtrTable.
    x = a
    a = [frameptrtable:x]
    [0x0] = a
    //Entry from FramePtrTable is stored in $0000.
    a = [frameptrtable+1:x]
    [0x1] = a
    //($DCC3)Get place pointer index and sprite control data.
    call getspritecntrldata
    a = [placeptrtable:x]
    [0x2] = a
    //Store pointer from PlacePtrTbl in $0002.
    a = [placeptrtable+1:x]
    [0x3] = a
    //Is Samus the object being drawn?-->
    a = [issamus]
    //If not, branch.
    goto _0127 when zero

//Special case for Samus exploding.
    //Is Samus exploding?-->
    compare x to 0xe
    //If not, branch to skip this section of code.
    goto _0127 when ~zero
    //X=0.
    x = [pageindex]
    //Incremented every frame during explode sequence.-->
    [objectcounter]++
    //Bottom two bits used for index into ExplodeRotationTbl.
    a = [objectcounter]
    //Save value of A.
    push a
    //Use 2 LSBs for index into ExplodeRotationTbl.
    a = a & 0x3
    x = a
    //Drop mirror control bits from sprite control byte.
    a = [0x5]
    a = a & 0x3f
    //Use mirror control bytes from table(Base is $DC8B).
    a = a | [exploderotationtbl:x]
    //Save modified sprite control byte.
    [0x5] = a
    //Restore A
    a = pop
    //After 25 frames, Move on to second part of death-->
    compare a to 0x19
    //handler, else branch to skip the rest of this code.
    goto _0127 when ~zero
    //X=0.
    x = [pageindex]
    a = sa_dead2
    //Move to next part of the death handler.
    [objaction:x] = a
    a = 0x28
    //Set animation delay for 40 frames(.667 seconds).
    [animdelay:x] = a
    //Pull last return address off of the stack.
    a = pop
    a = pop
    //($DF2D)Clear object control byte.
    goto clearobjectcntrl

def _0127:
    x = [pageindex]
    //Increment to second frame data byte.
    y++
    a = [[0x0]:y]
    //Get verticle radius in pixles of object.
    [objrady:x] = a
    //($DE3D)Reduce temp y radius by #$10.
    call reduceyradius
    //Increment to third frame data byte.
    y++
    //Get horizontal radius in pixels of object.
    a = [[0x0]:y]
    [objradx:x] = a
    //Temp storage for object x radius.
    [0x9] = a
    //Set index to 4th byte of frame data.
    y++
    //Store current index into frame data.
    [0x11] = y
    //($DFDF)Determine if object is within the screen boundaries.
    call isobjectvisible
    a = x
    //Get index to object.
    x = [pageindex]
    //Store visibility status of object.
    [objectonscreen:x] = a
    x = a
    //Branch if object is not within the screen boundaries.
    goto _0128 when zero
def game_engine_page_DEDE:
    //Load index into next unused sprite RAM segment.
    x = [spritepagepos]
    //($DF19)Start drawing object.
    goto drawspriteobject

def _0128:
    //($DF2D)Clear object control byte then exit.
    goto clearobjectcntrl

def writespriteram:

def _0129:
    //Load index for placement data.
    y = [0xf]
    //($DF6B)Get displacement for y direction.
    call ydisplacement
    //Add initial Y position.
    a = a +# [0x10]
    //Store sprite Y coord.
    [sprite00ram:x] = a
    //Because PPU uses Y + 1 as real Y coord.
    [sprite00ram:x]--
    //Increment index to next byte of placement data.
    [0xf]++
    //Get index to frame data.
    y = [0x11]
    //Tile value.
    a = [[0x0]:y]
    //Store tile value in sprite RAM.
    [sprite00ram+1:x] = a
    a = [objectcntrl]
    //Move horizontal mirror control byte to bit 6 and-->
    a = a << 1
    //discard all other bits.
    a = a << 1
    a = a & 0x40
    //Use it to override sprite horz mirror bit.
    a = a ^ [0x5]
    //Store sprite control byte in sprite RAM.
    [sprite00ram+2:x] = a
    //Increment to next byte of frame data.
    [0x11]++
    //Load index for placement data.
    y = [0xf]
    //($DFA3)Get displacement for x direction.
    call xdisplacement
    //Add initial X pos
    a = a +# [0xe]
    //Store sprite X coord
    [sprite00ram+3:x] = a
    //Increment to next placement data byte.
    [0xf]++
    x++
    x++
    //Advance to next sprite.
    x++
    x++

def drawspriteobject:

    //Get index into frame data.
    y = [0x11]

def getnextframebyte:

    //Get next frame data byte.
    a = [[0x0]:y]
    //If byte < #$FC, byte is tile data. If >= #$FC, byte is-->
    compare a to 0xfc
    //frame data control info. Branch to draw sprite.
    goto writespriteram when ~carry
    //#$FC changes object's x and y position.
    goto offsetobjectposition when zero
    compare a to 0xfd
    //#$FD sets new control byte information for the next sprites.
    goto getnewcontrolbyte when zero
    //#$FE skips next sprite placement x and y bytes.
    compare a to 0xfe
    goto skipplacementdata when zero
    //Keep track of current position in sprite RAM.
    [spritepagepos] = x

def clearobjectcntrl:

    a = 0x0
    //Clear object control byte.
    [objectcntrl] = a
    return

def skipplacementdata:

def _012A:
    //Skip next y and x placement data bytes.
    [0xf]++
    [0xf]++
    //Increment to next data item in frame data.
    [0x11]++
    //($DF19)Draw next sprite.
    goto drawspriteobject

def getnewcontrolbyte:

def _012B:
    //Increment index to next byte of frame data.
    y++
    //If MSB of ObjectCntrl is not set, no overriding of-->
    [objectcntrl] = [objectcntrl] << 1
    //flip bits needs to be performed.
    goto _012C when ~carry
    //($E038)Use object flip bits as priority over sprite flip bits.
    call spriteflipbitsoveride
    //Branch always.
    goto _012D when ~zero
def _012C:
    //Restore MSB of ObjectCntrl.
    [objectcntrl] = [objectcntrl] >> 1
    a = [[0x0]:y]
    //Save new sprite control byte.
    [0x5] = a
def _012D:
    //Increment past sprite control byte.
    y++
    //Save index of frame data.
    [0x11] = y
    //($DF1B)Load next frame data byte.
    goto getnextframebyte

def offsetobjectposition:

def _012E:
    //Increment index to next byte of frame data.
    y++
    //This data byte is used to offset the object from-->
    a = [[0x0]:y]
    //its current y positon.
    carry = 0
    a = a +# [0x10]
    //Add offset amount to object y screen position.
    [0x10] = a
    [0x11]++
    //Increment past control byte and y offset byte.
    [0x11]++
    y = [0x11]
    //Load x offset data byte.
    a = [[0x0]:y]
    carry = 0
    //Add offset amount to object x screen position.
    a = a +# [0xe]
    [0xe] = a
    //Increment past x offset byte.
    [0x11]++
    //($DF19)Draw next sprite.
    goto drawspriteobject

//----------------------------------[ Sprite placement routines ]-------------------------------------

def ydisplacement:

    //Load placement data byte.
    a = [[0x2]:y]
    y = a
    //Check to see if this is placement data for the object-->
    a = a & 0xf0
    //exploding.  If so, branch.
    compare a to 0x80
    goto _0130 when zero
    //Restore placement data byte to A.
    a = y
def _012F:
    compare a & [0x4]
    //Branch if MSB in $04 is set(Flips object).
    goto negativedisplacement when negative
    //Clear carry before returning.
    carry = 0
    return

def explodeydisplace:

def _0130:
    //Transfer placement byte back into A.
    a = y
    //Discard bits 7,6,5,4 and 0.
    a = a & 0xe
    ///2.
    a = a >> 1
    y = a
    //Index into ExplodePlacementTbl.
    a = [explodeindextbl:y]
    y = [issamus]
    //Is Samus the object exploding? if so, branch.
    goto _0131 when ~zero
    //Load index to proper enemy data.
    y = [pageindex]
    //Increment every frame enemy is exploding. Initial=#$01.
    a = a +# [encounter:y]
    //Jump to load explode placement data.
    goto _0132


//Special case for Samus exploding.
def _0131:
    //Increments every frame Samus is exploding. Initial=#$01.
    a = a +# [objectcounter]
def _0132:
    y = a
    //Get data from ExplodePlacementTbl.
    a = [explodeindextbl+2:y]
    //Save data on stack.
    push a
    //Load placement data index.
    a = [0xf]
    carry = 0
    //Move index forward by 12 bytes. to find y-->
    a = a +# 0xc
    //placement data.
    y = a
    //Restore A with ExplodePlacementTbl data.
    a = pop
    carry = 0
    //Add table displacements with sprite placement data.
    a = a +# [[0x2]:y]
    //Branch to add y placement values to sprite coords.
    goto _012F

def xdisplacement:

    //Load placement data byte.
    a = [[0x2]:y]
    y = a
    //Check to see if this is placement data for the object-->
    a = a & 0xf0
    //exploding.  If so, branch.
    compare a to 0x80
    goto _0135 when zero
    //Restore placement data byte to A.
    a = y
def _0133:
    compare a & [0x4]
    //Branch if bit 6 cleared, else data is negative displacement.
    goto _0134 when ~overflow

def negativedisplacement:

    a = a ^ 0xff
    //NOTE:Setting carry makes solution 1 higher than expected.
    carry = 1
    //If flip bit is set in $04, this function flips the-->
    a = a +# 0xf8
def _0134:
    //object by using two compliment minus 8(Each sprite is-->
    carry = 0
    //8x8 pixels).
    return

def explodexdisplace:

def _0135:
    //Load index to proper enemy slot.
    y = [pageindex]
    //Load counter value.
    a = [encounter:y]
    //Is Samus the one exploding?-->
    y = [issamus]
    //If not, branch.
    goto _0136 when zero
    //Load object counter if it is Samus who is exploding.
    a = [objectcounter]
def _0136:
    //*2. Move sprite in x direction 2 pixels every frame.
    a = a << 1
    //Store value on stack.
    push a
    y = [0xf]
    //Load placement data byte.
    a = [[0x2]:y]
    a = a >> 1
    //Check if LSB is set. If not, the byte stored on stack-->
    goto _0137 when carry
    //Will be twos complimented and used to move sprite in-->
    a = pop
    //the negative x direction.
    a = a ^ 0xff
    a = a +# 0x1
    push a
def _0137:
    //Load placement data index.
    a = [0xf]
    carry = 0
    //Move index forward by 12 bytes. to find x-->
    a = a +# 0xc
    //placement data.
    y = a
    //Restore A with x displacement data.
    a = pop
    carry = 0
    //Add x displacement with sprite placement data.
    a = a +# [[0x2]:y]
    //Branch to add x placement values to sprite coords.
    goto _0133

//---------------------------------[ Check if object is on screen ]----------------------------------

//The following set of functions determine if an object is visible on the screen.  If the object
//is visible, X-1 when the function returns, X=0 if the object is not within the boundaries of the
//current screen.  The function needs to know what nametable is currently in the PPU, what nametable
//the object is on and what the scroll offsets are. 

def isobjectvisible:

    //Assume object is visible on screen.
    x = 0x1
    //Object Y position in room.
    a = [0xa]
    y = a
    //Subtract y scroll to find sprite's y position on screen.
    carry = 1
    a = a -# [scroll.y]
    //Store result in $10.
    [0x10] = a
    //Object X position in room.
    a = [0xb]
    carry = 1
    //Subtract x scroll to find sprite's x position on screen.
    a = a -# [scroll.x]
    //Store result in $0E.
    [0xe] = a
    a = [scroll.dir]
    //Is Samus scrolling left or right?-->
    a = a & 0x2
    //($E01C)If so, branch.
    goto horzscrollcheck when ~zero

def vertscrollcheck:

    //If object room pos is >= scrollY, set carry.
    compare y to [scroll.y]
    //Check if object is on different name table as current-->
    a = [0x6]
    //name table active in PPU.-->
    a = a ^ [video.ctrl]
    //If not, branch.
    a = a & 0x1
    goto _0138 when zero
    //If carry is still set, sprite is not in screen boundaries.
    goto _0139 when carry
    a = [0x10]
    //Move sprite y position up 15 pixles.
    a = a -# 0xf
    [0x10] = a
    a = [0x9]
    //If a portion of the object is outside the sceen-->
    carry = 0
    //boundaries, treat object as if the whole thing is-->
    a = a +# [0x10]
    //not visible.
    compare a to 0xf0
    goto _013A when ~carry
    //Causes next statement to branch always.
    carry = 0
def _0138:
    goto _0139 when ~carry
    //If object is on same name table as the current one in-->
    a = [0x9]
    //the PPU, check if part of object is out of screen-->
    compare a to [0x10]
    //boundaries.  If so, branch.
    goto _013A when ~carry
def _0139:
    //Sprite is not within screen boundaries. Decrement X.
    x--
def _013A:
    return

def horzscrollcheck:

    a = [0x6]
    //Check if object is on different name table as current-->
    a = a ^ [video.ctrl]
    //name table active in PPU.-->
    a = a & 0x1
    //If not, branch.
    goto _013B when zero
    //If carry is still set, sprite is not in screen boundaries.
    goto _013C when carry
    a = [0x9]
    //If a portion of the object is outside the sceen-->
    carry = 0
    //boundaries, treat object as if the whole thing is-->
    a = a +# [0xe]
    //not visible.
    goto _013D when ~carry
    //Causes next statement to branch always.
    carry = 0
def _013B:
    goto _013C when ~carry
    //If object is on same name table as the current one in-->
    a = [0x9]
    //the PPU, check if part of object is out of screen-->
    compare a to [0xe]
    //boundaries.  If so, branch.
    goto _013D when ~carry
def _013C:
    //Sprite is not within screen boundaries. Decrement X.
    x--
def _013D:
    return

//------------------------[ Override sprite flip bits with object flip bits ]-------------------------

//If the MSB is set in ObjectCntrl, its two upper bits that control sprite flipping take priority
//over the sprite control bits.  This function modifies the sprite control byte with any flipping
//bits found in ObjectCntrl.

def spriteflipbitsoveride:

    //Restore MSB.
    [objectcntrl] = [objectcntrl] >> 1
    //Reload frame data control byte into A.
    a = [[0x0]:y]
    //Extract the two sprite flip bytes from theoriginal-->
    a = a & 0xc0
    //control byte and set any additional bits from ObjectCntrl.
    a = a | [objectcntrl]
    //Store modified byte to load in sprite control byte later.
    [0x5] = a
    a = [objectcntrl]
    a = a | 0x80
    //Ensure MSB of object control byte remains set.
    [objectcntrl] = a
    return

//--------------------------------[ Explosion placement data ]---------------------------------------

//The following table has the index values into the table after it for finding the placement data
//for an exploding object.

def explodeindextbl:

    byte: 0x0, 0x18, 0x30

//The following table is used to produce the arcing motion of exploding objects.  It is displacement
//data for the y directions only.  The x displacement is constant.

def explodeplacementtbl:


//Bottom sprites.
    byte: 0xfc, 0xf8, 0xf4, 0xf0, 0xee, 0xec, 0xea, 0xe8, 0xe7, 0xe6, 0xe6, 0xe5, 0xe5, 0xe4, 0xe4, 0xe3
    byte: 0xe5, 0xe7, 0xe9, 0xeb, 0xef, 0xf3, 0xf7, 0xfb

//Middle sprites.
    byte: 0xfe, 0xfc, 0xfa, 0xf8, 0xf6, 0xf4, 0xf2, 0xf0, 0xee, 0xed, 0xeb, 0xea, 0xe9, 0xe8, 0xe7, 0xe6
    byte: 0xe6, 0xe6, 0xe6, 0xe6, 0xe8, 0xea, 0xec, 0xee

//Top sprites.
    byte: 0xfe, 0xfc, 0xfa, 0xf8, 0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf1, 0xf0, 0xf0, 0xef, 0xef
    byte: 0xef, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf1, 0xf2

//--------------------------------------[ Update enemy animation ]-----------------------------------

//Advance to next frame of enemy's animation. Basically the same as UpdateObjAnim, only for enemies.

def updateenemyanim:

    //Load index to desired enemy.
    x = [pageindex]
    y = [enstatus:x]
    //Is enemy in the process of dying?-->
    compare y to 0x5
    //If so, branch to exit.
    goto _0140 when zero
    y = [enanimdelay:x]
    //Check if current anumation frame is ready to be updated.
    goto _013E when zero
    //Not ready to update. decrement delay timer and-->
    [enanimdelay:x]--
    //branch to exit.
    goto _0140 when ~zero
def _013E:
    //Save new animation delay value.
    [enanimdelay:x] = a
    //Load enemy animation index.
    y = [enanimindex:x]
def _013F:
    //Get animation data.
    a = [[enemyanimptr]:y]
    //End of animation?
    compare a to 0xff
    //If so, branch to reset animation.
    goto _0141 when zero
    //Store current animation frame data.
    [enanimframe:x] = a
    //Increment to next animation data index.
    y++
    a = y
    //Save new animation index.
    [enanimindex:x] = a
def _0140:
    return

def _0141:
    //reset animation index.
    y = [enresetanimindex:x]
    //Branch always.
    goto _013F when carry

//---------------------------------------[ Display status bar ]---------------------------------------

//Displays Samus' status bar components.

def displaybar:

    //Reset data index.
    y = 0x0
    //Load current sprite index.
    a = [spritepagepos]
    //save sprite page pos.
    push a
    x = a
def _0142:
    a = [datadisplaytbl:y]
    //Stor contents of DataDisplayTbl in sprite RAM.
    [sprite00ram:x] = a
    x++
    y++
    //10*4. At end of DataDisplayTbl? If not, loop to-->
    compare y to 0x28
    //load next byte from table.
    goto _0142 when ~zero

//Display 2-digit health count.
    //Save new location in sprite RAM.
    [spritepagepos] = x
    //Restore initial sprite page pos.
    a = pop
    x = a
    a = [healthhi]
    //Extract upper health digit.
    a = a & 0xf
    //($E173)Display digit on screen.
    call sprwritedigit
    a = [healthlo]
    //($C2BF)Move lower health digit to 4 LSBs.
    call adiv16
    //($E173)Display digit on screen.
    call sprwritedigit
    y = [endtimerhi]
    //Is Samus in escape sequence?-->
    y++
    //If so, branch.
    goto _0144 when ~zero
    y = [maxmissiles]
    //Don't show missile count if Samus has no missile containers.
    goto _0143 when zero

//Display 3-digit missile count.
    a = [missilecount]
    //($E198)Convert missile hex count to decimal cout.
    call hextodec
    //Upper digit.
    a = [0x2]
    //($E173)Display digit on screen.
    call sprwritedigit
    //Middle digit.
    a = [0x1]
    //($E173)Display digit on screen.
    call sprwritedigit
    //Lower digit.
    a = [0x0]
    //($E173)Display digit on screen.
    call sprwritedigit
    //Branch always.
    goto _0145 when ~zero

//Samus has no missiles, erase missile sprite.
def _0143:
    //"Blank" tile.
    a = 0xff
    //If at last 3 sprites, branch to skip.
    compare x to 0xf4
    goto _0145 when carry
    //Erase left half of missile.
    [sprite03ram+1:x] = a
    //If at last 4 sprites, branch to skip.
    compare x to 0xf0
    goto _0145 when carry
    //Erase right half of missile.
    [sprite04ram+1:x] = a
    //Branch always.
    goto _0145 when ~zero

//Display 3-digit end sequence timer.
def _0144:
    a = [endtimerhi]
    //($C2BF)Upper timer digit.
    call adiv16
    //($E173)Display digit on screen.
    call sprwritedigit
    a = [endtimerhi]
    //Middle timer digit.
    a = a & 0xf
    //($E173)Display digit on screen.
    call sprwritedigit
    a = [endtimerlo]
    //($C2BF)Lower timer digit.
    call adiv16
    //($E173)Display digit on screen.
    call sprwritedigit
    //"TI" sprite(left half of "TIME").
    a = 0x58
    [sprite00ram+1:x] = a
    //Change color of sprite.
    [sprite00ram+2:x]++
    //If at last sprite, branch to skip.
    compare x to 0xfc
    goto _0145 when carry
    //"ME" sprite(right half of "TIME").
    a = 0x59
    [sprite01ram+1:x] = a
    //Change color of sprite.
    [sprite01ram+2:x]++

def _0145:
    //Restore initial sprite page pos.
    x = [spritepagepos]
    a = [tankcount]
    //Branch to exit if Samus has no energy tanks.
    goto _0147 when zero

//Display full/empty energy tanks.
    //Temp store tank count.
    [0x3] = a
    //X coord of right-most energy tank.
    a = 0x40
    //Energy tanks are drawn from right to left.
    [0x0] = a
    //"Full energy tank" tile.
    y = 0x6f
    a = [healthhi]
    //($C2BF)/16. A contains # of full energy tanks.
    call adiv16
    //Storage of full tanks.
    [0x1] = a
    //Branch if at least 1 tank is full.
    goto addtanks when ~zero
    //Else switch to "empty energy tank" tile.
    y--

def addtanks:

    //($E17B)Add energy tank to display.
    call addonetank
    //Any more full energy tanks left?-->
    [0x1]--
    //If so, then branch.-->
    goto _0146 when ~zero
    //Otherwise, switch to "empty energy tank" tile.
    y--
def _0146:
    //done all tanks?-->
    [0x3]--
    //if not, loop to do another.
    goto addtanks when ~zero

    //Store new sprite page position.
    [spritepagepos] = x
def _0147:
    return

//----------------------------------------[Sprite write digit ]---------------------------------------

//A=value in range 0..9. #$A0 is added to A(the number sprites begin at $A0), and the result is stored
//as the tile # for the sprite indexed by X.

def sprwritedigit:

    //#$A0 is index into pattern table for numbers.
    a = a | 0xa0
    //Store proper nametable pattern in sprite RAM.
    [sprite00ram+1:x] = a
    //Find next sprite pattern table byte.
    goto xplus4

//----------------------------------[ Add energy tank to display ]------------------------------------

//Add energy tank to Samus' data display.

def addonetank:

    //Y coord-1.
    a = 0x17
    [sprite00ram:x] = a
    //Tile value.
    a = y
    [sprite00ram+1:x] = a
    //Palette #.
    a = 0x1
    [sprite00ram+2:x] = a
    //X coord.
    a = [0x0]
    [sprite00ram+3:x] = a
    carry = 1
    //Find x coord of next energy tank.
    a = a -# 0xa
    [0x0] = a

//-----------------------------------------[ Add 4 to x ]---------------------------------------------

def xplus4:

    x++
    x++
    //Add 4 to value stored in X.
    x++
    x++
    return

//------------------------------------[ Convert hex to decimal ]--------------------------------------

//Convert 8-bit value in A to 3 decimal digits. Upper digit put in $02, middle in $01 and lower in $00.

def hextodec:

    //Find upper digit.
    y = 100
    [0xa] = y
    //($E1AD)Extract hundreds digit.
    call getdigit
    //Store upper digit in $02.
    [0x2] = y
    //Find middle digit.
    y = 10
    [0xa] = y
    //($E1AD)Extract tens digit.
    call getdigit
    //Store middle digit in $01.
    [0x1] = y
    //Store lower digit in $00
    [0x0] = a
    return

def getdigit:

    y = 0x0
    carry = 1
def _0148:
    y++
    //Loop and subtract value in $0A from A until carry flag-->
    a = a -# [0xa]
    //is not set.  The resulting number of loops is the decimal-->
    goto _0148 when carry
    //number extracted and A is the remainder.
    y--
    a = a +# [0xa]
    return

//-------------------------------------[ Status bar sprite data ]-------------------------------------

//Sprite data for Samus' data display

def datadisplaytbl:

    //Upper health digit.
    byte: 0x21, 0xa0, 0x1, 0x30
    //Lower health digit.
    byte: 0x21, 0xa0, 0x1, 0x38
    //Upper missile digit.
    byte: 0x2b, 0xff, 0x1, 0x28
    //Middle missile digit.
    byte: 0x2b, 0xff, 0x1, 0x30
    //Lower missile digit.
    byte: 0x2b, 0xff, 0x1, 0x38
    //Left half of missile.
    byte: 0x2b, 0x5e, 0x0, 0x18
    //Right half of missile.
    byte: 0x2b, 0x5f, 0x0, 0x20
    //E
    byte: 0x21, 0x76, 0x1, 0x18
    //N
    byte: 0x21, 0x7f, 0x1, 0x20
    //..
    byte: 0x21, 0x3a, 0x0, 0x28

//-------------------------------------------[ Bit scan ]---------------------------------------------

//This function takes the value stored in A and right shifts it until a set bit is encountered.
//Once a set bit is encountered, the function exits and returns the bit number of the set bit.
//The returned value is stored in A. 

def bitscan:

    //Save X.
    [0xe] = x
    //First bit is bit 0.
    x = 0x0
def _0149:
    //Transfer bit to carry flag.
    a = a >> 1
    //If the shifted bit was 1, Branch out of loop.
    goto _014A when carry
    //Increment X to keep of # of bits checked.
    x++
    //Have all 8 bit been tested?-->
    compare x to 0x8
    //If not, branch to check the next bit.
    goto _0149 when ~zero
def _014A:
    //Return which bit number was set.
    a = x
    //Restore X.
    x = [0xe]
def _014B:
    return

//------------------------------------------[ Scroll door ]-------------------------------------------

//Scrolls the screen if Samus is inside a door.

def scrolldoor:

    x = [doorstatus]
    //Exit if Samus isn't in a door.
    goto _014B when zero
    x--
    //Not in right door. branch to check left door.
    goto _014C when ~zero
    //($E6D2)DoorStatus=1, scroll 1 pixel right.
    call scrollright
    //Jump to check if door scroll is finished.
    goto _014D

def _014C:
    //Check if in left door.
    x--
    goto _014E when ~zero
    //($E6A7)DoorStatus=2, scroll 1 pixel left.
    call scrollleft
def _014D:
    //Has x scroll offset reached 0?-->
    x = [scroll.x]
    //If not, branch to exit.
    goto exit15 when ~zero

//Scrolled one full screen, time to exit door.
    //Samus is exiting the door.
    x = 0x5
    //Branch always.
    goto doonedoorscroll when ~zero

def _014E:
    x--
    //Check if need to scroll down to center door.
    goto _014F when ~zero
    //($E519)DoorStatus=3, scroll 1 pixel down.
    call scrolldown
    //Jump to check y scrolling value.
    goto _0150
def _014F:
    x--
    //Check if need to scroll up to center door.
    goto exit15 when ~zero
    //($E4F1)DoorStatus=4, scroll 1 pixel up.
    call scrollup

def verticalroomcentered:

def _0150:
    //Has room been centered on screen?-->
    x = [scroll.y]
    //If not, branch to exit.
    goto exit15 when ~zero
    [dooronnametable3] = x
    //Erase door nametable data.
    [dooronnametable0] = x
    //X=1.
    x++
    //Did Samus enter in the right hand door?-->
    a = [objectx]
    //If so, branch.
    goto _0152 when negative
    //X=2. Samus is in left door.
    x++
    //Branch always.
    goto _0152 when ~zero

//This function is called once after door scrolling is complete.

def doonedoorscroll:

    //Set DoorDelay to 32 frames(comming out of door).
    a = 0x20
    [doordelay] = a
    //Check if scrolling should be toggled.
    a = [samusdoordata]
    //($C2C6)*8. Is door not to toggle scrolling(item room,-->
    call amul8
    //bridge room, etc.)? If so, branch to NOT toggle scrolling.
    goto _0151 when carry
    //If comming from vertical shaft, skip ToggleScroll because-->
    y = [doorscrollstatus]
    //the scroll was already toggled after room was centered-->
    compare y to 0x3
    //by the routine just above.
    goto _0152 when ~carry
def _0151:
    //Set mirroring for vertical mirroring(horz scrolling).
    a = 0x47
    //Branch always.
    goto _0153 when ~zero

def _0152:
    //($E252)Toggle scrolling and mirroring.
    call togglescroll
def _0153:
    //Store new mirror control data.
    [video.mirror] = a
    //DoorStatus=5. Done with door scrolling.
    [doorstatus] = x

def exit15:

    //Exit for several routines above.
    return

//------------------------------------[ Toggle Samus nametable ]--------------------------------------

def togglesamushi:

    a = [objecthi]
    //Change Samus' current nametable from one to the other.
    a = a ^ 0x1
    [objecthi] = a
    return

//-------------------------------------------[ Toggle scroll ]----------------------------------------

//Toggles both mirroring and scroll direction when Samus has moved from
//a horizontal shaft to a vertical shaft or vice versa.

def togglescroll:

    a = [scroll.dir]
    //Toggle scroll direction.
    a = a ^ 0x3
    [scroll.dir] = a
    //Toggle mirroring.
    a = [video.mirror]
    a = a ^ 0x8
    return

//----------------------------------------[ Is Samus in lava ]----------------------------------------

//The following function checks to see if Samus is in lava.  If she is, the carry bit is cleared,
//if she is not, the carry bit is set. Samus can only be in lava if in a horizontally scrolling
//room. If Samus is 24 pixels or less away from the bottom of the screen, she is considered to be
//in lava whether its actually there or not.

def issamusinlava:

    a = 0x1
    //Set carry bit(and exit) if scrolling up or down.
    compare a to [scroll.dir]
    goto _0154 when carry
    //If Samus is Scrolling left or right and within 24 pixels-->
    a = 0xd8
    //of the bottom of the screen, she is in lava. Clear carry bit.
    compare a to [objecty]
def _0154:
    return

//----------------------------------[ Check lava and movement routines ]------------------------------

def lavaandmovecheck:

    a = [objaction]
    //Is Samus on elevator?-->
    compare a to sa_elevator
    //If so, branch.
    goto _0155 when zero
    //Is Samus Dead-->
    compare a to sa_dead
    //If so, branch to exit.
    goto _0154 when carry
def _0155:
    //($E25D)Clear carry flag if Samus is in lava.
    call issamusinlava
    //Assume Samus not in lava.
    y = 0xff
    //Samus not in lava so branch.
    goto _0159 when carry

//Samus is in lava.
    //Don't push Samus from lava damage.
    [damagepushdirection] = y
    //($F323)Clear any pending health changes to Samus.
    call clearhealthchange
    a = 0x32
    //Make Samus blink.
    [samusblink] = a
    a = [framecount]
    //Start the jump SFX every 4th frame while in lava.
    a = a & 0x3
    goto _0156 when ~zero
    //($CBAC)Initiate jump SFX.
    call sfx_samusjump
def _0156:
    a = [framecount]
    //This portion of the code causes Samus to be damaged by-->
    a = a >> 1
    //lava twice every 8 frames if she does not have the varia-->
    a = a & 0x3
    //but only once every 8 frames if she does.
    goto _0158 when ~zero
    a = [samusgear]
    //Does Samus have the Varia?-->
    a = a & gr_varia
    //If not, branch.
    goto _0157 when zero
    //Samus has varia. Carry set every other frame. Half damage.
    goto _0158 when ~carry
def _0157:
    a = 0x7
    //Samus takes lava damage.
    [healthlochange] = a
    //($CE92)
    call subtracthealth
def _0158:
    //Prepare to indicate Samus is in lava.
    y = 0x0
def _0159:
    //Set Samus lava status.
    y++
    [samusinlava] = y

def samusmovevertically:

    //($E37A)Calculate vertical acceleration.
    call vertaccelerate
    a = [objecty]
    carry = 1
    //Calculate Samus' screen y position.
    a = a -# [scroll.y]
    [samusscry] = a
    //Load temp copy of vertical speed.
    a = [0x0]
    //If Samus is moving downwards, branch.
    goto _015D when ~negative

    //($C3D4)Get twos compliment of vertical speed.
    call twoscompliment
    //Is Samus in lava?
    y = [samusinlava]
    //If not, branch,-->
    goto _015A when zero
    //else cut vertical speed in half.
    a = a >> 1
    //($E31A)Branch if no vertical mvmnt to Check left/right mvmnt.
    goto samusmovehorizontally when zero

//Samus is moving upwards.
def _015A:
    //Store number of pixels to move Samus this frame.
    [objectcounter] = a
def _015B:
    //($E457)Attempt to move Samus up 1 pixel.
    call movesamusup
    //Branch if Samus successfully moved up 1 pixel.
    goto _015C when carry

    //Samus blocked upwards. Divide her speed by 2 and set the
    carry = 1
    //MSB to reverse her direction of travel.
    [objvertspeed] = [objvertspeed] >>> 1
    [vertcntrlinear] = [vertcntrlinear] >>> 1
    //($E31A)Attempt to move Samus left/right.
    goto samusmovehorizontally

def _015C:
    //1 pixel movement is complete.
    [objectcounter]--
    //Branch if Samus needs to be moved another pixel.
    goto _015B when ~zero

//Samus is moving downwards.
def _015D:
    //($E31A)Branch if no vertical mvmnt to Check left/right mvmnt.
    goto samusmovehorizontally when zero
    //Is Samus in lava?
    y = [samusinlava]
    //If not, branch,-->
    goto _015E when zero
    //Else reduce Samus speed by 75%(divide by 4).
    a = a >> 1
    a = a >> 1
    //($E31A)Attempt to move Samus left/right.
    goto samusmovehorizontally when zero

def _015E:
    //Store number of pixels to move Samus this frame.
    [objectcounter] = a
def _015F:
    //($E4A3)Attempt to move Samus 1 pixel down.
    call movesamusdown
    //Branch if Samus successfully moved down 1 pixel.
    goto _0162 when carry

//Samus bounce after hitting the ground in ball form.
    a = [objaction]
    //Is Samus rolled into a ball?-->
    compare a to sa_roll
    //If not, branch.
    goto _0160 when ~zero
    //Divide verticle speed by 2.
    [objvertspeed] = [objvertspeed] >> 1
    //Speed not fast enough to bounce. branch to skip.
    goto _0161 when zero
    //Move carry bit into MSB to reverse Linear counter.
    [vertcntrlinear] = [vertcntrlinear] >>> 1
    a = 0x0
    carry = 1
    //Subtract linear counter from 0 and save the results.-->
    a = a -# [vertcntrlinear]
    //Carry will be cleared.
    [vertcntrlinear] = a
    a = 0x0
    //Subtract vertical speed from 0. this will reverse the-->
    a = a -# [objvertspeed]
    //vertical direction of travel(bounce up).
    [objvertspeed] = a
    //($E31A)Attempt to move Samus left/right.
    goto samusmovehorizontally

//Samus has hit the ground after moving downwards. 
def _0160:
    //($CB96)Play walk SFX.
    call sfx_samuswalk
def _0161:
    //($D147)Clear vertical movement data.
    call stopvertmovement
    //Clear Samus gravity value.
    [samusgravity] = y
    //($E31A)Attempt to move Samus left/right.
    goto samusmovehorizontally when zero

def _0162:
    //1 pixel movement is complete.
    [objectcounter]--
    //Branch if Samus needs to be moved another pixel.
    goto _015F when ~zero

def samusmovehorizontally:

    //($E3E5)Horizontally accelerate Samus.
    call horzaccelerate
    a = [objectx]
    //Calculate Samus' x position on screen.
    carry = 1
    a = a -# [scroll.x]
    //Save Samus' x position.
    [samusscrx] = a
    //Load Samus' current horizontal speed.
    a = [0x0]
    //Branch if moving right.
    goto _0165 when ~negative

//Samus is moving left.
    //($C3D4)Get twos compliment of horizontal speed.
    call twoscompliment
    //Is Samus in lava?-->
    y = [samusinlava]
    //If not, branch,-->
    goto _0163 when zero
    //else cut horizontal speed in half.
    a = a >> 1
    //Branch to exit if Samus not going to move this frame.
    goto exit10 when zero

def _0163:
    //Store number of pixels to move Samus this frame.
    [objectcounter] = a
def _0164:
    //($E626)Attempt to move Samus 1 pixel to the left.
    call movesamusleft
    //($E365)Check if horizontal movement needs to be stopped.
    call checkstophorzmvmt
    //1 pixel movement is complete.
    [objectcounter]--
    //Branch if Samus needs to be moved another pixel.
    goto _0164 when ~zero

    //Has Samus entered a door?-->
    a = [samusdoordata]
    //If not, branch to exit.
    goto exit10 when zero
    //Door leads to the left.
    a = 0x1
    //Branch always.
    goto _0168 when ~zero

//Samus is moving right.
def _0165:
    //Branch to exit if Samus not moving horizontally.
    goto exit10 when zero
    //Is Samus in lava?-->
    y = [samusinlava]
    //If not, branch,-->
    goto _0166 when zero
    //else cut horizontal speed in half.
    a = a >> 1
    //Branch to exit if Samus not going to move this frame.
    goto exit10 when zero

def _0166:
    //Store number of pixels to move Samus this frame.
    [objectcounter] = a
def _0167:
    //($E668)Attempt to move Samus 1 pixel to the right.
    call movesamusright
    //($E365)Check if horizontal movement needs to be stopped.
    call checkstophorzmvmt
    //1 pixel movement is complete.
    [objectcounter]--
    //Branch if Samus needs to be moved another pixel.
    goto _0167 when ~zero

    //Has Samus entered a door?-->
    a = [samusdoordata]
    //If not, branch to exit.
    goto exit10 when zero
    a = 0x0
def _0168:
    //Door leads to the right.
    [samusdoordir] = a

def exit10:

    //Exit for routines above and below.
    return

def checkstophorzmvmt:

    //Samus moved successfully. Branch to exit.
    goto exit10 when carry
    //Load counter with #$01 so this function will not be-->
    a = 0x1
    //called again.
    [objectcounter] = a
    //Is Samus on the ground?-->
    a = [samusgravity]
    //If not, branch to exit.
    goto exit10 when ~zero
    a = [objaction]
    //Is Samus rolled into a ball?-->
    compare a to sa_roll
    //If so, branch to exit.
    goto exit10 when zero
    //($CF55)Stop horizontal movement or play walk SFX if stopped.
    goto stophorzmovement

//-------------------------------------[ Samus vertical acceleration ]--------------------------------

//The following code accelerates/decelerates Samus vertically.  There are 4 possible values for
//gravity used in the acceleration calculation. The higher the number, the more intense the gravity.
//The possible values for gravity are as follows:
//#$38-When Samus has been hit by an enemy.
//#$1A-When Samus is falling.
//#$18-Jump without high jump boots.
//#$12-Jump with high jump boots.

def vertaccelerate:

    //Is Samus rising or falling?-->
    a = [samusgravity]
    //Branch if yes.
    goto _016A when ~zero
    a = 0x18
    //Set Samus maximum running speed.
    [samushorzspeedmax] = a
    a = [objecty]
    carry = 0
    //Check is Samus is obstructed downwards on y room-->
    a = a +# [objrady]
    //positions divisible by 8(every 8th pixel).
    a = a & 0x7
    goto _0169 when ~zero
    //($E7AD)Is Samus obstructed downwards?-->
    call checkmovedown
    //Branch if yes.
    goto _016A when ~carry
def _0169:
    //($D976)Calculate if Samus standing on elevator or enemy.
    call samusonelevatororenemy
    //Is Samus on an elevator?-->
    a = [samusonelevator]
    //Branch if yes.
    goto _016A when ~zero
    //Is Samus standing on a frozen enemy?-->
    a = [onfrozenenemy]
    //Branch if yes.
    goto _016A when ~zero
    //Samus is falling. Store falling gravity value.
    a = 0x1a
    [samusgravity] = a

def _016A:
    //Load X with maximum downward speed.
    x = 0x5
    a = [vertcntrlinear]
    //The higher the gravity, the faster this addition overflows-->
    carry = 0
    //and the faster ObjVertSpeed is incremented.
    a = a +# [samusgravity]
    [vertcntrlinear] = a
    //Every time above addition sets carry bit, ObjVertSpeed is-->
    a = [objvertspeed]
    //incremented. This has the effect of speeding up a fall-->
    a = a +# 0x0
    //and slowing down a jump.
    [objvertspeed] = a
    //Branch if Samus is moving downwards.
    goto _016B when ~negative

//Check if maximum upward speed has been exceeded. If so, prepare to set maximum speed.
    a = 0x0
    //Sets carry bit.
    compare a to [vertcntrlinear]
    //Subtract ObjVertSpeed to see if maximum speed has-->
    a = a -# [objvertspeed]
    //been exceeded.
    compare a to 0x6
    //Load X with maximum upward speed.
    x = 0xfa
    //Branch always.
    goto _016C when ~zero

//Check if maximum downward speed has been reached. If so, prepare to set maximum speed.
def _016B:
    //Has maximum downward speed been reached?-->
    compare a to 0x5
def _016C:
    //If not, branch.
    goto _016D when ~carry

//Max verticle speed reached or exceeded. Adjust Samus verticle speed to max.
    //($D147)Clear verticle movement data.
    call stopvertmovement
    //Set Samus vertical speed to max.
    [objvertspeed] = x

//This portion of the function creates an exponential increase/decrease in verticle speed. This is the
//part of the function that does all the work to make Samus' jump seem natural.
def _016D:
    a = [vertcntrnonlinear]
    //This function adds itself plus the linear verticle counter-->
    carry = 0
    //onto itself every frame.  This causes the non-linear-->
    a = a +# [vertcntrlinear]
    //counter to increase exponentially.  This function will-->
    [vertcntrnonlinear] = a
    //cause Samus to reach maximum speed first in most-->
    a = 0x0
    //situations before the linear counter.
    a = a +# [objvertspeed]
    //$00 stores temp copy of current verticle speed.
    [0x0] = a
    return

//----------------------------------------------------------------------------------------------------

def horzaccelerate:

    a = [samushorzspeedmax]
    //* 16
    call amul16
    [0x0] = a
    [0x2] = a
    a = [samushorzspeedmax]
    /// 16
    call adiv16
    [0x1] = a
    [0x3] = a

    a = [horzcntrlinear]
    carry = 0
    a = a +# [samushorzaccel]
    [horzcntrlinear] = a
    x = a
    a = 0x0
    compare a & [samushorzaccel]
    //Branch if Samus accelerating to the right.
    goto _016E when ~negative

    a = 0xff

def _016E:
    a = a +# [objhorzspeed]
    [objhorzspeed] = a
    y = a
    //Branch if Samus accelerating to the right.
    goto _016F when ~negative

    a = 0x0
    carry = 1
    a = a -# [horzcntrlinear]
    x = a
    a = 0x0
    a = a -# [objhorzspeed]
    y = a
    call game_engine_page_E449

def _016F:
    compare x to [0x2]
    a = y
    a = a -# [0x3]
    goto _0170 when ~carry
    a = [0x0]
    [horzcntrlinear] = a
    a = [0x1]
    [objhorzspeed] = a
def _0170:
    a = [horzcntrnonlinear]
    carry = 0
    a = a +# [horzcntrlinear]
    [horzcntrnonlinear] = a
    a = 0x0
    a = a +# [objhorzspeed]
    //$00 stores temp copy of current horizontal speed.
    [0x0] = a
    return

def game_engine_page_E449:
    a = 0x0
    carry = 1
    a = a -# [0x0]
    [0x0] = a
    a = 0x0
    a = a -# [0x1]
    [0x1] = a
    return

//----------------------------------------------------------------------------------------------------

//Attempt to move Samus one pixel up.

def movesamusup:

    //Get Samus' y position in room.
    a = [objecty]
    carry = 1
    //Subtract Samus' vertical radius.
    a = a -# [objrady]
    //Check if result is a multiple of 8. If so, branch to-->
    a = a & 0x7
    //Only call crash detection every 8th pixel.
    goto _0171 when ~zero
    //($E7A2)Check if Samus obstructed UPWARDS.-->
    call checkmoveup
    //If so, branch to exit(can't move any further).
    goto _0177 when ~carry
def _0171:
    a = [objaction]
    //Is Samus riding elevator?-->
    compare a to sa_elevator
    //If so, branch.
    goto _0172 when zero
    //($D976)Calculate if Samus standing on elevator or enemy.
    call samusonelevatororenemy
    a = [samushit]
    a = a & 0x42
    compare a to 0x42
    carry = 0
    goto _0177 when zero
def _0172:
    a = [samusscry]
    //reached up scroll limit?
    compare a to 0x66
    //branch if not
    goto _0173 when carry
    call scrollup
    goto _0174 when ~carry
def _0173:
    [samusscry]--
def _0174:
    a = [objecty]
    goto _0176 when ~zero
    a = [scroll.dir]
    a = a & 0x2
    goto _0175 when ~zero
    //toggle 9th bit of Samus' Y coord
    call togglesamushi
def _0175:
    a = 240
    [objecty] = a
def _0176:
    [objecty]--
    [samusjumpdsplcmnt]++
    carry = 1
def _0177:
    return

// attempt to move Samus one pixel down

def movesamusdown:

    a = [objecty]
    carry = 0
    a = a +# [objrady]
    a = a & 0x7
    //only call crash detection every 8th pixel
    goto _0178 when ~zero
    //check if Samus obstructed DOWNWARDS
    call checkmovedown
    //exit if yes
    goto _017E when ~carry
def _0178:
    a = [objaction]
    //is Samus in elevator?
    compare a to sa_elevator
    goto _0179 when zero
    call game_engine_page_D976
    a = [samusonelevator]
    carry = 0
    goto _017E when ~zero
    a = [onfrozenenemy]
    goto _017E when ~zero
def _0179:
    a = [samusscry]
    //reached down scroll limit?
    compare a to 0x84
    //branch if not
    goto _017A when ~carry
    call scrolldown
    goto _017B when ~carry
def _017A:
    [samusscry]++
def _017B:
    a = [objecty]
    compare a to 239
    goto _017D when ~zero
    a = [scroll.dir]
    a = a & 0x2
    goto _017C when ~zero
    //toggle 9th bit of Samus' Y coord
    call togglesamushi
def _017C:
    a = 0xff
    [objecty] = a
def _017D:
    [objecty]++
    [samusjumpdsplcmnt]--
    carry = 1
def _017E:
    return

// Attempt to scroll UP

def scrollup:

    a = [scroll.dir]
    goto _017F when zero
    compare a to 0x1
    goto _0182 when ~zero
    [scroll.dir]--
    a = [scroll.y]
    goto _017F when zero
    [mapposy]--
def _017F:
    x = [scroll.y]
    goto _0180 when ~zero
    //decrement MapY
    [mapposy]--
    //put room # at current map pos in $5A
    call getroomnum
    //if function returns CF = 1, moving up is not possible
    goto _0181 when carry
    //switch to the opposite Name Table
    call game_engine_page_E9B7
    //new Y coord
    x = 240
def _0180:
    x--
    goto game_engine_page_E53F

def _0181:
    [mapposy]++
def _0182:
    carry = 1
    return

// Attempt to scroll DOWN

def scrolldown:

    x = [scroll.dir]
    x--
    goto _0183 when zero
    goto _0187 when ~negative
    [scroll.dir]++
    a = [scroll.y]
    goto _0183 when zero
    [mapposy]++
def _0183:
    a = [scroll.y]
    goto _0184 when ~zero
    //increment MapY
    [mapposy]++
    //put room # at current map pos in $5A
    call getroomnum
    //if function returns CF = 1, moving down is not possible
    goto _0186 when carry
def _0184:
    x = [scroll.y]
    compare x to 239
    goto _0185 when ~zero
    //switch to the opposite Name Table
    call game_engine_page_E9B7
    x = 0xff
def _0185:
    x++
def game_engine_page_E53F:
    [scroll.y] = x
    //check if it's time to update Name Table
    call game_engine_page_E54A
    carry = 0
    return

def _0186:
    [mapposy]--
def _0187:
    carry = 1
def _0188:
    return

def game_engine_page_E54A:
    call setuproom
    x = [roomnumber]
    x++
    goto _0188 when ~zero
    a = [scroll.dir]
    a = a & 0x2
    goto _0189 when ~zero
    goto game_engine_page_E571
def _0189:
    goto 0xe701

// Table

def table11:

    byte: 0x7
    byte: 0x0

//---------------------------------[ Get PPU and RoomRAM addresses ]----------------------------------

def ppuaddrs:

    //High byte of nametable #0(PPU).
    byte: 0x20
    //High byte of nametable #3(PPU)
    byte: 0x2c

def wramaddrs:

    //High byte of RoomRAMA(cart RAM).
    byte: 0x60
    //High byte of RoomRAMB(cart RAM).
    byte: 0x64

def getnameaddrs:

    //($EB85)Get current name table number.
    call getnametable
    //Update name table 0 or 3.
    a = a & 0x1
    y = a
    //Get high PPU addr of nametable(dest).
    a = [ppuaddrs:y]
    //Get high cart RAM addr of nametable(src).
    x = [wramaddrs:y]
    return

//----------------------------------------------------------------------------------------------------

// check if it's time to update nametable (when scrolling is VERTICAL)

def game_engine_page_E571:
    x = [scroll.dir]
    a = [scroll.y]
    //compare value = 0 if ScrollDir = down, else 7
    a = a & 0x7
    compare a to [table11:x]
    //exit if not equal (no nametable update)
    goto _0188 when ~zero

def game_engine_page_E57C:
    x = [scroll.dir]
    //Still scrolling same direction when room was loaded?-->
    compare x to [scroll.temp_dir]
    //If not, branch to exit.
    goto _0188 when ~zero
    a = [scroll.y]
    //keep upper 5 bits
    a = a & 0xf8
    [0x0] = a
    a = 0x0
    [0x0] = [0x0] << 1
    a = a <<< 1
    [0x0] = [0x0] << 1
    a = a <<< 1

def game_engine_page_E590:
    //$0001 = (ScrollY & 0xF8) << 2 = row offset
    [0x1] = a
    call getnameaddrs
    a = a | [0x1]
    [0x3] = a
    a = x
    a = a | [0x1]
    [0x1] = a
    a = [0x0]
    [0x2] = a
    a = [scroll.dir]
    //A = 0 if vertical scrolling, 1 if horizontal
    a = a >> 1
    x = a
    a = [table01:x]
    [0x4] = a
    y = 0x1
    //data pending = YES
    [video.ppu_pending] = y
    y--
    x = [ppustrindex]
    a = [0x3]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    a = [0x2]
    call writeppubyte
    a = [0x4]
    //($C3C6)
    call separatecontrolbits
def _018A:
    a = [[0x0]:y]
    call writeppubyte
    [0x6] = y
    //WRAM pointer increment = 1...
    y = 0x1
    //... if bit 7 (PPU inc) of $04 clear
    compare a & [0x4]
    goto _018B when ~negative
    //else ptr inc = 32
    y = 0x20
def _018B:
    //($C2A8)
    call addytoptr00
    y = [0x6]
    [0x5]--
    goto _018A when ~zero
    [ppustrindex] = x
    call endppustring

def table01:

    //Horizontal write. PPU inc = 1, length = 32 tiles.
    byte: 0x20
    //Vertical write... PPU inc = 32, length = 30 tiles.
    byte: 0x9e

//---------------------------------[Write PPU attribute table data ]----------------------------------

def writeppuattribtbl:

    //Low byte of First row of attribute table.
    x = 0xc0
    a = [roomnumber]
    //Is this the second pass through the routine?-->
    compare a to 0xf2
    //If so, branch.
    goto _018C when zero
    //Low byte of second row of attribute table.
    x = 0xe0
def _018C:
    //$0000=RoomRAM atrrib table starting address.
    [0x0] = x
    //$0002=PPU attrib table starting address.
    [0x2] = x
    //($E564)Get name table addr and corresponding RoomRAM addr.
    call getnameaddrs
    //#$23 for attrib table 0, #$2F for attrib table 3.
    a = a | 0x3
    //Store results.
    [0x3] = a
    //move high byte of RoomRAM to A.
    a = x
    //#$63 for RoomRAMA, #$67 for RoomRAMB(Attrib tables).
    a = a | 0x3
    //Store results.
    [0x1] = a
    a = 0x1
    //Data pending = YES.
    [video.ppu_pending] = a
    //Load current index into PPU strng to append data.
    x = [ppustrindex]
    //Store high byte of starting address(attrib table).
    a = [0x3]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //Store low byte of starting address(attrib table).
    a = [0x2]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //Length of data to write(1 row of attrib data).
    a = 0x20
    [0x4] = a
    //($C36B)Write control byte. Horizontal write.
    call writeppubyte
    //Reset index into data string.
    y = 0x0
def _018D:
    //Get data byte.
    a = [[0x0]:y]
    //($C36B)Put data byte into PPUDataString.
    call writeppubyte
    //Increment to next attrib data byte.
    y++
    [0x4]--
    //Loop until all attrib data loaded into PPU.
    goto _018D when ~zero
    //Store updated PPU string index.
    [ppustrindex] = x
    //($C376)Append end marker(#$00) and exit writing routines.
    call endppustring

//----------------------------------------------------------------------------------------------------

// attempt to move Samus one pixel left

def movesamusleft:

    a = [objectx]
    carry = 1
    a = a -# [objradx]
    a = a & 0x7
    //only call crash detection every 8th pixel
    goto _018E when ~zero
    //check if player is obstructed to the LEFT
    call checkmoveleft
    //branch if yes! (CF = 0)
    goto _0192 when ~carry
def _018E:
    call game_engine_page_D976
    a = [samushit]
    a = a & 0x41
    compare a to 0x41
    carry = 0
    goto _0192 when zero
    a = [samusscrx]
    //reached left scroll limit?
    compare a to 0x71
    //branch if not
    goto _018F when carry
    call scrollleft
    goto _0190 when ~carry
def _018F:
    [samusscrx]--
def _0190:
    a = [objectx]
    goto _0191 when ~zero
    a = [scroll.dir]
    a = a & 0x2
    goto _0191 when zero
    //toggle 9th bit of Samus' X coord
    call togglesamushi
def _0191:
    [objectx]--
    carry = 1
    return

// crash with object on the left

def _0192:
    a = 0x0
    [samusdoordata] = a
    return

// attempt to move Samus one pixel right

def movesamusright:

    a = [objectx]
    carry = 0
    a = a +# [objradx]
    a = a & 0x7
    //only call crash detection every 8th pixel
    goto _0193 when ~zero
    //check if Samus is obstructed to the RIGHT
    call checkmoveright
    //branch if yes! (CF = 0)
    goto _0197 when ~carry
def _0193:
    call game_engine_page_D976
    a = [samushit]
    a = a & 0x41
    compare a to 0x40
    carry = 0
    goto _0197 when zero
    a = [samusscrx]
    //reached right scroll limit?
    compare a to 0x8f
    //branch if not
    goto _0194 when ~carry
    call scrollright
    goto _0195 when ~carry
def _0194:
    [samusscrx]++
def _0195:
    //go right, Samus!
    [objectx]++
    goto _0196 when ~zero
    a = [scroll.dir]
    a = a & 0x2
    goto _0196 when zero
    //toggle 9th bit of Samus' X coord
    call togglesamushi
def _0196:
    carry = 1
    return

// crash with object on the right

def _0197:
    a = 0x0
    [samusdoordata] = a
    return

// Attempt to scroll LEFT

def scrollleft:

    a = [scroll.dir]
    compare a to 0x2
    goto _0198 when zero
    compare a to 0x3
    goto _019B when ~zero
    [scroll.dir]--
    a = [scroll.x]
    goto _0198 when zero
    [mapposx]--
def _0198:
    a = [scroll.x]
    goto _0199 when ~zero
    //decrement MapX
    [mapposx]--
    //put room # at current map pos in $5A
    call getroomnum
    //if function returns CF=1, scrolling left is not possible
    goto _019A when carry
    //switch to the opposite Name Table
    call game_engine_page_E9B7
def _0199:
    [scroll.x]--
    //check if it's time to update Name Table
    call game_engine_page_E54A
    carry = 0
    return

def _019A:
    [mapposx]++
def _019B:
    carry = 1
    return

// Attempt to scroll RIGHT

def scrollright:

    a = [scroll.dir]
    compare a to 0x3
    goto _019C when zero
    compare a to 0x2
    goto _01A0 when ~zero
    [scroll.dir]++
    a = [scroll.x]
    goto _019C when zero
    [mapposx]++
def _019C:
    a = [scroll.x]
    goto _019D when ~zero
    [mapposx]++
    //put room # at current map pos in $5A
    call getroomnum
    //if function returns CF=1, scrolling right is not possible
    goto _019F when carry
def _019D:
    [scroll.x]++
    goto _019E when ~zero
    //switch to the opposite Name Table
    call game_engine_page_E9B7
def _019E:
    //check if it's time to update Name Table
    call game_engine_page_E54A
    carry = 0
    return

def _019F:
    [mapposx]--
def _01A0:
    carry = 1
def _01A1:
    return

def table02:

    byte: 0x7, 0x0

// check if it's time to update nametable (when scrolling is HORIZONTAL)

    x = [scroll.dir]
    a = [scroll.x]
    //keep lower 3 bits
    a = a & 0x7
    //compare value = 0 if ScrollDir = right, else 7
    compare a to [table02-2:x]
    //exit if not equal (no nametable update)
    goto _01A1 when ~zero

    x = [scroll.dir]
    compare x to [scroll.temp_dir]
    goto _01A1 when ~zero
    a = [scroll.x]
    //keep upper five bits
    a = a & 0xf8
    /// 8 (make 'em lower five)
    call adiv8
    [0x0] = a
    a = 0x0
    goto game_engine_page_E590

//---------------------------------------[ Get room number ]-------------------------------------------

//Gets room number at current map position. Sets carry flag if room # at map position is FF.
//If valid room number, the room number is stored in $5A.

def getroomnum:

    a = [scroll.dir]
    //Branch if scrolling vertical.
    a = a >> 1
    goto _01A2 when zero

    //Restore value of a
    a = a <<< 1
    //A=#$01 if scrolling left, A=#$02 if scrolling right.
    a = a +# 0xff
    //Save A.
    push a
    //($EC93)Y=1 if name table=0, Y=0 if name table=3.
    call onnametable0
    //Restore A.
    a = pop
    a = a & [0x6c:y]
    carry = 1
    //Can't load room, a door is in the way. This has the-->
    goto _01A6 when ~zero
                    //effect of stopping the scrolling until Samus walks-->
                    //through the door(horizontal scrolling only).

def _01A2:
    //Map pos y.
    a = [mapposy]
    //($C2C5)Multiply by 16.
    call amul16
    //Store multiplied value in $00.
    [0x0] = a
    a = 0x0
    //Save carry, if any.
    a = a <<< 1
    //Multiply value in $00 by 2.
    [0x0] = [0x0] <<< 1
    //Save carry, if any.
    a = a <<< 1
    [0x1] = a
    a = [0x0]
    //Add map pos X to A.
    a = a +# [mapposx]
    //Store result.
    [0x0] = a
    a = [0x1]
    //Add #$7000 to result.
    a = a +# 0x70
    //$0000 = (MapY*32)+MapX+#$7000.
    [0x1] = a
    y = 0x0
    //Load room number.
    a = [[0x0]:y]
    //Is it unused?-->
    compare a to 0xff
    //If so, branch to exit with carry flag set.
    goto _01A6 when zero

    //Store room number.
    [roomnumber] = a

def _01A3:
    //Is it a special room?-->
    compare a to [0x95d0:y]
    //If so, branch to set flag to play item room music.
    goto _01A4 when zero
    y++
    compare y to 0x7
    //Loop until all special room numbers are checked.
    goto _01A3 when ~zero

    //Load item room music status.
    a = [itemroommusicstatus]
    //Branch if not in special room.
    goto _01A5 when zero
    //Ptop playing item room music after next music start.
    a = 0x80
    //Branch always.
    goto _01A5 when ~zero

def _01A4:
    //Start item room music on next music start.
    a = 0x1
def _01A5:
    [itemroommusicstatus] = a
    //Clear carry flag. was able to get room number.
    carry = 0
def _01A6:
    return

//-----------------------------------------------------------------------------------------------------

def game_engine_page_E770:
    x = [pageindex]
    a = [enrady:x]
    carry = 0
    a = a +# 0x8
    goto game_engine_page_E783

def game_engine_page_E77B:
    x = [pageindex]
    a = 0x0
    carry = 1
    a = a -# [enrady:x]
def game_engine_page_E783:
    [0x2] = a
    a = 0x8
    [0x4] = a
    call game_engine_page_E792
    a = [enradx:x]
    goto game_engine_page_E7BD

def game_engine_page_E792:
    a = [enxroompos:x]
    //X coord
    [0x9] = a
    a = [enyroompos:x]
    //Y coord
    [0x8] = a
    a = [ennametable:x]
    //hi coord
    [0xb] = a
    return

def checkmoveup:

    x = [pageindex]
    a = [objrady:x]
    carry = 0
    a = a +# 0x8
    goto _01A7

def checkmovedown:

    x = [pageindex]
    a = 0x0
    carry = 1
    a = a -# [objrady:x]
def _01A7:
    [0x2] = a
    call game_engine_page_E8BE
    a = [objradx:x]
def game_engine_page_E7BD:
    goto _01A8 when ~zero
    carry = 1
    return

def _01A8:
    [0x3] = a
    y = a
    x = 0x0
    a = [0x9]
    carry = 1
    a = a -# [0x3]
    a = a & 0x7
    goto _01A9 when zero
    x++
def _01A9:
    call 0xe8ce
    [0x4] = a
    call game_engine_page_E90F
    x = 0x0
    y = 0x8
    a = [0x0]
def game_engine_page_E7DE:
    goto _01AC when ~zero
    [0x6] = x
    [0x7] = y
    x = [0x4]

// object<-->background crash detection

def game_engine_page_E7E6:
    //set up ptr in $0004
    call makewramptr
    y = 0x0
    //get tile value
    a = [[0x4]:y]
    compare a to 0x4e
    goto game_engine_page_E81E when zero
    call 0x95c0
    call game_engine_page_D651
    //CF = 0 if tile # < $80 (solid tile)... CRASH!!!
    goto exit16 when ~carry
    //is tile >= A0h? (walkable tile)
    compare a to 0xa0
    goto iswalkabletile when carry
    //tile is $80-$9F (blastable tiles)
    goto isblasttile

def iswalkabletile:

    y = [issamus]
    goto _01AB when zero
    // special case for Samus
    //= 0
    y--
    [samusdoordata] = y
    //crash with tile #$A0? (scroll toggling door)
    compare a to 0xa0
    goto _01AA when zero
    //crash with tile #$A1? (horizontal scrolling door)
    compare a to 0xa1
    goto _01AB when ~zero
    [samusdoordata]++
def _01AA:
    [samusdoordata]++
def _01AB:
    x--
    goto _01AC when zero
    call game_engine_page_E98E
    goto game_engine_page_E7E6

def _01AC:
    //no crash
    carry = 1
def exit16:

    return

def game_engine_page_E81E:
    x = [updatingprojectile]
    goto clcexit when zero
    x = 0x6
def _01AD:
    a = [0x5]
    a = a ^ [0x5d:x]
    a = a & 0x4
    goto _01B0 when ~zero
    a = [0x4]
    a = a ^ [0x5c:x]
    a = a & 0x1f
    goto _01B0 when ~zero
    a = x
    //* 8
    call amul8
    a = a | 0x80
    y = a
    a = [objaction:y]
    goto _01B0 when zero
    a = [0x307:y]
    a = a >> 1
    goto _01AF when carry
    x = [pageindex]
    a = [objaction:x]
    a = a ^ 0xb
    goto _01AE when zero
    a = [objaction:x]
    a = a ^ 0x4
    goto playsnd4 when ~zero
    a = [animresetindex:x]
    a = a ^ 0x91
    goto playsnd4 when ~zero
def _01AE:
    a = [0x683]
    a = a | 0x2
    [0x683] = a
def _01AF:
    a = 0x4
    [0x30a:y] = a
    goto clcexit when ~zero
def _01B0:
    x--
    x--
    goto _01AD when ~negative
    a = [0x4]
    /// 8
    call adiv8
    a = a & 0x1
    x = a
    [0x366:x]++
def clcexit:

    carry = 0
    return

def playsnd4:

    goto sfx_metal

def checkmoveleft:

    x = [pageindex]
    a = [objradx:x]
    carry = 0
    a = a +# 0x8
    goto _01B1

def checkmoveright:

    x = [pageindex]
    a = 0x0
    carry = 1
    a = a -# [objradx:x]
def _01B1:
    [0x3] = a
    call game_engine_page_E8BE
    y = [objrady:x]
def game_engine_page_E89B:
    goto _01B2 when ~zero
    carry = 1
    return

def _01B2:
    [0x2] = y
    x = 0x0
    a = [0x8]
    carry = 1
    a = a -# [0x2]
    a = a & 0x7
    goto _01B3 when zero
    x++
def _01B3:
    call 0xe8ce
    [0x4] = a
    call game_engine_page_E90F
    x = 0x8
    y = 0x0
    a = [0x1]
    goto game_engine_page_E7DE

def game_engine_page_E8BE:
    a = [objecthi:x]
    [0xb] = a
    a = [objecty:x]
    [0x8] = a
    a = [objectx:x]
    [0x9] = a
    return

    a = a ^ 0xff
    carry = 0
    a = a +# 0x1
    a = a & 0x7
    [0x4] = a
    a = y
    a = a << 1
    carry = 1
    a = a -# [0x4]
    goto _01B4 when carry
    a = a +# 0x8
def _01B4:
    y = a
    a = a >> 1
    a = a >> 1
    a = a >> 1
    [0x4] = a
    a = y
    a = a & 0x7
    goto _01B5 when zero
    x++
def _01B5:
    a = x
    carry = 0
    a = a +# [0x4]
    return

def game_engine_page_E8F1:
    x = [pageindex]
    a = [enradx:x]
    carry = 0
    a = a +# 0x8
    goto game_engine_page_E904

def game_engine_page_E8FC:
    x = [pageindex]
    a = 0x0
    carry = 1
    a = a -# [enradx:x]
def game_engine_page_E904:
    [0x3] = a
    call game_engine_page_E792
    y = [enrady:x]
    goto game_engine_page_E89B

def game_engine_page_E90F:
    a = [0x2]
    goto _01B7 when ~negative
    call game_engine_page_E95F
    goto _01B6 when carry
    compare x to 0xf0
    goto _01B8 when ~carry
def _01B6:
    a = x
    a = a +# 0xf
    goto game_engine_page_E934

def _01B7:
    call game_engine_page_E95F
    a = [0x8]
    carry = 1
    a = a -# [0x2]
    x = a
    a = a & 0x7
    [0x0] = a
    goto _01B8 when carry
    a = x
    a = a -# 0xf
def game_engine_page_E934:
    x = a
    a = [scroll.dir]
    a = a & 0x2
    goto _01B8 when ~zero
    [0xb]++
def _01B8:
    [0x2] = x
    x = 0x0
    a = [0x3]
    goto _01B9 when negative
    x--
def _01B9:
    a = [0x9]
    carry = 1
    a = a -# [0x3]
    [0x3] = a
    a = a & 0x7
    [0x1] = a
    a = x
    a = a +# 0x0
    goto _01BA when zero
    a = [scroll.dir]
    a = a & 0x2
    goto _01BA when zero
    [0xb]++
def _01BA:
    return

def game_engine_page_E95F:
    a = [0x8]
    carry = 1
    a = a -# [0x2]
    x = a
    a = a & 0x7
    [0x0] = a
    return

// MakeWRAMPtr
// ===========
// Makes pointer to WRAM nametable based on object's coordinates.
// In: $02 = ObjectY, $03 = ObjectX, $0B = ObjectHi
// Out: $04 = WRAM pointer

def makewramptr:

    a = 0x18
    [0x5] = a
    //ObjectY
    a = [0x2]
    //keep upper 5 bits
    a = a & 0xf8
    a = a << 1
    [0x5] = [0x5] <<< 1
    a = a << 1
    [0x5] = [0x5] <<< 1
    [0x4] = a
    //ObjectX
    a = [0x3]
    a = a >> 1
    a = a >> 1
    //A = ObjectX / 8
    a = a >> 1
    a = a | [0x4]
    [0x4] = a
    //ObjectYHi
    a = [0xb]
    a = a << 1
    //A = ObjectYHi * 4
    a = a << 1
    a = a & 0x4
    a = a | [0x5]
    [0x5] = a
    return

def game_engine_page_E98E:
    a = [0x2]
    carry = 0
    a = a +# [0x6]
    [0x2] = a
    compare a to 0xf0
    goto _01BB when ~carry
    a = a +# 0xf
    [0x2] = a
    a = [scroll.dir]
    a = a & 0x2
    goto _01BB when ~zero
    [0xb]++
def _01BB:
    a = [0x3]
    carry = 0
    a = a +# [0x7]
    [0x3] = a
    goto _01BC when ~carry
    a = [scroll.dir]
    a = a & 0x2
    goto _01BC when zero
    [0xb]++
def _01BC:
    return

def game_engine_page_E9B7:
    a = [video.ctrl]
    a = a ^ 0x3
    [video.ctrl] = a
    return

def isblasttile:

    y = [updatingprojectile]
    goto exit18 when zero
def game_engine_page_E9C2:
    y = a
    call 0x95bd
    compare y to 0x98
    goto _01C1 when carry
// attempt to find a vacant tile slot
    x = 0xc0
def _01BD:
    a = [tileroutine:x]
    //0 = free slot
    goto _01BE when zero
    call xminus16
    goto _01BD when ~zero
    a = [tileroutine:x]
    //no more slots, can't blast tile
    goto _01C1 when ~zero
def _01BE:
    [tileroutine:x]++
    a = [0x4]
    a = a & 0xde
    [tilewramlo:x] = a
    a = [0x5]
    [tilewramhi:x] = a
    a = [inarea]
    compare a to 0x11
    goto _01BF when ~zero
    compare y to 0x76
    goto _01BF when ~zero
    a = 0x4
    goto _01C0 when ~zero
def _01BF:
    a = y
    carry = 0
    a = a +# 0x10
    a = a & 0x3c
    a = a >> 1
def _01C0:
    a = a >> 1
    [tiletype:x] = a
def _01C1:
    carry = 0
def exit18:
    return

//------------------------------------------[ Select room RAM ]---------------------------------------

def selectroomram:

    //($EB85)Find name table to draw room on.
    call getnametable
    a = a << 1
    a = a << 1
    //A=#$64 for name table 3, A=#$60 for name table 0.
    a = a | 0x60
    [cartramptr+1] = a
    a = 0x0
    //Save two byte pointer to start of proper room RAM.
    [cartramptr] = a
    return

//------------------------------------[ write attribute table data ]----------------------------------

def attribtablewrite:
    a = [roomnumber]
    //Determine what row of PPU attribute table data, if any,-->
    a = a & 0xf
    //to load from RoomRAM into PPU.
    [roomnumber]++
    call choose_routine
        //($C45C)Rts.
        word: exit_sub
        //($E5E2)Write first row of PPU attrib data.
        word: writeppuattribtbl
        //($C45C)Rts.
        word: exit_sub
        //($E5E2)Write second row of PPU attrib data.
        word: writeppuattribtbl
        //($EA26)Finished writing attribute table data.
        word: roomfinished

//-----------------------------------[ Finished writing room data ]-----------------------------------

def roomfinished:
    //No more tasks to perform on current room.-->
    a = 0xff
    //Set RoomNumber to #$FF.
    [roomnumber] = a
def _01C3:
    return

//------------------------------------------[ Setup room ]--------------------------------------------

def setuproom:
    //Room number.
    a = [roomnumber]
    compare a to 0xff
    //Branch to exit if room is undefined.
    goto _01C3 when zero
    compare a to 0xfe
    //Branch if empty place holder byte found in room data.
    goto _01C4 when zero
    compare a to 0xf0
    //Branch if time to write PPU attribute table data.
    goto attribtablewrite when carry
    //($EC9B)Update which sprite belongs on which name table.
    call updateroomspriteinfo

    //($ED98)Set up any special items.
    call scanforitems
    //Room number to load.
    a = [roomnumber]
    //*2(for loading address of room pointer).
    a = a << 1
    y = a
    //Low byte of 16-bit room pointer.-->
    a = [[roomptrtable]:y]
    //Base copied from $959A to $3B.
    [roomptr] = a
    y++
    //High byte of 16-bit room pointer.-->
    a = [[roomptrtable]:y]
    //Base copied from $959B to $3C.
    [roomptr+1] = a
    y = 0x0
    //First byte of room data.
    a = [[roomptr]:y]
    //store initial palette # to fill attrib table with.
    [roompal] = a
    a = 0x1
    //($EAC0)Increment room data pointer.
    call addtoroomptr
    //($EA05)Determine where to draw room in RAM, $6000 or $6400.
    call selectroomram
    //($EFF8)clear Name Table & do initial Attrib table setup.
    call inittables
def _01C4:
    //($EAAA)Load room contents into room RAM.
    goto drawroom

//---------------------------------------[ Draw room object ]-----------------------------------------

def drawobject:

    //Store object position byte(%yyyyxxxx).
    [0xe] = a
    a = [cartramptr]
    //Set the working pointer equal to the room pointer-->
    [cartramworkptr] = a
    //(start at beginning of the room).
    a = [cartramptr+1]
    [cartramworkptr+1] = a
    //Reload object position byte.
    a = [0xe]
    //($C2BF)/16. Lower nibble contains object y position.-->
    call adiv16
    //Transfer it to X, prepare for loop.
    x = a
    //Skip y position calculation loop as y position=0 and-->
    goto _01C7 when zero
                    //does not need to be calculated.
def _01C5:
    //LoW byte of pointer working in room RAM.
    a = [cartramworkptr]
    carry = 0
    //Advance two rows in room RAM(one y unit).
    a = a +# 0x40
    [cartramworkptr] = a
    //If carry occurred, increment high byte of pointer-->
    goto _01C6 when ~carry
    //in room RAM.
    [cartramworkptr+1]++
def _01C6:
    x--
    //Repeat until at desired y position(X=0).
    goto _01C5 when ~zero

def _01C7:
    //Reload object position byte.
    a = [0xe]
    //Remove y position upper nibble.
    a = a & 0xf
    //Each x unit is 2 tiles.
    a = a << 1
    a = a +# [cartramworkptr]
    //Add x position to room RAM work pointer.
    [cartramworkptr] = a
    //If carry occurred, increment high byte of room RAM work-->
    goto _01C8 when ~carry
    //pointer, else branch to draw object.
    [cartramworkptr+1]++

//CartRAMWorkPtr now points to the object's starting location (upper left corner)
//on the room RAM which will eventually be loaded into a name table.

def _01C8:
    //Move to the next byte of room data which is-->
    y++
    //the index into the structure pointer table.
    a = [[roomptr]:y]
    //Transfer structure pointer index into X.
    x = a
    //Move to the next byte of room data which is-->
    y++
    //the attrib table info for the structure.
    a = [[roomptr]:y]
    //Save attribute table info.
    [objectpal] = a
    //Restore structure pointer to A.
    a = x
    //*2. Structure pointers are two bytes in size.
    a = a << 1
    y = a
    //Low byte of 16-bit structure ptr.
    a = [[structptrtable]:y]
    [structptr] = a
    y++
    //High byte of 16-bit structure ptr.
    a = [[structptrtable]:y]
    [structptr+1] = a
    //($EF8C)Draw one structure.
    call drawstruct
    //Move to next set of structure data.
    a = 0x3
    //($EAC0)Add A to room data pointer.
    call addtoroomptr

//-------------------------------------------[ Draw room ]--------------------------------------------

//The following function draws a room in the room RAM which is eventually loaded into a name table.

def drawroom:

    //Zero index.
    y = 0x0
    //Load byte of room data.-->
    a = [[roomptr]:y]
    //Is it #$FF(end-of-room)?-->
    compare a to 0xff
    //If so, branch to exit.
    goto endofroom when zero
    //Place holder for empty room objects(not used).
    compare a to 0xfe
    goto _01C9 when zero
    //is A=#$FD(end-of-objects)?-->
    compare a to 0xfd
    //If not, branch to draw room object.-->
    goto drawobject when ~zero
    //Else branch to set up enemies/doors.
    goto endofobjs when zero
def _01C9:
    //Store #$FE if room object is empty.
    [roomnumber] = a
    //Prepare to increment RoomPtr.
    a = 0x1

//-------------------------------------[ Add A to room pointer ]--------------------------------------

def addtoroomptr:

    //Prepare to add index in A to room pointer.
    carry = 0
    a = a +# [roomptr]
    [roomptr] = a
    //Did carry occur? If not branch to exit.
    goto _01CA when ~carry
    //Increment high byte of room pointer if carry occured.
    [roomptr+1]++
def _01CA:
    return

//----------------------------------------------------------------------------------------------------

def endofobjs:

    a = [roomptr]
    //Store room pointer in $0000.
    [0x0] = a
    a = [roomptr+1]
    [0x1] = a
    //Prepare to increment to enemy/door data.
    a = 0x1

def enemyloop:

    //($EF09)Add A to pointer at $0000.
    call addtoptr00
    y = 0x0
    //Get first byte of enemy/door data.
    a = [[0x0]:y]
    //End of enemy/door data?-->
    compare a to 0xff
    //If so, branch to finish room setup.
    goto endofroom when zero
    //Discard upper four bits of data.
    a = a & 0xf
    //Jump to proper enemy/door handling routine.
    call choose_routine
        //($C45C)Rts.
        word: exit_sub
        //($EB06)Room enemies.
        word: loadenemy
        //($EB8C)Room doors.
        word: loaddoor
        //($C45C)Rts.
        word: exit_sub
        //($EC04)Elevator.
        word: loadelevator
        //($C45C)Rts.
        word: exit_sub
        //($EC2F)Kraid & Ridley statues.
        word: loadstatues
        //($EC57)Regenerating enemies(such as Zeb).
        word: zebhole

def endofroom:

    //Prepare for PPU attribute table write.
    x = 0xf0
    [roomnumber] = x
    a = [scroll.dir]
    //Make temp copy of ScrollDir.
    [scroll.temp_dir] = a
    //Check if scrolling left or right.
    a = a & 0x2
    goto _01CB when ~zero
    goto game_engine_page_E57C
def _01CB:
    goto 0xe70c

def loadenemy:

    //($EB0C)Get enemy data from room data.
    call getenemydata
    //($EAD4)Do next room object.
    goto enemyloop

def getenemydata:

    //Get 1st byte again.
    a = [[0x0]:y]
    //Get object slot that enemy will occupy.
    a = a & 0xf0
    x = a
    //($EB7A)Check if object slot is already in use.
    call isslottaken
    //Exit if object slot taken.
    goto _01CD when ~zero
    y++
    //Get enemy type.
    a = [[0x0]:y]
    //($EB28)Load data about enemy.
    call getenemytype
    y = 0x2
    //Get enemy initial position(%yyyyxxxx).
    a = [[0x0]:y]
    call game_engine_page_EB4D
    push a
def _01CC:
    a = pop
def _01CD:
    //Number of bytes to add to ptr to find next room item.
    a = 0x3
    return

def getenemytype:

def game_engine_page_EB28:
    //Store enemy type.
    push a
    //If MSB is set, the "tough" version of the enemy
    a = a & 0xc0
    //is to be loaded(more hit points, except rippers).
    [enspecialattribs:x] = a
    a = a << 1
    //If bit 6 is set, the enemy is either Kraid or Ridley.
    goto _01CF when ~negative
    //Load current area Samus is in(to check if Kraid or-->
    a = [inarea]
    //Ridley is alive or dead).
    a = a & 0x6
    //Use InArea to find status of Kraid/Ridley statue.
    a = a >> 1
    y = a
    //Load status of Kraid/Ridley statue.
    a = [maxmissiles:y]
    //Branch if Kraid or Ridley needs to be loaded.
    goto _01CE when zero
    a = pop
    //Mini boss is dead so pull enemy info and last address off-->
    a = pop
    //stack so next enemy/door item can be loaded.
    goto _01CC

def _01CE:
    //Samus is in Kraid or Ridley's room and the-->
    a = 0x1
    //mini boss is alive and needs to be loaded.
    [kraidridleypresent] = a

def _01CF:
    //Restore enemy type data.
    a = pop
    //Keep 6 lower bits to use as index for enemy data tables.
    a = a & 0x3f
    //Store index byte.
    [endataindex:x] = a
    return

def game_engine_page_EB4D:
    //Save enemy position data in Y.
    y = a
    //Extract Enemy y position.
    a = a & 0xf0
    //Add 8 pixels to y position so enemy is always on screen.
    a = a | 0x8
    //Store enemy y position.
    [enyroompos:x] = a
    //Restore enemy position data.
    a = y
    //*16 to extract enemy x position.
    call amul16
    //Add 12 pixels to x position so enemy is always on screen.
    a = a | 0xc
    //Store enemy x position.
    [enxroompos:x] = a
    a = 0x1
    //Indicate object slot is taken.
    [enstatus:x] = a
    a = 0x0
    [0x404:x] = a
    //($EB85)Get name table to place enemy on.
    call getnametable
    //Store name table.
    [ennametable:x] = a
    //Load A with index to enemy data.
    y = [endataindex:x]
    //*2
    [0x405:x] = [0x405:x] << 1
    call game_engine_page_FB7B
    goto game_engine_page_F85A

def isslottaken:

    a = [enstatus:x]
    goto _01D0 when zero
    a = [0x405:x]
    a = a & 0x2
def _01D0:
    return

//------------------------------------------[ Get name table ]----------------------------------------

//The following routine is small but is called by several other routines so it is important and
//requires some explaining to understand its function.  First of all, as Samus moves from one room
//to the next, she is also moving from one name table to the next.  Samus does not move from one
//name table to the next as one might think. Samus moves diagonally through the name tables. To
//understand this concept, one must first know how the name tables are arranged.  They are arranged
//like so:
//
// +-----+-----+                             +-----+-----+
// |     |     | The following is an incorrect example of how     |     |     |
// |  2  |  3  | Samus goes from one name table to the next-----> |  2  |  3  |
// |     |     |                             |     |     |
// +-----+-----+                             +-----+-----+
// |     |     |                             |     |     |
// |  0  |  1  |                      INCORRECT!------>  |  0<-|->1  |
// |     |     |                             |     |     |
// +-----+-----+                             +-----+-----+
//
//The following are examples of how the name tables are properly traversed while walking through rooms:
//
//       +-----+-----+                     +-----+-----+
//       |     |     |                     |     |     |
//       |  2  | ->3 |                     |  2  |  3<-|-+
//       |     |/    |                     |     |     | |
//       +-----+-----+     <--------CORRECT!-------->      +-----+-----+ |
//       |    /|     |                     |     |     | |
//       | 0<- |  1  |                   +-|->0  |  1  | |
//       |     |     |                   | |     |     | |
//       +-----+-----+                   | +-----+-----+ |
//                               +---------------+
//
//The same diagonal traversal of the name tables illustrated above applies to vetricle traversal as
//well. Since Samus can only travel between 2 name tables and not 4, the name table placement for
//objects is simplified.  The following code determines which name table to use next:

def getnametable:

    a = [video.ctrl]
    //Store #$01 if object should be loaded onto name table 3-->
    a = a ^ [scroll.dir]
    //store #$00 if it should be loaded onto name table 0.
    a = a & 0x1
    return

//----------------------------------------------------------------------------------------------------

// LoadDoor
// ========

def loaddoor:

    call game_engine_page_EB92
def _01D1:
    //do next room object
    goto enemyloop

def game_engine_page_EB92:
    y++
    //door info byte
    a = [[0x0]:y]
    push a
    //CF = door side (0=right, 1=left)
    call amul16
    push p
    a = [mapposx]
    carry = 0
    a = a +# [mapposy]
    p = pop
    a = a <<< 1
    a = a & 0x3
    y = a
    x = [game_engine_page_EC00:y]
    //retrieve door info
    a = pop
    a = a & 0x3
    //door palette
    [0x307:x] = a
    a = y
    push a
    a = [0x307:x]
    compare a to 0x1
    goto _01D3 when zero
    compare a to 0x3
    goto _01D3 when zero
    a = 0xa
    [0x9] = a
    y = [mapposx]
    a = x
    //* 16
    call amul16
    goto _01D2 when ~carry
    y--
def _01D2:
    a = y
    call game_engine_page_EE41
    call game_engine_page_EE4A
    goto _01D4 when carry
def _01D3:
    a = 0x1
    [objaction:x] = a
def _01D4:
    a = pop
    //A = door side (0=right, 1=left)
    a = a & 0x1
    y = a
    //($EB85)
    call getnametable
    [objecthi:x] = a
    //get door's X coordinate
    a = [doorxs:y]
    [objectx:x] = a
    //door Y coord is always #$68
    a = 0x68
    [objecty:x] = a
    a = [game_engine_page_EBFE:y]
    y = a
    //($EB85)
    call getnametable
    a = a ^ 0x1
    x = a
    a = y
    a = a | [dooronnametable3:x]
    [dooronnametable3:x] = a
    a = 0x2
    return

def doorxs:

    //X coord of RIGHT door
    byte: 0xf0
    //X coord of LEFT door
    byte: 0x10
def game_engine_page_EBFE:
    byte: 0x2
    byte: 0x1
def game_engine_page_EC00:
    byte: 0x80
    byte: 0xb0
    byte: 0xa0
    byte: 0x90

// LoadElevator
// ============

def loadelevator:

    call game_engine_page_EC09
    //branch always
    goto _01D1 when ~zero

def game_engine_page_EC09:
    a = [elevatorstatus]
    //exit if elevator already present
    goto _01D5 when ~zero
    y++
    a = [[0x0]:y]
    [0x32f] = a
    y = 0x83
    //elevator Y coord
    [0x32d] = y
    a = 0x80
    //elevator X coord
    [0x32e] = a
    //($EB85)
    call getnametable
    //high Y coord
    [0x32c] = a
    a = 0x23
    //elevator frame
    [0x323] = a
    //1
    [elevatorstatus]++
def _01D5:
    a = 0x2
    return

// LoadStatues
// ===========

def loadstatues:

    //($EB85)
    call getnametable
    [0x36c] = a
    a = 0x40
    x = [ridleystatuestatus]
    //branch if Ridley statue not hit
    goto _01D6 when ~negative
    a = 0x30
def _01D6:
    [0x370] = a
    a = 0x60
    x = [kraidstatuestatus]
    //branch if Kraid statue not hit
    goto _01D7 when ~negative
    a = 0x50
def _01D7:
    [0x36f] = a
    [0x54] = y
    a = 0x1
    [0x360] = a
def _01D8:
    //do next room object
    goto enemyloop

def zebhole:

    x = 0x20
def _01D9:
    a = x
    carry = 1
    a = a -# 0x8
    goto _01DA when negative
    x = a
    y = [0x728:x]
    y++
    goto _01D9 when ~zero
    y = 0x0
    a = [[0x0]:y]
    a = a & 0xf0
    [0x729:x] = a
    y++
    a = [[0x0]:y]
    [0x728:x] = a
    y++
    a = [[0x0]:y]
    y = a
    a = a & 0xf0
    a = a | 0x8
    [0x72a:x] = a
    a = y
    //* 16
    call amul16
    a = a | 0x0
    [0x72b:x] = a
    //($EB85)
    call getnametable
    [0x72c:x] = a
def _01DA:
    a = 0x3
    goto _01D8 when ~zero

def onnametable0:

    a = [video.ctrl]
    //If currently on name table 0,-->
    a = a ^ 0x1
    //return #$01. Else return #$00.
    a = a & 0x1
    y = a
    return

def updateroomspriteinfo:

    x = [scroll.dir]
    x--
    y = 0x0
    //($ED51)Update name table 0 door data.
    call updatedoordata
    y++
    //($ED51)Update name table 3 door data.
    call updatedoordata
    x = 0x50
    //($EB85)
    call getnametable
    y = a
def _01DB:
    a = y
    a = a ^ [ennametable:x]
    a = a >> 1
    goto _01DC when carry
    a = [0x405:x]
    a = a & 0x2
    goto _01DC when ~zero
    [enstatus:x] = a
def _01DC:
    call xminus16
    goto _01DB when ~negative
    x = 0x18
def _01DD:
    a = y
    a = a ^ [0xb3:x]
    a = a >> 1
    goto _01DE when carry
    a = 0x0
    [0xb0:x] = a
def _01DE:
    a = x
    carry = 1
    a = a -# 0x8
    x = a
    goto _01DD when ~negative
    call game_engine_page_ED65
    call game_engine_page_ED5B
    //(EB85)
    call getnametable
    a = a << 1
    a = a << 1
    y = a
    x = 0xc0
def _01DF:
    a = y
    a = a ^ [tilewramhi:x]
    a = a & 0x4
    goto _01E0 when ~zero
    [0x500:x] = a
def _01E0:
    call xminus16
    compare a to 0xf0
    goto _01DF when ~zero
    a = y
    a = a >> 1
    a = a >> 1
    y = a
    x = 0xd0
    call game_engine_page_ED7A
    x = 0xe0
    call game_engine_page_ED7A
    x = 0xf0
    call game_engine_page_ED7A
    a = y
    carry = 1
    a = a -# [0x32c]
    goto _01E1 when ~zero
    [elevatorstatus] = a
def _01E1:
    x = 0x1e
def _01E2:
    a = [0x704:x]
    goto _01E3 when ~zero
    a = 0xff
    [0x700:x] = a
def _01E3:
    a = x
    carry = 1
    a = a -# 0x6
    x = a
    goto _01E2 when ~negative
    compare y to [0x36c]
    goto _01E4 when ~zero
    a = 0x0
    [0x360] = a
def _01E4:
    x = 0x18
def _01E5:
    a = y
    compare a to [0x72c:x]
    goto _01E6 when ~zero
    a = 0xff
    [0x728:x] = a
def _01E6:
    a = x
    carry = 1
    a = a -# 0x8
    x = a
    goto _01E5 when ~negative
    x = 0x0
    call game_engine_page_ED8C
    x = 0x8
    call game_engine_page_ED8C
    goto 0x95ae

def updatedoordata:

    a = x
    a = a ^ 0x3
    //Moves door info from one name table to the next-->
    a = a & [0x6c:y]
def _01E7:
    //when the room is transferred across name tables.
    [0x6c:y] = a
    return

def game_engine_page_ED5B:
    //($EB85)
    call getnametable
    a = a ^ 0x1
    y = a
    a = 0x0
    goto _01E7 when zero
def game_engine_page_ED65:
    x = 0xb0
def _01E8:
    a = [objaction:x]
    goto _01E9 when zero
    a = [objectonscreen:x]
    goto _01E9 when ~zero
    [objaction:x] = a
def _01E9:
    call xminus16
    goto _01E8 when negative
    return

def game_engine_page_ED7A:
    a = [objaction:x]
    compare a to 0x5
    goto _01EA when ~carry
    a = y
    a = a ^ [objecthi:x]
    a = a >> 1
    goto _01EA when carry
    [objaction:x] = a
def _01EA:
    return

def game_engine_page_ED8C:
    a = y
    compare a to [powerupnametable:x]
    goto exit11 when ~zero
    a = 0xff
    [poweruptype:x] = a
def exit11:
    return

//---------------------------------------[ Setup special items ]--------------------------------------

//The following routines look for special items on the game map and jump to
//the appropriate routine to handle those items.

def scanforitems:

    //Low byte of ptr to 1st item data.
    a = [specitmstable]
    [0x0] = a
    //High byte of ptr to 1st item data.
    a = [specitmstable+1]

def scanoneitem:

    [0x1] = a
    //Index starts at #$00.
    y = 0x0
    //Load map Ypos of item.-->
    a = [[0x0]:y]
    //Does it equal Samus' Ypos on map?-->
    compare a to [mapposy]
    //If yes, check Xpos too.
    goto _01EB when zero

    //Exit if item Y pos >  Samus Y Pos.
    goto exit11 when carry
    y++
    //Low byte of ptr to next item data.
    a = [[0x0]:y]
    x = a
    y++
    //AND with hi byte of item ptr.
    a = a & [[0x0]:y]
    //if result is FFh, then this was the last item-->
    compare a to 0xff
    //(item ptr = FFFF). Branch to exit.
    goto exit11 when zero

    //High byte of ptr to next item data.
    a = [[0x0]:y]
    //Write low byte for next item.
    [0x0] = x
    //Process next item.
    goto scanoneitem

def _01EB:
    //Get ready to look at byte containing X pos.
    a = 0x3
    //($EF09)Add 3 to pointer at $0000.
    call addtoptr00

def scanitemx:

    y = 0x0
    //Load map Xpos of object.-->
    a = [[0x0]:y]
    //Does it equal Samus' Xpos on map?-->
    compare a to [mapposx]
    //If so, then load object.
    goto _01EC when zero
    //Exit if item pos X > Samus Pos X.
    goto exit11 when carry

    y++
    //($EF00)Check for another item on same Y pos.
    call anotheritem
    //Try next X coord.
    goto scanitemx

def _01EC:
    //Move ahead two bytes to find item data.
    a = 0x2

def choosehandlerroutine:

    //($EF09)Add A to pointer at $0000.
    call addtoptr00
    y = 0x0
    //Object type
    a = [[0x0]:y]
    //Object handling routine index stored in 4 LSBs.
    a = a & 0xf
    //($C27C)Load proper handling routine from table below.
    call choose_routine
        //($C45C)rts.
        word: exit_sub
        //($EDF8)Some squeepts.
        word: squeepthandler
        //($EDFE)power-ups.
        word: poweruphandler
        //($EE63)Special enemies(Mellows, Melias and Memus).
        word: specenemyhandler
        //($EEA1)Elevators.
        word: elevatorhandler
        //($EEA6)Mother brain room cannons.
        word: cannonhandler
        //($EEAE)Mother brain.
        word: motherbrainhandler
        //($EECA)Zeebetites.
        word: zeebetitehandler
        //($EEEE)Rinkas.
        word: rinkahandler
        //($EEF4)Some doors.
        word: doorhandler
        //($EEFA)Background palette change.
        word: palettehandler

//---------------------------------------[ Squeept handler ]------------------------------------------

def squeepthandler:

    //($EB0C)Load Squeept data.
    call getenemydata
def _01ED:
    //($EDD6)Exit handler routines.
    goto choosehandlerroutine

//--------------------------------------[ Power-up Handler ]------------------------------------------

def poweruphandler:

    //Prepare to store item type.
    y++
    x = 0x0
    a = 0xff
    //Is first power-up item slot available?-->
    compare a to [poweruptype]
    //if yes, branch to load item.
    goto _01EE when zero

    //Prepare to check second power-up item slot.
    x = 0x8
    //Is second power-up item slot available?-->
    compare a to [powerupbtype]
    //If not, branch to exit.
    goto _01EF when ~zero
def _01EE:
    //Power-up item type.
    a = [[0x0]:y]
    //($EE3D)Get unique item ID.
    call prepareitemid
    //($EE4A)Check if Samus already has item.
    call checkforitem
    //Samus already has item. do not load it.
    goto _01EF when carry

    //Prepare to load item coordinates.
    y = 0x2
    a = [0x9]
    //Store power-up type in available item slot.
    [poweruptype:x] = a
    //Load x and y screen positions of item.
    a = [[0x0]:y]
    //Save position data for later processing.
    y = a
    //Extract Y coordinate.
    a = a & 0xf0
    //+ 8 to find  Y coordinate center.
    a = a | 0x8
    //Store center Y coord
    [powerupycoord:x] = a
    //Reload position data.
    a = y
    //($C2C5)*16. Move lower 4 bits to upper 4 bits.
    call amul16
    //+ 8 to find X coordinate center.
    a = a | 0x8
    //Store center X coord
    [powerupxcoord:x] = a
    //($EB85)Get name table to place item on.
    call getnametable
    //Store name table Item is located on.
    [powerupnametable:x] = a

def _01EF:
    //Get next data byte(Always #$00).
    a = 0x3
    //Branch always to exit handler routines.
    goto _01ED when ~zero
    
def prepareitemid:

    //Store item type.
    [0x9] = a
    a = [mapposx]

def game_engine_page_EE41:
    //Store item X coordinate.
    [0x7] = a
    a = [mapposy]
    //Store item Y coordinate.
    [0x6] = a
    //($DC67)Get unique item ID.
    goto createitemid

def checkforitem:

def game_engine_page_EE4A:
    y = [numberofuniqueitems]
    //Samus has no unique items. Load item and exit.
    goto _01F2 when zero
def _01F0:
    a = [0x7]
    //Look for lower byte of unique item.
    compare a to [numberofuniqueitems:y]
    goto _01F1 when ~zero
    //Look for upper byte of unique item.
    a = [0x6]
    compare a to [dataslot:y]
    //Samus already has item. Branch to exit.
    goto _01F3 when zero
def _01F1:
    y--
    y--
    //Loop until all Samus' unique items are checked.
    goto _01F0 when ~zero
def _01F2:
    //Samus does not have the item. It will be placed on screen.
    carry = 0
def _01F3:
    return

//-----------------------------------------------------------------------------------------------------

def specenemyhandler:

    x = 0x18
    a = [randomnumber1]
    a = a +# [framecount]
    [0x8a] = a
def _01F4:
    call 0xee86
    a = x
    carry = 1
    a = a -# 0x8
    x = a
    goto _01F4 when ~negative
    a = [0x95e4]
    [0x6be9] = a
    [0x6bea] = a
    a = 0x1
    [0x6be4] = a
def _01F5:
    //($EDD6)Exit handler routines.
    goto choosehandlerroutine

    a = [0xb0:x]
    goto _01F6 when ~zero
    a = x
    a = a +# [0x8a]
    a = a & 0x7f
    [0xb1:x] = a
    a = a +# [randomnumber2]
    [0xb2:x] = a
    //($EB85)
    call getnametable
    [0xb3:x] = a
    a = 0x1
    [0xb0:x] = a
    [0x8a] = [0x8a] <<< 1
def _01F6:
    return

def elevatorhandler:

    call game_engine_page_EC09
    //Branch always.
    goto _01F5 when ~zero

def cannonhandler:

    call 0x95b1
    a = 0x2
def _01F7:
    //($EDD6)Exit handler routines.
    goto choosehandlerroutine

def motherbrainhandler:

    call 0x95b4
    a = 0x38
    [0x7] = a
    a = 0x0
    [0x6] = a
    call game_engine_page_EE4A
    goto game_engine_page_EEC6 when ~carry
    a = 0x8
    [motherbrainstatus] = a
    a = 0x0
    [motherbrainhits] = a
def game_engine_page_EEC6:
    a = 0x1
    goto _01F7 when ~zero

def zeebetitehandler:

    call 0x95b7
    a = x
    a = a >> 1
    a = a +# 0x3c
    [0x7] = a
    a = 0x0
    [0x6] = a
    call game_engine_page_EE4A
    goto _01F8 when ~carry
    a = 0x81
    [0x758:x] = a
    a = 0x1
    [0x75d:x] = a
    a = 0x7
    [0x75b:x] = a
def _01F8:
    goto game_engine_page_EEC6

def rinkahandler:

    call 0x95ba
    goto game_engine_page_EEC6

def doorhandler:

    call game_engine_page_EB92
    //($EDD6)Exit handler routines.
    goto choosehandlerroutine

def palettehandler:

    a = [scroll.dir]
    [0x91] = a
    goto game_engine_page_EEC6 when ~zero

def anotheritem:

    //Is there another item with same Y pos?-->
    a = [[0x0]:y]
    //If so, A is amount to add to ptr. to find X pos.
    compare a to 0xff
    //($EF09)
    goto addtoptr00 when ~zero
    a = pop
    //No more items to check. Pull last subroutine-->
    a = pop
    //off stack and exit.
    return

def addtoptr00:

    carry = 0
    a = a +# [0x0]
    //A is added to the 16 bit address stored in $0000.
    [0x0] = a
    goto _01F9 when ~carry
    [0x1]++
def _01F9:
    return

//----------------------------------[ Draw structure routines ]----------------------------------------

//Draws one row of the structure.
//A = number of 2x2 tile macros to draw horizontally.

def drawstructrow:

    //Row length(in macros). Range #$00 thru #$0F.
    a = a & 0xf
    goto _01FA when ~zero
    //#$00 in row length=16.
    a = 0x10
def _01FA:
    //Store horizontal macro count.
    [0xe] = a
    //Get length byte again.
    a = [[structptr]:y]
    //($C2BF)/16. Upper nibble contains x coord offset(if any).
    call adiv16
    //*2, because a macro is 2 tiles wide.
    a = a << 1
    //Add x coord offset to CartRAMWorkPtr and save in $00.
    a = a +# [cartramworkptr]
    [0x0] = a
    a = 0x0
    //Save high byte of work pointer in $01.
    a = a +# [cartramworkptr+1]
    //$0000 = work pointer.
    [0x1] = a

def drawmacro:

    //High byte of current location in room RAM.
    a = [0x1]
    //Check high byte of room RAM address for both room RAMs-->
    compare a to 0x63
    //to see if the attribute table data for the room RAM has-->
    goto _01FB when zero
    //been reached.  If so, branch to check lower byte as well.
    compare a to 0x67
    //If not at end of room RAM, branch to draw macro.
    goto _01FC when ~carry
    goto _01FB when zero
    //Return if have gone past room RAM(should never happen).
    return

def _01FB:
    //Low byte of current nametable address.
    a = [0x0]
    //Reached attrib table?-->
    compare a to 0xa0
    //If not, branch to draw the macro.
    goto _01FC when ~carry
    //Can't draw any more of the structure, exit.
    return

def _01FC:
    //Increase struct data index.
    [0x10]++
    //Load struct data index into Y.
    y = [0x10]
    //Get macro number.
    a = [[structptr]:y]
    a = a << 1
    //A=macro number * 4. Each macro is 4 bytes long.
    a = a << 1
    //Store macro index.
    [0x11] = a
    //Prepare to copy four tile numbers.
    x = 0x3
def _01FD:
    //Macro index loaded into Y.
    y = [0x11]
    //Get tile number.
    a = [[macroptr]:y]
    //Increase macro index
    [0x11]++
    //get tile position in macro.
    y = [tilepostable:x]
    //Write tile number to room RAM.
    [[0x0]:y] = a
    //Done four tiles yet?-->
    x--
    //If not, loop to do another.
    goto _01FD when ~negative
    //($EF9E)Update attribute table if necessary
    call updateattrib
    //Macro width(in tiles).
    y = 0x2
    //($C2A8)Add 2 to pointer to move to next macro.
    call addytoptr00
    //Low byte of current room RAM work pointer.
    a = [0x0]
    //Still room left in current row?-->
    a = a & 0x1f
    //If yes, branch to do another macro.
    goto _01FE when ~zero

//End structure row early to prevent it from wrapping on to the next row..
    //Struct index.
    a = [0x10]
    carry = 0
    //Add number of macros remaining in current row.
    a = a +# [0xe]
    carry = 1
    //-1 from macros remaining in current row.
    a = a -# 0x1
    //($EF78)Move to next row of structure.
    goto advancerow

def _01FE:
    //Have all macros been drawn on this row?-->
    [0xe]--
    //If not, branch to draw another macro.
    goto drawmacro when ~zero
    //Load struct index.
    a = [0x10]

def advancerow:

    //Since carry bit is set,-->
    carry = 1
    //addition will be one more than expected.
    a = a +# [structptr]
    //Update the struct pointer.
    [structptr] = a
    goto _01FF when ~carry
    //Update high byte of struct pointer if carry occured.
    [structptr+1]++
def _01FF:
    a = 0x40
    carry = 0
    //Advance to next macro row in room RAM(two tile rows).
    a = a +# [cartramworkptr]
    [cartramworkptr] = a
    //Begin drawing next structure row.
    goto drawstruct when ~carry
    //Increment high byte of pointer if necessary.
    [cartramworkptr+1]++

def drawstruct:

    //Reset struct index.
    y = 0x0
    [0x10] = y
    //Load data byte.
    a = [[structptr]:y]
    //End-of-struct?-->
    compare a to 0xff
    //If so, branch to exit.
    goto _0200 when zero
    //($EF13)Draw a row of macros.
    goto drawstructrow
def _0200:
    return

//The following table is used to draw macros in room RAM. Each macro is 2 x 2 tiles.
//The following table contains the offsets required to place the tiles in each macro.

def tilepostable:

    //Lower right tile.
    byte: 0x21
    //Lower left tile.
    byte: 0x20
    //Upper right tile.
    byte: 0x1
    //Upper left tile.
    byte: 0x0

//---------------------------------[ Update attribute table bits ]------------------------------------

//The following routine updates attribute bits for one 2x2 tile section on the screen.

def updateattrib:

    //Load attribute data of structure.
    a = [objectpal]
    //Is it the same as the room's default attribute data?-->
    compare a to [roompal]
    //If so, no need to modify the attribute table, exit.
    goto _0205 when zero

//Figure out cart RAM address of the byte containing the relevant bits.

    a = [0x0]
    [0x2] = a
    a = [0x1]
    a = a >> 1
    [0x2] = [0x2] >>> 1
    a = a >> 1
    [0x2] = [0x2] >>> 1
    //The following section of code calculates the-->
    a = [0x2]
    //proper attribute byte that corresponds to the-->
    a = a & 0x7
    //macro that has just been placed in the room RAM.
    [0x3] = a
    a = [0x2]
    a = a >> 1
    a = a >> 1
    a = a & 0x38
    a = a | [0x3]
    a = a | 0xc0
    [0x2] = a
    a = 0x63
    //$0002 contains pointer to attribute byte.
    [0x3] = a

    x = 0x0
    compare a & [0x0]
    goto _0201 when ~overflow
    //The following section of code figures out which-->
    x = 0x2
def _0201:
    //pair of bits to modify in the attribute table byte-->
    a = [0x0]
    //for the macro that has just been placed in the-->
    a = a & 0x2
    //room RAM.
    goto _0202 when zero
    x++

//X now contains which macro attribute table bits to modify:
//+---+---+
//| 0 | 1 |
//+---+---+
//| 2 | 3 |
//+---+---+
//Where each box represents a macro(2x2 tiles).

//The following code clears the old attribute table bits and sets the new ones.
def _0202:
    //Load high byte of work pointer in room RAM.
    a = [0x1]
    a = a & 0x4
    //Choose proper attribute table associated with the-->
    a = a | [0x3]
    //current room RAM.
    [0x3] = a
    //Choose appropriate attribute table bit mask from table below.
    a = [attribmasktable:x]
    y = 0x0
    //clear the old attribute table bits.
    a = a & [[0x2]:y]
    [[0x2]:y] = a
    //Load new attribute table data(#$00 thru #$03).
    a = [objectpal]
def _0203:
    x--
    goto _0204 when negative
    a = a << 1
    //Attribute table bits shifted one step left
    a = a << 1
    //Loop until attribute table bits are in the proper location.
    goto _0203 when ~carry
def _0204:
    a = a | [[0x2]:y]
    //Set attribute table bits.
    [[0x2]:y] = a
def _0205:
    return

def attribmasktable:

    //Upper left macro.
    byte: 0b11111100
    //Upper right macro.
    byte: 0b11110011
    //Lower left macro.
    byte: 0b11001111
    //Lower right macro.
    byte: 0b00111111

//------------------------[ Initialize room RAM and associated attribute table ]-----------------------

def inittables:

    //#$60 or #$64.
    a = [cartramptr+1]
    y = a
    //Save value to create counter later.
    x = a
    y++
    //High byte of address to fill to ($63 or $67).
    y++
    y++
    //Value to fill room RAM with.
    a = 0xff
    //($F01C)Fill entire RAM for designated room with #$FF.
    call fillroomram

    //#$5F or #$63 depening on which room RAM was initialized.
    x = [0x1]
    //($E193)X = X + 4.
    call xplus4
    //Set high byte for attribute table write(#$63 or #$67).
    [0x1] = x
    //Index into table below (Lowest 2 bits).
    x = [roompal]
    //Load attribute table data from table below.
    a = [atdatatable:x]
    //Low byte of start of all attribute tables.
    y = 0xc0
def _0206:
    //Fill attribute table.
    [[0x0]:y] = a
    y++
    //Loop until entire attribute table is filled.
    goto _0206 when ~zero
    return

def atdatatable:
       
    byte: 0b00000000
    //Data to fill attribute tables with.
    byte: 0b01010101
    byte: 0b10101010
    byte: 0b11111111

def fillroomram:

    //Temporarily store A.
    push a
    a = x
    //Calculate value to store in X to use as upper byte-->
    [0x1] = y
    //counter for initilaizing room RAM(X=#$FC).-->
    carry = 0
    //Since carry bit is cleared, result is one less than expected.
    a = a -# [0x1]
    x = a
    //Restore value to fill room RAM with(#$FF).
    a = pop
    //Lower address byte to start at.
    y = 0x0
    [0x0] = y
def _0207:
    [[0x0]:y] = a
    y--
    goto _0207 when ~zero
    //Loop until all the room RAM is filled with #$FF(black).
    [0x1]--
    x++
    goto _0207 when ~zero
    return

//----------------------------------------------------------------------------------------------------

// Crash detection
// ===============

def game_engine_page_F034:
    a = 0xff
    [0x73] = a
    [0x10f] = a
// check for crash with Memus
    x = 0x18
def _0208:
    a = [0xb0:x]
    //branch if no Memu in slot
    goto _020D when zero
    compare a to 0x3
    goto _020D when zero
    call game_engine_page_F19A
    call issamusdead
    goto _0209 when zero
    a = [samusblink]
    goto _0209 when ~zero
    y = 0x0
    call game_engine_page_F149
    call game_engine_page_F2B4
    // check for crash with bullets
def _0209:
    y = 0xd0
def _020A:
    //projectile active?
    a = [objaction:y]
    //try next one if not
    goto _020C when zero
    compare a to wa_bulletexplode
    goto _020B when ~carry
    compare a to 0x7
    goto _020B when zero
    compare a to wa_bombexplode
    goto _020B when zero
    compare a to wa_missile
    goto _020C when ~zero
def _020B:
    call game_engine_page_F149
    call game_engine_page_F32A
def _020C:
    call yplus16
    goto _020A when ~zero
def _020D:
    a = x
    carry = 1
    //each Memu occupies 8 bytes
    a = a -# 0x8
    x = a
    goto _0208 when ~negative

    x = 0xb0
def _020E:
    a = [objaction:x]
    compare a to 0x2
    goto _020F when ~zero
    y = 0x0
    call issamusdead
    goto _0210 when zero
    call game_engine_page_DC7F
    call game_engine_page_F277
def _020F:
    call xminus16
    goto _020E when negative
// enemy <--> bullet/missile/bomb detection
def _0210:
    //start with enemy slot #5
    x = 0x50
def game_engine_page_F09F:
    //slot active?
    a = [enstatus:x]
    //branch if not
    goto _0211 when zero
    compare a to 0x3
def _0211:
    //next slot
    goto nextenemy when zero
    call game_engine_page_F152
    a = [enstatus:x]
    compare a to 0x5
    goto _0215 when zero
    //first projectile slot
    y = 0xd0
def _0212:
    //is it active?
    a = [objaction:y]
    //branch if not
    goto _0214 when zero
    compare a to wa_bulletexplode
    goto _0213 when ~carry
    compare a to 0x7
    goto _0213 when zero
    compare a to wa_bombexplode
    goto _0213 when zero
    compare a to wa_missile
    goto _0214 when ~zero
// check if enemy is actually hit
def _0213:
    call game_engine_page_F140
    call game_engine_page_F2CA
def _0214:
    //next projectile slot
    call yplus16
    goto _0212 when ~zero
def _0215:
    y = 0x0
    a = [samusblink]
    goto nextenemy when ~zero
    call issamusdead
    goto nextenemy when zero
    call game_engine_page_F140
    call game_engine_page_F282
def nextenemy:

    call xminus16
    goto _0216 when negative
    goto game_engine_page_F09F

def _0216:
    x = 0x0
    call game_engine_page_F172
    y = 0x60
def _0217:
    a = [enstatus:y]
    goto _0218 when zero
    compare a to 0x5
    goto _0218 when zero
    a = [samusblink]
    goto _0218 when ~zero
    call issamusdead
    goto _0218 when zero
    call game_engine_page_F1B3
    call game_engine_page_F162
    call game_engine_page_F1FA
    call game_engine_page_F2ED
def _0218:
    call yplus16
    compare a to 0xc0
    goto _0217 when ~zero
    y = 0x0
    call issamusdead
    goto _021C when zero
    call game_engine_page_F186
    x = 0xf0
def _0219:
    a = [objaction:x]
    compare a to 0x7
    goto _021A when zero
    compare a to 0xa
    goto _021B when ~zero
def _021A:
    call game_engine_page_DC82
    call game_engine_page_F311
def _021B:
    call xminus16
    compare a to 0xc0
    goto _0219 when ~zero
def _021C:
    //($CE92)
    goto subtracthealth

def game_engine_page_F140:
    call game_engine_page_F1BF
    call game_engine_page_F186
    goto game_engine_page_F1FA

def game_engine_page_F149:
    call game_engine_page_F186
    call game_engine_page_F1D2
    goto game_engine_page_F1FA

def game_engine_page_F152:
    a = [enyroompos:x]
    //Y coord
    [0x7] = a
    a = [enxroompos:x]
    //X coord
    [0x9] = a
    //hi coord
    a = [ennametable:x]
    goto game_engine_page_F17F

def game_engine_page_F162:
    //Y coord
    a = [enyroompos:y]
    [0x6] = a
    //X coord
    a = [enxroompos:y]
    [0x8] = a
    //hi coord
    a = [ennametable:y]
    goto game_engine_page_F193

def game_engine_page_F172:
    a = [objecty:x]
    [0x7] = a
    a = [objectx:x]
    [0x9] = a
    a = [objecthi:x]
def game_engine_page_F17F:
    a = a ^ [video.ctrl]
    a = a & 0x1
    [0xb] = a
    return

def game_engine_page_F186:
    a = [objecty:y]
    [0x6] = a
    a = [objectx:y]
    [0x8] = a
    a = [objecthi:y]
def game_engine_page_F193:
    a = a ^ [video.ctrl]
    a = a & 0x1
    [0xa] = a
    return

def game_engine_page_F19A:
    a = [0xb1:x]
    [0x7] = a
    a = [0xb2:x]
    [0x9] = a
    a = [0xb3:x]
    goto game_engine_page_F17F

def game_engine_page_F1A7:
    a = [objrady:x]
    call game_engine_page_F1E0
    a = [objradx:x]
    goto game_engine_page_F1D9

def game_engine_page_F1B3:
    a = [objrady:x]
    call game_engine_page_F1E7
    a = [objradx:x]
    goto game_engine_page_F1CB

def game_engine_page_F1BF:
    a = [enrady:x]
    call game_engine_page_F1E0
    a = [enradx:x]
    goto game_engine_page_F1D9

def game_engine_page_F1CB:
    carry = 0
    a = a +# [enradx:y]
    [0x5] = a
    return

def game_engine_page_F1D2:
    a = 0x4
    call game_engine_page_F1E0
    a = 0x8
def game_engine_page_F1D9:
    carry = 0
    a = a +# [objradx:y]
    [0x5] = a
    return

def game_engine_page_F1E0:
    carry = 0
    a = a +# [objrady:y]
    [0x4] = a
    return

def game_engine_page_F1E7:
    carry = 0
    a = a +# [enrady:y]
    [0x4] = a
    return

// Y = Y + 16

def yplus16:

    a = y
    carry = 0
    a = a +# 0x10
    y = a
    return

// X = X - 16

def xminus16:

    a = x
    carry = 1
    a = a -# 0x10
    x = a
    return

def game_engine_page_F1FA:
    a = 0x2
    [0x10] = a
    a = a & [scroll.dir]
    [0x3] = a
    a = [0x7]
    carry = 1
    //Y
    a = a -# [0x6]
    [0x0] = a
    a = [0x3]
    goto _021E when ~zero
    a = [0xb]
    a = a ^ [0xa]
    goto _021E when zero
    call game_engine_page_F262
    a = [0x0]
    carry = 1
    a = a -# 0x10
    [0x0] = a
    goto _021D when carry
    [0x1]--
def _021D:
    goto 0xf22b

def _021E:
    a = 0x0
    a = a -# 0x0
    call game_engine_page_F266
    carry = 1
    a = [0x1]
    goto _0220 when ~zero
    a = [0x0]
    [0x11] = a
    compare a to [0x4]
    goto _0220 when carry
    [0x10] = [0x10] << 1
    a = [0x9]
    carry = 1
    a = a -# [0x8]
    [0x0] = a
    a = [0x3]
    goto _021F when zero
    a = [0xb]
    a = a ^ [0xa]
    goto _021F when zero
    call game_engine_page_F262
    goto game_engine_page_F256

def _021F:
    a = a -# 0x0
    call game_engine_page_F266
def game_engine_page_F256:
    carry = 1
    a = [0x1]
    goto _0220 when ~zero
    a = [0x0]
    [0xf] = a
    compare a to [0x5]
def _0220:
    return

def game_engine_page_F262:
    a = [0xb]
    a = a -# [0xa]
def game_engine_page_F266:
    [0x1] = a
    goto _0221 when ~negative
    call game_engine_page_E449
    [0x10]++
def _0221:
    return

def game_engine_page_F270:
    a = a | [0x30a:x]
    [0x30a:x] = a
    return

def game_engine_page_F277:
    goto exit17 when carry
def game_engine_page_F279:
    a = [0x10]
def game_engine_page_F27B:
    a = a | [0x30a:y]
    [0x30a:y] = a
def exit17:

    return

def game_engine_page_F282:
    goto exit17 when carry
    call game_engine_page_F2E8
    //($CD9C)Check if screw attack active.
    call isscrewattackactive
    y = 0x0
    goto _0224 when ~carry
    a = [enstatus:x]
    compare a to 0x4
    goto exit17 when carry
    a = [endataindex:x]
def _0222:
    [0x10f] = a
    y = a
    goto _0223 when negative
    a = [0x968b:y]
    a = a & 0x10
    goto exit17 when ~zero
def _0223:
    y = 0x0
    call game_engine_page_F338
    goto game_engine_page_F306

def _0224:
    a = 0x81
    [0x40e:x] = a
    goto _0226 when ~zero
def game_engine_page_F2B4:
    goto _0225 when carry
    //($CD9C)Check if screw attack active.
    call isscrewattackactive
    y = 0x0
    a = 0xc0
    goto _0222 when carry
def game_engine_page_F2BF:
    a = [0xb6:x]
    a = a & 0xf8
    a = a | [0x10]
    a = a ^ 0x3
    [0xb6:x] = a
def _0225:
    return

def game_engine_page_F2CA:
    goto _0228 when carry
    a = [objaction:y]
    [0x40e:x] = a
    call game_engine_page_F279
def _0226:
    call game_engine_page_F332
def _0227:
    a = a | [0x404:x]
    [0x404:x] = a
def _0228:
    return

def game_engine_page_F2DF:
    a = [0x10]
    a = a | [0x404:y]
    [0x404:y] = a
    return

def game_engine_page_F2E8:
    call game_engine_page_F340
    goto _0227 when ~zero
def game_engine_page_F2ED:
    goto _0229 when carry
    call game_engine_page_F2DF
    a = y
    push a
    //($CD9C)Check if screw attack active.
    call isscrewattackactive
    a = pop
    y = a
    goto _0229 when ~carry
    a = 0x80
    [0x10f] = a
    call game_engine_page_F332
    call game_engine_page_F270
def game_engine_page_F306:
    a = [0x95ce]
    [healthlochange] = a
    a = [0x95cf]
    [healthhichange] = a
def _0229:
    return

def game_engine_page_F311:
    goto exit22 when carry
    a = 0xe0
    [0x10f] = a
    call game_engine_page_F338
    a = [0xf]
    goto _022A when zero
    a = 0x1
def _022A:
    [0x73] = a

def clearhealthchange:

    a = 0x0
    [healthlochange] = a
    [healthhichange] = a

def exit22:
 
    //Return for routine above and below.
    return

def game_engine_page_F32A:
    goto exit22 when carry
    call game_engine_page_F279
    goto game_engine_page_F2BF

def game_engine_page_F332:
    call game_engine_page_F340
    //* 8
    goto amul8

def game_engine_page_F338:
    a = [0x10]
    a = a << 1
    a = a << 1
    a = a << 1
    goto game_engine_page_F27B

def game_engine_page_F340:
    a = [0x10]
    a = a ^ 0x3
    return

// UpdateEnemies
// =============

def updateenemies:

    //Load x with #$50
    x = 0x50
def _022B:
    //($F351)
    call dooneenemy
    x = [pageindex]
    call xminus16
    goto _022B when ~zero
def dooneenemy:

    //PageIndex starts at $50 and is subtracted by $F each iteration.
    [pageindex] = x
                //There is a max of 6 enemies at a time.
    y = [enstatus:x]
    goto _022C when zero
    compare y to 0x3
    goto _022C when carry
    call game_engine_page_F37F
def _022C:
    call 0xf3aa
    a = [enstatus:x]
    [0x81] = a
    compare a to 0x7
    goto _022D when carry
    call choose_routine
        //($C45C) rts
        word: exit_sub
        word: game_engine_page_F3BE
        word: game_engine_page_F3E6
        word: 0xf40d
        word: game_engine_page_F43E
        word: game_engine_page_F483
        word: game_engine_page_F4EE

def _022D:
    //($FA18)Free enemy data slot.
    goto killobject

def game_engine_page_F37F:
    a = [0x405:x]
    a = a & 0x2
    goto _022E when ~zero
    //Y coord
    a = [enyroompos:x]
    [0xa] = a
    //X coord
    a = [enxroompos:x]
    [0xb] = a
    //hi coord
    a = [ennametable:x]
    [0x6] = a
    a = [enrady:x]
    [0x8] = a
    a = [enradx:x]
    [0x9] = a
    //($DFDF)Determine if object is within the screen boundaries.
    call isobjectvisible
    a = x
    goto _022E when ~zero
    a = pop
    a = pop
def _022E:
    x = [pageindex]
    return

    a = [0x405:x]
    a = a << 1
    a = a <<< 1
    y = a
    a = x
    //($C2BF)/16.
    call adiv16
    a = a ^ [framecount]
    a = a >> 1
    a = y
    a = a >>> 1
    a = a >>> 1
    [0x405:x] = a
    return

def game_engine_page_F3BE:
    a = [0x405:x]
    a = a << 1
    goto _022F when negative
    a = 0x0
    [0x6b01:x] = a
    [encounter:x] = a
    [0x40a:x] = a
    call game_engine_page_F6B9
    call game_engine_page_F75B
    call game_engine_page_F682
    call game_engine_page_F676
    a = [endelay:x]
    goto _022F when zero
    call game_engine_page_F7BA
def _022F:
    goto _0231

def game_engine_page_F3E6:
    a = [0x405:x]
    a = a << 1
    goto _0231 when negative
    a = [0x405:x]
    a = a & 0x20
    goto _0230 when zero
    y = [endataindex:x]
    //($96BB)
    a = [enemyinitdelaytbl:y]
    [endelay:x] = a
    [enstatus:x]--
    goto _0231 when ~zero
def _0230:
    call game_engine_page_F6B9
    call game_engine_page_F75B
    call game_engine_page_F51E
def _0231:
    call game_engine_page_F536
    goto 0x95e5

def game_engine_page_F410:
    call updateenemyanim
    call 0x8058
def game_engine_page_F416:
    x = [pageindex]
    a = [enspecialattribs:x]
    goto _0232 when ~negative
    a = [objectcntrl]
    goto _0232 when negative
    a = 0xa3
def game_engine_page_F423:
    [objectcntrl] = a
def _0232:
    a = [enstatus:x]
    goto game_engine_page_F42D when zero
    call game_engine_page_DD8B
def game_engine_page_F42D:
    x = [pageindex]
    a = 0x0
    [0x404:x] = a
    [0x40e:x] = a
    return

def game_engine_page_F438:
    call updateenemyanim
    goto game_engine_page_F416

def game_engine_page_F43E:
    call game_engine_page_F536
    a = [enstatus:x]
    compare a to 0x3
    goto game_engine_page_F410 when zero
    compare a & [objectcntrl]
    goto _0233 when negative
    a = 0xa1
    [objectcntrl] = a
def _0233:
    a = [framecount]
    a = a & 0x7
    goto _0234 when ~zero
    [0x40d:x]--
    goto _0234 when ~zero
    a = [enstatus:x]
    compare a to 0x3
    goto _0234 when zero
    a = [0x40c:x]
    [enstatus:x] = a
    y = [endataindex:x]
    a = [0x969b:y]
    [0x40d:x] = a
def _0234:
    a = [0x40d:x]
    compare a to 0xb
    goto _0235 when carry
    a = [framecount]
    a = a & 0x2
    goto _0235 when zero
    [objectcntrl] = [objectcntrl] << 1
def _0235:
    goto game_engine_page_F416

def game_engine_page_F483:
    a = [0x404:x]
    a = a & 0x24
    goto _023B when zero
    //($FA18)Free enemy data slot.
    call killobject
    y = [enanimframe:x]
    compare y to 0x80
    goto pickupmissile when zero
    a = y
    push a
    a = [endataindex:x]
    push a
    y = 0x0
    x = 0x3
    a = pop
    goto _0237 when ~zero
    x--
    a = pop
    compare a to 0x81
    goto _0236 when ~zero
    //Increase HealthHi by 0.
    x = 0x0
    //Increase HealthLo by 5.
    y = 0x50
def _0236:
    push a
def _0237:
    a = pop
    [healthlochange] = y
    [healthhichange] = x
    //($CEF9)Add health to Samus.
    call addhealth
    goto sfx_energypickup

def pickupmissile:

    a = 0x2
    y = [endataindex:x]
    goto _0238 when zero
    a = 0x1e
def _0238:
    carry = 0
    a = a +# [missilecount]
    //can't have more than 255 missiles
    goto _0239 when carry
    //can Samus hold this many missiles?
    compare a to [maxmissiles]
    //branch if yes
    goto _023A when ~carry
def _0239:
    //set to max. # of missiles allowed
    a = [maxmissiles]
def _023A:
    [missilecount] = a
    goto sfx_missilepickup

def _023B:
    a = [framecount]
    a = a & 0x3
    goto _023C when ~zero
    [0x40d:x]--
    goto _023C when ~zero
    //($FA18)Free enemy data slot.
    call killobject
def _023C:
    a = [framecount]
    a = a & 0x2
    a = a >> 1
    a = a | 0xa0
    [objectcntrl] = a
    goto game_engine_page_F416

def game_engine_page_F4EE:
    [enspecialattribs:x]--
    goto _023E when ~zero
    a = [0x40c:x]
    y = a
    a = a & 0xc0
    [enspecialattribs:x] = a
    a = y
    a = a & 0x3f
    [enstatus:x] = a
    push a
    call 0x80b0
    a = a & 0x20
    goto _023D when zero
    a = pop
    call game_engine_page_F515
    push a
def _023D:
    a = pop
def _023E:
    a = 0xa0
    goto game_engine_page_F423

def game_engine_page_F515:
    [0x40c:x] = a
def game_engine_page_F518:
    a = 0x4
    [enstatus:x] = a
    return

def game_engine_page_F51E:
    a = [scroll.dir]
    x = [pageindex]
    compare a to 0x2
    goto _0240 when ~carry
    //Y coord
    a = [enyroompos:x]
    compare a to 0xec
    goto _0240 when ~carry
    //($FA18)Free enemy data slot.
    goto killobject

def _023F:
    call sfx_metroidhit
    goto getpageindex

def game_engine_page_F536:
    a = [enspecialattribs:x]
    [0xa] = a
    a = [0x404:x]
    a = a & 0x20
    goto _0240 when zero
    a = [0x40e:x]
    compare a to 0x3
    goto _0242 when ~zero
    compare a & [0xa]
    goto _0242 when overflow
    a = [enstatus:x]
    compare a to 0x4
    goto _0242 when zero
    call game_engine_page_F515
    a = 0x40
    [0x40d:x] = a
    call 0x80b0
    a = a & 0x20
    goto _0240 when zero
    a = 0x5
    [enhitpoints:x] = a
    goto 0x95a8
def _0240:
    return

def _0241:
    call 0x80b0
    a = a & 0x20
    goto _023F when ~zero
    call sfx_metal
    goto game_engine_page_F42D

def _0242:
    a = [enhitpoints:x]
    compare a to 0xff
    goto _0241 when zero
    compare a & [0xa]
    goto _0243 when ~overflow
    call sfx_bosshit
    goto _0244 when ~zero
def _0243:
    call game_engine_page_F74B
    a = a & 0xc
    goto playsnd1 when zero
    compare a to 0x4
    goto playsnd2 when zero
    compare a to 0x8
    goto playsnd3 when zero
    call sfx_metroidhit
    //branch always
    goto _0244 when ~zero
def playsnd1:

    call sfx_enemyhit
    //branch always
    goto _0244 when ~zero
def playsnd2:

    call sfx_enemyhit
    //branch always
    goto _0244 when ~zero
def playsnd3:

    //($CBCE)
    call sfx_bigenemyhit
def _0244:
    x = [pageindex]
    call 0x80b0
    a = a & 0x20
    goto _0245 when zero
    a = [0x40e:x]
    compare a to 0xb
    goto _0241 when ~zero
def _0245:
    a = [enstatus:x]
    compare a to 0x4
    goto _0246 when ~zero
    a = [0x40c:x]
def _0246:
    a = a | [0xa]
    [0x40c:x] = a
    a = a << 1
    goto _0247 when negative
    call 0x80b0
    a = a & 0x20
    goto _0247 when ~zero
    y = [0x40e:x]
    compare y to 0xb
    goto _024B when zero
    compare y to 0x81
    goto _024B when zero
def _0247:
    a = 0x6
    [enstatus:x] = a
    a = 0xa
    compare a & [0xa]
    goto _0248 when ~overflow
    a = 0x3
def _0248:
    [enspecialattribs:x] = a
    compare y to 0x2
    goto _0249 when zero
    compare a & [0xa]
    goto _024A when ~overflow
    y = [0x40e:x]
    compare y to 0xb
    goto _024A when ~zero
    [enhitpoints:x]--
    goto _024B when zero
    [enhitpoints:x]--
    goto _024B when zero
def _0249:
    [enhitpoints:x]--
    goto _024B when zero
def _024A:
    [enhitpoints:x]--
    goto getpageindex when ~zero
def _024B:
    a = 0x3
    [enstatus:x] = a
    compare a & [0xa]
    goto _024C when overflow
    a = [0x40e:x]
    compare a to 0x2
    goto _024C when carry
    a = 0x0
    call game_engine_page_DCFC
    x = [pageindex]
def _024C:
    call game_engine_page_F844
    a = [0x960b:y]
    call game_engine_page_F68D
    [encounter:x] = a
    x = 0xc0
def _024D:
    a = [enstatus:x]
    goto _024E when zero
    a = x
    carry = 0
    a = a +# 0x8
    x = a
    compare a to 0xe0
    goto _024D when ~zero
    goto getpageindex when zero
def _024E:
    a = [0x95dd]
    call game_engine_page_F68D
    a = 0xa
    [encounter:x] = a
    [enstatus:x]++
    a = 0x0
    compare a & [0xa]
    goto _024F when ~overflow
    a = 0x3
def _024F:
    [0x407:x] = a
    y = [pageindex]
    a = [enyroompos:y]
    [enyroompos:x] = a
    a = [enxroompos:y]
    [enxroompos:x] = a
    a = [ennametable:y]
    [ennametable:x] = a
def getpageindex:

    x = [pageindex]
    return

def game_engine_page_F676:
    call 0x80b0
    a = a << 1
    a = a << 1
    a = a << 1
    a = a & 0xc0
    [0x6b03:x] = a
    return

def game_engine_page_F682:
    call game_engine_page_F844
    a = [0x963b:y]
    compare a to [enresetanimindex:x]
    goto _0250 when zero
def game_engine_page_F68D:
    [enresetanimindex:x] = a
def game_engine_page_F690:
    [enanimindex:x] = a
def game_engine_page_F693:
    a = 0x0
    [enanimdelay:x] = a
def _0250:
    return

def game_engine_page_F699:
    call game_engine_page_F844
    a = [0x965b:y]
    compare a to [enresetanimindex:x]
    goto exit12 when zero
    call game_engine_page_F68D
    y = [endataindex:x]
    a = [0x967b:y]
    a = a & 0x7f
    goto exit12 when zero
    y = a
def _0251:
    [enanimindex:x]--
    y--
    goto _0251 when ~zero
def exit12:
    return

def game_engine_page_F6B9:
    a = 0x0
    [0x82] = a
    call game_engine_page_F74B
    y = a
    a = [enstatus:x]
    compare a to 0x2
    goto _0252 when ~zero
    a = y
    a = a & 0x2
    goto exit12 when zero
def _0252:
    a = y
    [0x40d:x]--
    goto exit12 when ~zero
    push a
    y = [endataindex:x]
    a = [0x969b:y]
    [0x40d:x] = a
    a = pop
    goto _0256 when ~negative
    a = 0xfe
    call game_engine_page_F7B3
    a = [scroll.dir]
    compare a to 0x2
    goto _0253 when ~carry
    call game_engine_page_F752
    goto _0253 when ~carry
    a = y
    a = a ^ [video.ctrl]
    goto _0255 when carry
def _0253:
    a = [enxroompos:x]
    compare a to [objectx]
    goto _0254 when ~zero
    [0x82]++
def _0254:
    a = a <<< 1
def _0255:
    a = a & 0x1
    call game_engine_page_F744
    a = a >> 1
    a = a >>> 1
    a = a ^ [0x403:x]
    goto _0256 when ~negative
    call 0x81da
def _0256:
    a = 0xfb
    call game_engine_page_F7B3
    a = [scroll.dir]
    compare a to 0x2
    goto _0257 when carry
    call game_engine_page_F752
    goto _0257 when ~carry
    a = y
    a = a ^ [video.ctrl]
    goto _0259 when carry
def _0257:
    a = [enyroompos:x]
    compare a to [objecty]
    goto _0258 when ~zero
    [0x82]++
    [0x82]++
def _0258:
    a = a <<< 1
def _0259:
    a = a & 0x1
    a = a << 1
    a = a << 1
    call game_engine_page_F744
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a >>> 1
    a = a ^ [0x402:x]
    goto _025A when ~negative
    goto 0x820f

def game_engine_page_F744:
    a = a | [0x405:x]
    [0x405:x] = a
def _025A:
    return

def game_engine_page_F74B:
    y = [endataindex:x]
    a = [0x968b:y]
    return

def game_engine_page_F752:
    a = [ennametable:x]
    y = a
    a = a ^ [objecthi]
    a = a >> 1
    return

def game_engine_page_F75B:
    a = 0xe7
    [0x6] = a
    a = 0x18
    call game_engine_page_F744
    y = [endataindex:x]
    a = [0x96ab:y]
    goto _025F when zero
    y = a
    a = [0x405:x]
    a = a & 0x2
    goto _025E when zero
    a = y
    y = 0xf7
    a = a << 1
    goto _025B when carry
    y = 0xef
def _025B:
    a = a >> 1
    [0x2] = a
    [0x6] = y
    a = [objecty]
    [0x0] = a
    y = [enyroompos:x]
    a = [0x405:x]
    goto _025C when negative
    y = [objectx]
    [0x0] = y
    y = [enxroompos:x]
def _025C:
    a = [objecthi]
    a = a >> 1
    [0x0] = [0x0] >>> 1
    a = [ennametable:x]
    a = a >> 1
    a = y
    a = a >>> 1
    carry = 1
    a = a -# [0x0]
    goto _025D when ~negative
    //($C3D4)
    call twoscompliment
def _025D:
    a = a >> 1
    a = a >> 1
    a = a >> 1
    compare a to [0x2]
    goto _025F when ~carry
def _025E:
    a = [0x6]
def game_engine_page_F7B3:
    a = a & [0x405:x]
    [0x405:x] = a
def _025F:
    return

def game_engine_page_F7BA:
    [endelay:x]--
    goto _0260 when ~zero
    a = [0x405:x]
    a = a & 0x8
    goto _0261 when ~zero
    [endelay:x]++
def _0260:
    return

def _0261:
    a = [endataindex:x]
    compare a to 0x7
    goto _0262 when ~zero
    call sfx_outofhole
    x = [pageindex]
def _0262:
    [enstatus:x]++
    call game_engine_page_F699
    y = [endataindex:x]
    a = [0x96cb:y]
    carry = 0
    a = a +# 0xd1
    [0x0] = a
    a = 0x0
    a = a +# 0x97
    [0x1] = a
    a = [framecount]
    a = a ^ [randomnumber1]
    y = 0x0
    a = a & [[0x0]:y]
    y = a
    y++
    a = [[0x0]:y]
    [0x408:x] = a
    call 0x80b0
    goto _0264 when ~negative
    a = 0x0
    [encounter:x] = a
    [0x407:x] = a
    y = [0x408:x]
    a = [0x972b:y]
    [0x6afe:x] = a
    a = [0x973f:y]
    [0x6aff:x] = a
    a = [0x9753:y]
    [0x402:x] = a
    a = [0x9767:y]
    [0x403:x] = a
    a = [0x405:x]
    goto _0263 when negative
    a = a >> 1
    goto _0264 when ~carry
    call 0x81d1
    goto _0264

def _0263:
    a = a & 0x4
    goto _0264 when zero
    call 0x8206
def _0264:
    a = 0xdf
    goto game_engine_page_F7B3

def game_engine_page_F83E:
    a = [0x405:x]
    goto _0265

def game_engine_page_F844:
    a = [0x405:x]
    goto _0265 when ~negative
    a = a >> 1
    a = a >> 1
def _0265:
    a = a >> 1
    a = [endataindex:x]
    a = a <<< 1
    y = a
    return

def game_engine_page_F852:
    a = x
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a +# [framecount]
    a = a >> 1
    return

def game_engine_page_F85A:
    y = [endataindex:x]
    a = [0x969b:y]
    [0x40d:x] = a
    //($962B)
    a = [enemyhitpointtbl:y]
    y = [enspecialattribs:x]
    goto _0266 when ~negative
    a = a << 1
def _0266:
    [enhitpoints:x] = a
def _0267:
    return

def game_engine_page_F870:
    a = [0x405:x]
    a = a & 0x10
    goto _0267 when zero
    a = [0x87]
    a = a & [enstatus:x]
    goto _0267 when zero
    a = [0x87]
    goto _0268 when ~negative
    y = [0x6b01:x]
    goto _0267 when ~zero
def _0268:
    call 0xf8e8
    goto _026A when carry
    [0x404:y] = a
    call game_engine_page_F92C
    a = [0x405:x]
    a = a >> 1
    a = [0x85]
    push a
    a = a <<< 1
    x = a
    a = [0x978b:x]
    push a
    a = y
    x = a
    a = pop
    call game_engine_page_F68D
    x = [pageindex]
    a = 0x1
    [enstatus:y] = a
    a = a & [0x405:x]
    x = a
    a = [table15:x]
    [0x403:y] = a
    a = 0x0
    [0x402:y] = a
    x = [pageindex]
    call game_engine_page_F8F8
    a = [0x405:x]
    a = a >> 1
    a = pop
    x = a
    a = [0x97a3:x]
    [0x4] = a
    a = x
    a = a <<< 1
    x = a
    a = [0x979b:x]
    [0x5] = a
    call game_engine_page_F91D
    x = [pageindex]
    compare a & [0x87]
    goto _026A when ~overflow
    a = [0x405:x]
    a = a & 0x1
    y = a
    a = [0x83:y]
    goto game_engine_page_F690

    y = 0x60
    carry = 0
def _0269:
    a = [enstatus:y]
    goto _026A when zero
    call yplus16
    compare a to 0xc0
    goto _0269 when ~zero
def _026A:
    return

def game_engine_page_F8F8:
    a = [0x85]
    compare a to 0x2
    goto _026B when ~carry
    x = [pageindex]
    a = [0x405:x]
    a = a >> 1
    a = [0x88]
    a = a <<< 1
    a = a & 0x7
    [0x40a:y] = a
    a = 0x2
    [enstatus:y] = a
    a = 0x0
    [endelay:y] = a
    [enanimdelay:y] = a
    [0x408:y] = a
def _026B:
    return

def game_engine_page_F91D:
    x = [pageindex]
    call game_engine_page_E792
    a = y
    x = a
    call game_engine_page_FD8F
    goto game_engine_page_FA49

// Table used by above subroutine

def table15:

    byte: 0x2
    byte: 0xfe

def game_engine_page_F92C:
    a = 0x2
    [enrady:y] = a
    [enradx:y] = a
    a = a | [0x405:y]
    [0x405:y] = a
    return

def game_engine_page_F93B:
    x = 0xb0
def _026C:
    call 0xf949
    x = [pageindex]
    call xminus16
    compare a to 0x60
    goto _026C when ~zero
    [pageindex] = x
    a = [0x405:x]
    a = a & 0x2
    goto _026D when ~zero
    //($FA18)Free enemy data slot.
    call killobject
def _026D:
    a = [enstatus:x]
    goto exit19 when zero
    call choose_routine
        //($C45C) rts
        word: exit_sub
        word: game_engine_page_F96A
        //spit dragon's fireball
        word: game_engine_page_F991
        //($C45C) rts
        word: exit_sub
        word: game_engine_page_FA6B
        word: game_engine_page_FA91

def exit19:
    return

def game_engine_page_F96A:
    call game_engine_page_FA5B
    call game_engine_page_FA1E
    x = [pageindex]
    goto game_engine_page_F97C when carry
    a = [enstatus:x]
    goto exit19 when zero
    call game_engine_page_FA60
def game_engine_page_F97C:
    a = 0x1
def game_engine_page_F97E:
    call updateenemyanim
    goto game_engine_page_DD8B

def _026E:
    [0x408:x]++
def game_engine_page_F987:
    [0x408:x]++
    a = 0x0
    [endelay:x] = a
    goto _026F when zero
def game_engine_page_F991:
    call game_engine_page_FA5B
    a = [0x40a:x]
    a = a & 0xfe
    y = a
    a = [0x97a7:y]
    [0xa] = a
    a = [0x97a8:y]
    [0xb] = a
def _026F:
    y = [0x408:x]
    a = [[0xa]:y]
    compare a to 0xff
    goto _0270 when ~zero
    [0x408:x] = a
    goto game_engine_page_F987

def _0270:
    compare a to [endelay:x]
    goto _026E when zero
    [endelay:x]++
    y++
    a = [[0xa]:y]
    call 0x8296
    x = [pageindex]
    [0x402:x] = a
    a = [[0xa]:y]
    call 0x832f
    x = [pageindex]
    [0x403:x] = a
    y = a
    a = [0x40a:x]
    a = a >> 1
    push p
    goto _0271 when ~carry
    a = y
    //($C3D4)
    call twoscompliment
    [0x403:x] = a
def _0271:
    p = pop
    goto _0272 when ~zero
    a = [0x402:x]
    goto _0272 when zero
    goto _0272 when negative
    y = [0x40a:x]
    a = [0x95e0:y]
    [enresetanimindex:x] = a
def _0272:
    call game_engine_page_FA1E
    x = [pageindex]
    goto _0274 when carry
    a = [enstatus:x]
    goto exit20 when zero
    y = 0x0
    a = [0x40a:x]
    a = a >> 1
    goto _0273 when zero
    y++
def _0273:
    a = [0x95e2:y]
    call game_engine_page_F68D
    call game_engine_page_F518
    a = 0xa
    [endelay:x] = a
def _0274:
    goto game_engine_page_F97C

def killobject:

    a = 0x0
    //Store #$00 as enemy status(enemy slot is open).
    [enstatus:x] = a
    return

// enemy<-->background crash detection

def game_engine_page_FA1E:
    a = [inarea]
    compare a to 0x11
    goto _0275 when ~zero
    a = [enstatus:x]
    a = a >> 1
    goto _0276 when ~carry
def _0275:
    call 0xfa7d
    y = 0x0
    a = [[0x4]:y]
    compare a to 0xa0
    goto _0277 when ~carry
    x = [pageindex]
def _0276:
    a = [0x403:x]
    [0x5] = a
    a = [0x402:x]
    [0x4] = a
def game_engine_page_FA41:
    call game_engine_page_E792
    call game_engine_page_FD8F
    //($FA18)Free enemy data slot.
    goto killobject when ~carry
def game_engine_page_FA49:
    a = [0x8]
    [enyroompos:x] = a
    a = [0x9]
    [enxroompos:x] = a
    a = [0xb]
    a = a & 0x1
    [ennametable:x] = a
def _0277:
    return

def game_engine_page_FA5B:
    a = [0x404:x]
    goto exit20 when zero
def game_engine_page_FA60:
    a = 0x0
    [0x404:x] = a
    a = 0x5
    [enstatus:x] = a
def exit20:
    return

def game_engine_page_FA6B:
    a = [enanimframe:x]
    compare a to 0xf7
    goto _0278 when zero
    [endelay:x]--
    goto _0279 when ~zero
def _0278:
    //($FA18)Free enemy data slot.
    call killobject
def _0279:
    goto game_engine_page_F97C

    x = [pageindex]
    a = [enyroompos:x]
    [0x2] = a
    a = [enxroompos:x]
    [0x3] = a
    a = [ennametable:x]
    [0xb] = a
    goto makewramptr

def game_engine_page_FA91:
    //($FA18)Free enemy data slot.
    call killobject
    a = [0x95dc]
    call game_engine_page_F68D
    goto game_engine_page_F97C

def game_engine_page_FA9D:
    x = 0xc0
def _027A:
    [pageindex] = x
    a = [enstatus:x]
    goto _027B when zero
    call game_engine_page_FAB4
def _027B:
    a = [pageindex]
    carry = 0
    a = a +# 0x8
    x = a
    compare a to 0xe0
    goto _027A when ~zero
def _027C:
    return

def game_engine_page_FAB4:
    [encounter:x]--
    goto _027E when ~zero
    a = 0xc
    [encounter:x] = a
    [0x407:x]--
    goto _027D when negative
    goto _027E when ~zero
def _027D:
    //($FA18)Free enemy data slot.
    call killobject
def _027E:
    a = [encounter:x]
    compare a to 0x9
    goto _027F when ~zero
    a = [0x407:x]
    a = a << 1
    y = a
    a = [table16:y]
    [0x4] = a
    a = [table16+1:y]
    [0x5] = a
    call game_engine_page_FA41
def _027F:
    a = 0x80
    [objectcntrl] = a
    a = 0x3
    goto game_engine_page_F97E

// Table used by above subroutine

def table16:

    byte: 0x0
    byte: 0x0
    byte: 0xc
    byte: 0x1c
    byte: 0x10
    byte: 0xf0
    byte: 0xf0
    byte: 0x8

def game_engine_page_FAF2:
    y = 0x18
def _0280:
    call 0xfaff
    a = [pageindex]
    carry = 1
    a = a -# 0x8
    y = a
    goto _0280 when ~zero

    [pageindex] = y
    x = [0x728:y]
    x++
    goto _027C when zero
    x = [0x729:y]
    a = [enstatus:x]
    goto _0281 when zero
    a = [0x405:x]
    a = a & 0x2
    goto exit13 when ~zero
def _0281:
    [0x404:x] = a
    a = 0xff
    compare a to [endataindex:x]
    goto _0282 when ~zero
    [endelay:x]--
    goto exit13 when ~zero
    a = [0x728:y]
    call game_engine_page_EB28
    y = [pageindex]
    a = [0x72a:y]
    [enyroompos:x] = a
    a = [0x72b:y]
    [enxroompos:x] = a
    a = [0x72c:y]
    [ennametable:x] = a
    a = 0x18
    [enradx:x] = a
    a = 0xc
    [enrady:x] = a
    y = 0x0
    call game_engine_page_F186
    call game_engine_page_F152
    call game_engine_page_F1BF
    call game_engine_page_F1FA
    goto exit13 when ~carry
    a = 0x1
    [endelay:x] = a
    [enstatus:x] = a
    a = a & [scroll.dir]
    a = a << 1
    [0x405:x] = a
    y = [endataindex:x]
    call game_engine_page_FB7B
    goto game_engine_page_F85A

def _0282:
    [endataindex:x] = a
    a = 0x1
    [endelay:x] = a
    //($FA18)Free enemy data slot.
    goto killobject

def game_engine_page_FB7B:
    call 0x80b0
    [0x405:x] = [0x405:x] >>> 1
    //($96BB)Load initial delay for enemy movement.
    a = [enemyinitdelaytbl:y]
    [endelay:x] = a

def exit13:
 
    //Exit from multiple routines.
    return

def game_engine_page_FB88:
    x = [pageindex]
    call game_engine_page_F844
    a = [0x6b01:x]
    [0x6b03:x]++
    [0x6b03:x]--
    goto _0283 when ~zero
    push a
    a = pop
def _0283:
    goto _0284 when ~negative
    //($C3D4)
    call twoscompliment
def _0284:
    compare a to 0x8
    goto _0285 when ~carry
    compare a to 0x10
    goto exit13 when carry
    a = y
    a = a & 0x1
    y = a
    a = [0x85:y]
    compare a to [enresetanimindex:x]
    goto exit13 when zero
    [enanimindex:x] = a
    [enanimindex:x]--
    [enresetanimindex:x] = a
    goto game_engine_page_F693

def _0285:
    a = [0x963b:y]
    compare a to [enresetanimindex:x]
    goto exit13 when zero
    goto game_engine_page_F68D

def game_engine_page_FBCA:
    x = [pageindex]
    call game_engine_page_F844
    a = [0x965b:y]
    compare a to [enresetanimindex:x]
    goto exit13 when zero
    [enresetanimindex:x] = a
    goto game_engine_page_F690

def game_engine_page_FBDD:
    a = 0x40
    [pageindex] = a
    x = 0xc
def _0286:
    call 0xfbec
    x--
    x--
    x--
    x--
    goto _0286 when ~zero
    a = [0xa0:x]
    goto _0288 when zero
    [0xa0:x]--
    a = x
    a = a >> 1
    y = a
    a = [table17:y]
    [0x4] = a
    a = [table17+1:y]
    [0x5] = a
    a = [0xa1:x]
    [0x8] = a
    a = [0xa2:x]
    [0x9] = a
    a = [0xa3:x]
    [0xb] = a
    call game_engine_page_FD8F
    goto _0289 when ~carry
    a = [0x8]
    [0xa1:x] = a
    [0x34d] = a
    a = [0x9]
    [0xa2:x] = a
    [0x34e] = a
    a = [0xb]
    a = a & 0x1
    [0xa3:x] = a
    [0x34c] = a
    a = [0xa3:x]
    [0x34c] = a
    a = 0x5a
    [0x343] = a
    a = x
    push a
    call drawframe
    a = [samusblink]
    goto _0287 when ~zero
    y = 0x0
    x = 0x40
    call game_engine_page_DC7F
    goto _0287 when carry
    //($CD9C)Check if screw attack active.
    call isscrewattackactive
    y = 0x0
    goto _0287 when ~carry
    carry = 0
    call game_engine_page_F311
    a = 0x50
    [healthlochange] = a
    //($CE92)
    call subtracthealth
def _0287:
    a = pop
    x = a
def _0288:
    return

def _0289:
    a = 0x0
    [0xa0:x] = a
    return

// Table used by above subroutine

def table17:

    byte: 0x0
    byte: 0xfb
    byte: 0xfb
    byte: 0xfe
    byte: 0xfb
    byte: 0x2
    byte: 0x0
    byte: 0x5

def game_engine_page_FC65:
    a = [0x6be4]
    goto _028B when zero
    x = 0xf0
    [pageindex] = x
    a = [0x6be9]
    compare a to [0x95e4]
    goto _028C when ~zero
    a = 0x3
    call updateenemyanim
    a = [randomnumber1]
    [0x8a] = a
    a = 0x18
def _028A:
    push a
    x = a
    call game_engine_page_FC98
    a = pop
    x = a
    a = [0xb6:x]
    a = a & 0xf8
    [0xb6:x] = a
    a = x
    carry = 1
    a = a -# 0x8
    goto _028A when ~negative
def _028B:
    return

def _028C:
    //($FA18)Free enemy data slot.
    goto killobject

def game_engine_page_FC98:
    a = [0xb0:x]
    call choose_routine
        //($C45C) rts
        word: exit_sub
        word: game_engine_page_FCA5
        word: game_engine_page_FCB1
        word: game_engine_page_FCBA

def game_engine_page_FCA5:
    call game_engine_page_FD84
    call game_engine_page_FD08
    call game_engine_page_FD25
    goto game_engine_page_DD8B

def game_engine_page_FCB1:
    call game_engine_page_FD84
    call game_engine_page_FCC1
    goto game_engine_page_DD8B

def game_engine_page_FCBA:
    a = 0x0
    [0xb0:x] = a
    goto sfx_enemyhit

def game_engine_page_FCC1:
    call game_engine_page_FD5F
    a = [0xb4:x]
    compare a to 0x2
    goto _028D when carry
    y = [0x8]
    compare y to [objecty]
    goto _028D when ~carry
    a = a | 0x2
    [0xb4:x] = a
def _028D:
    y = 0x1
    a = [0xb4:x]
    a = a >> 1
    goto _028E when ~carry
    y = 0xff
def _028E:
    [0x5] = y
    y = 0x4
    a = a >> 1
    a = [0xb5:x]
    goto _028F when ~carry
    y = 0xfd
def _028F:
    [0x4] = y
    [0xb5:x]++
    call game_engine_page_FD8F
    goto _0290 when carry
    a = [0xb4:x]
    a = a | 0x2
    [0xb4:x] = a
def _0290:
    goto _0291 when ~carry
    call game_engine_page_FD6C
def _0291:
    a = [0xb5:x]
    compare a to 0x50
    goto _0292 when ~carry
    a = 0x1
    [0xb0:x] = a
def _0292:
    return

def game_engine_page_FD08:
    a = 0x0
    [0xb5:x] = a
    y = a
    a = [objectx]
    carry = 1
    a = a -# [0xb2:x]
    goto _0293 when ~negative
    y++
    //($C3D4)
    call twoscompliment
def _0293:
    compare a to 0x10
    goto _0294 when carry
    a = y
    [0xb4:x] = a
    a = 0x2
    [0xb0:x] = a
def _0294:
    return

def game_engine_page_FD25:
    a = x
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a +# [0x8a]
    [0x8a] = a
    [0x8a] = [0x8a] >> 1
    a = a & 0x3
    y = a
    a = [table18:y]
    [0x4] = a
    a = [table18+1:y]
    [0x5] = a
    call game_engine_page_FD5F
    a = [0x8]
    carry = 1
    a = a -# [scroll.y]
    y = a
    a = 0x2
    compare y to 0x20
    goto _0295 when ~carry
    //($C3D4)
    call twoscompliment
    compare y to 0x80
    goto _0296 when ~carry
def _0295:
    [0x4] = a
def _0296:
    call game_engine_page_FD8F
    goto game_engine_page_FD6C

// Table used by above subroutine

def table18:

    byte: 0x2
    byte: 0xfe
    byte: 0x1
    byte: 0xff
    byte: 0x2

def game_engine_page_FD5F:
    a = [0xb3:x]
    [0xb] = a
    a = [0xb1:x]
    [0x8] = a
    a = [0xb2:x]
    [0x9] = a
    return

def game_engine_page_FD6C:
    a = [0x8]
    [0xb1:x] = a
    [0x4f0] = a
    a = [0x9]
    [0xb2:x] = a
    [0x4f1] = a
    a = [0xb]
    a = a & 0x1
    [0xb3:x] = a
    [0x6beb] = a
    return

def game_engine_page_FD84:
    a = [0xb6:x]
    a = a & 0x4
    goto _0297 when zero
    a = 0x3
    [0xb0:x] = a
def _0297:
    return

def game_engine_page_FD8F:
    a = [scroll.dir]
    a = a & 0x2
    [0x2] = a
    a = [0x4]
    carry = 0
    goto _029A when negative
    goto game_engine_page_FDBF when zero
    a = a +# [0x8]
    goto _0298 when carry
    compare a to 0xf0
    goto _0299 when ~carry
def _0298:
    a = a +# 0xf
    y = [0x2]
    goto clcexit2 when ~zero
    [0xb]++
def _0299:
    [0x8] = a
    goto game_engine_page_FDBF

def _029A:
    a = a +# [0x8]
    goto _029B when carry
    a = a -# 0xf
    y = [0x2]
    goto clcexit2 when ~zero
    [0xb]++
def _029B:
    [0x8] = a
def game_engine_page_FDBF:
    a = [0x5]
    carry = 0
    goto _029D when negative
    goto secexit when zero
    a = a +# [0x9]
    goto _029C when ~carry
    y = [0x2]
    goto clcexit2 when zero
    [0xb]++
def _029C:
    goto _029E

def _029D:
    a = a +# [0x9]
    goto _029E when carry
    y = [0x2]
    goto clcexit2 when zero
    [0xb]++
def _029E:
    [0x9] = a
def secexit:

    carry = 1
    return

def clcexit2:

    carry = 0
def _029F:
    return

def game_engine_page_FDE3:
    a = [endtimerhi]
    compare a to 0x99
    goto _02A0 when ~zero
    carry = 0
    //A = zero if timer just started
    a = a -# [endtimerlo]
    //branch if not
    goto _02A0 when ~zero
    [0x6] = a
    a = 0x38
    [0x7] = a
    call game_engine_page_DC54
def _02A0:
    x = 0x20
def _02A1:
    call 0xfe05
    a = x
    carry = 1
    a = a -# 0x8
    x = a
    goto _02A1 when ~zero

    a = [0x758:x]
    carry = 1
    a = a -# 0x2
    goto _029F when ~zero
    [0x6] = a
    [0x758:x]++
    a = x
    a = a >> 1
    a = a +# 0x3c
    [0x7] = a
    goto game_engine_page_DC54

// Tile degenerate/regenerate

def updatetiles:

    x = 0xc0
def _02A2:
    call doonetile
    x = [pageindex]
    call xminus16
    goto _02A2 when ~zero
def doonetile:

    [pageindex] = x
    a = [tileroutine:x]
    //exit if tile not active
    goto _02A3 when zero
    call choose_routine
        //($C45C) rts
        word: exit_sub
        word: game_engine_page_FE3D
        word: game_engine_page_FE54
        word: game_engine_page_FE59
        word: game_engine_page_FE54
        word: game_engine_page_FE83

def game_engine_page_FE3D:
    [tileroutine:x]++
    a = 0x0
    call settileanim
    a = 0x50
    [tiledelay:x] = a
    //low WRAM addr of blasted tile
    a = [tilewramlo:x]
    [0x0] = a
    //high WRAM addr
    a = [tilewramhi:x]
    [0x1] = a

def game_engine_page_FE54:
    a = 0x2
    goto updatetileanim

def game_engine_page_FE59:
    a = [framecount]
    a = a & 0x3
    //only update tile timer every 4th frame
    goto _02A3 when ~zero
    [tiledelay:x]--
    //exit if timer not reached zero
    goto _02A3 when ~zero
    [tileroutine:x]++
    y = [tiletype:x]
    a = [table19:y]
def settileanim:

    [tileanimindex:x] = a
    [0x505:x] = a
    a = 0x0
    [tileanimdelay:x] = a
def _02A3:
    return

// Table used for indexing the animations in TileBlastAnim (see below)

def table19:

    byte: 0x18, 0x1c, 0x20, 0x0, 0x4, 0x8, 0xc, 0x10, 0x24, 0x14

def game_engine_page_FE83:
    a = 0x0
    //tile = respawned
    [tileroutine:x] = a
    a = [tilewramlo:x]
    carry = 0
    a = a +# 0x21
    [0x0] = a
    a = [tilewramhi:x]
    [0x1] = a
    call game_engine_page_FF3C
    a = [0x2]
    [0x7] = a
    a = [0x3]
    [0x9] = a
    a = [0x1]
    a = a >> 1
    a = a >> 1
    a = a & 0x1
    [0xb] = a
    y = 0x0
    call game_engine_page_F186
    a = 0x4
    carry = 0
    a = a +# [objrady]
    [0x4] = a
    a = 0x4
    carry = 0
    a = a +# [objradx]
    [0x5] = a
    call game_engine_page_F1FA
    goto exit23 when carry
    call game_engine_page_F311
    a = 0x50
    [healthlochange] = a
    //($CE92)
    goto subtracthealth

def gettileframeptr:

    a = [tileanimframe:x]
    a = a << 1
    y = a
    a = [0x97af:y]
    [0x2] = a
    a = [0x97b0:y]
    [0x3] = a
def exit23:
    return

def drawtileblast:

    a = [ppustrindex]
    compare a to 0x1f
    goto exit23 when carry
    x = [pageindex]
    a = [tilewramlo:x]
    [0x0] = a
    a = [tilewramhi:x]
    [0x1] = a
    call gettileframeptr
    y = 0x0
    [0x11] = y
    a = [[0x2]:y]
    x = a
    /// 16
    call adiv16
    [0x4] = a
    a = x
    a = a & 0xf
    [0x5] = a
    y++
    [0x10] = y
def _02A4:
    x = [0x5]
def _02A5:
    y = [0x10]
    a = [[0x2]:y]
    [0x10]++
    y = [0x11]
    [[0x0]:y] = a
    [0x11]++
    x--
    goto _02A5 when ~zero
    a = [0x11]
    carry = 0
    a = a +# 0x20
    carry = 1
    a = a -# [0x5]
    [0x11] = a
    [0x4]--
    goto _02A4 when ~zero
    a = [0x1]
    a = a & 0x4
    goto _02A6 when zero
    a = [0x1]
    a = a | 0xc
    [0x1] = a
def _02A6:
    a = [0x1]
    a = a & 0x2f
    [0x1] = a
    call game_engine_page_C328
    carry = 0
    return

def game_engine_page_FF3C:
    a = [0x0]
    y = a
    a = a & 0xe0
    [0x2] = a
    a = [0x1]
    a = a >> 1
    [0x2] = [0x2] >>> 1
    a = a >> 1
    [0x2] = [0x2] >>> 1
    a = y
    a = a & 0x1f
    //* 8
    call amul8
    [0x3] = a
    return

def updatetileanim:

    x = [pageindex]
    y = [tileanimdelay:x]
    goto _02A7 when zero
    [tileanimdelay:x]--
    goto _02A8 when ~zero
def _02A7:
    [tileanimdelay:x] = a
    y = [tileanimindex:x]
    a = [tileblastanim:y]
    //end of "tile-blast" animation?
    compare a to 0xfe
    goto _02A9 when zero
    [tileanimframe:x] = a
    y++
    a = y
    [tileanimindex:x] = a
    call drawtileblast
    goto _02A8 when ~carry
    x = [pageindex]
    [tileanimindex:x]--
def _02A8:
    return

def _02A9:
    [tileroutine:x]++
    a = pop
    a = pop
    return

// Frame data for tile blasts

def tileblastanim:

    byte: 0x6, 0x7, 0x0, 0xfe
    byte: 0x7, 0x6, 0x1, 0xfe
    byte: 0x7, 0x6, 0x2, 0xfe
    byte: 0x7, 0x6, 0x3, 0xfe
    byte: 0x7, 0x6, 0x4, 0xfe
    byte: 0x7, 0x6, 0x5, 0xfe
    byte: 0x7, 0x6, 0x9, 0xfe
    byte: 0x7, 0x6, 0xa, 0xfe
    byte: 0x7, 0x6, 0xb, 0xfe
    byte: 0x7, 0x6, 0x8, 0xfe

    byte: 0x0
    byte: 0x0

//-----------------------------------------------[ RESET ]--------------------------------------------

def reset:

    //Disables interrupt
    interrupt = 1
    //Sets processor to binary mode
    decimal = 0
    x = 0x0
    //Clear PPU control registers
    [nes.ppu.ctrl] = x
    [nes.ppu.mask] = x
def _02AA:
    a = [nes.ppu.status]
    //Wait for VBlank
    goto _02AA when ~negative
def _02AB:
    a = [nes.ppu.status]
    goto _02AB when ~negative
    a = a | 0xff
    //Reset MMC1 chip
    [nes.mmc1.ctrl] = a
    //(MSB is set)
    [nes.mmc1.chr1] = a
    [nes.mmc1.chr2] = a
    [nes.mmc1.prg] = a
    //($C01A)Do preliminary housekeeping.
    goto startup

//Not used.
    byte: 0xff, 0xff, 0xff, 0x4c, 0xe4, 0xb3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0x4d, 0x45, 0x54, 0x52, 0x4f, 0x49, 0x44, 0xe4, 0x8d, 0x0, 0x0, 0x38
    byte: 0x4, 0x1, 0x6, 0x1, 0xbc

//-----------------------------------------[ Interrupt vectors ]--------------------------------------

    //($C0D9)NMI vector.
    word: vblank
    //($FFB0)Reset vector.
    word: reset
    //($FFB0)IRQ vector.
    word: reset

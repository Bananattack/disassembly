// -------------------
// METROID source code
// -------------------
// MAIN PROGRAMMERS
//     HAI YUKAMI
//   ZARU SOBAJIMA
//    GPZ SENGOKU
//    N.SHIOTANI
//     M.HOUDAI
// (C) 1986 NINTENDO
//
//Commented by Dirty McDingus (nmikstas@yahoo.com)
//Disassembled using TRaCER.
//Can be reassembled using Ophis.
//Last updated: 3/9/2010

//Title/end (memory page 0)

in title_page, 0x8000: do

//-----------------------------------------[ Start of code ]------------------------------------------

    a = [titleroutine]
    //If intro routines not running, branch.
    compare a to 0x15
    goto _0001 when carry
    a = [joy1.delta]
    //if start has not been pressed, branch.
    a = a & 0x10
    goto _0000 when zero
    y = 0x0
    //Not accessed by game.
    [sparememd1] = y
    //Not accessed by game.
    [sparemembb] = y
    //Accessed by unused routine.
    [sparememb7] = y
    //Accessed by unused routine.
    [sparememb8] = y
    a = [video.ctrl]
    //Set name table to name table 0.
    a = a & 0xfc
    [video.ctrl] = a
    //If start pressed, load START/CONTINUE screen.
    a = 0x1b
    [titleroutine] = a
    //Branch always.
    goto _0001 when ~zero
def _0000:
    //($C1BC)Remove sparkle and crosshair sprites from screen.
    call removeintrosprites
    a = [titleroutine]
def _0001:
    //($C27C)Jump to proper routine below.
    call choose_routine

    //($8071)First routine after reset.
    word: initializeafterreset
    //($80D0)Draws ground on intro screen.
    word: drawintrobackground
    //($80F9)Sets up METROID fade in delay.
    word: fadeindelay
    //($812C)Fade METROID onto screen.
    word: metroidfadein
    //($8142)Load timer for METROID flash.
    word: loadflashtimer
    //($8109)Makes METROID flash.
    word: flasheffect
    //($814D)Top and bottom "sparkles" on METROID.
    word: metroidsparkle
    //($8163)Fades METROID off the screen.
    word: metroidfadeout
    //($8182)Displays "crosshairs" effect on screen.
    word: crosshairs
    //($81D1)Continue "crosshairs" effect.
    word: morecrosshairs
    //($806E)Increment TitleRoutine.
    word: inctitleroutine
    //($806E)Increment TitleRoutine.
    word: inctitleroutine
    //($822E)Change from name table 0 to name table 1.
    word: changeintronametable
    //($8243)Fade in intro sequence message.
    word: messagefadein
    //($8263)Fade out intro sequence message.
    word: messagefadeout
    //($8283)Set Delay time before intro sequence restarts.
    word: delayintroreplay
    //($8068)clears some memory addresses not used by game.
    word: clearsparemem
    //($82A3)Prepare to restart intro routines.
    word: prepintrorestart
    //($82ED)Turn screen off.
    word: titlescreenoff
    //($82F3)Rts.
    word: titleroutinereturn
    //($82F3)Rts.
    word: titleroutinereturn
    //($90BA)Displays START/Continue screen.
    word: startcontinuescreen
    //($90D7)player chooses between START and CONTINUE.
    word: choosestartcontinue
    //($911A)Loads password entry screen.
    word: loadpasswordscreen
    //($9147)User enters password.
    word: enterpassword
    //($9359)After game over, display password on screen.
    word: displaypassword
    //($9394)Wait for START when showing password.
    word: waitforstart
    //($90BA)Displays START/Continue screen.
    word: startcontinuescreen
    //($939E)Displays "GAME OVER".
    word: gameover
    //($9AA7)Show ending of the game.
    word: endgame
    //($C4AA)Set delay timer.
    word: settimer

//----------------------------------------[ Intro routines ]------------------------------------------

def clearsparemem:

    a = 0x0
    //Clears two memory addresses not used by the game.
    [sparememcb] = a
    [sparememc9] = a

def inctitleroutine:

    //Increment to next title routine.
    [titleroutine]++
    return

def initializeafterreset:

    //Y=2.
    y = 0x2
    //Not accessed by game.
    [sparememcf] = y
    //Not accessed by game.
    [sparememcc] = y
    //Y=1.
    y--
    //Not accessed by game.
    [sparememce] = y
    //Not accessed by game.
    [sparememd1] = y
    //Y=0.
    y--
    //Not accessed by game.
    [sparememd0] = y
    //Not accessed by game.
    [sparememcd] = y
    //Not accessed by game.
    [sparememd3] = y
    //Set NARPASSWORD not active.
    [narpassword] = y
    //Not accessed by game.
    [sparememcb] = y
    //Not accessed by game.
    [sparememc9] = y
    //A=2.
    a = 0x2
    //Title rountines cycle twice before restart of music.
    [intromusicrestart] = a
    //Accessed by unused routine.
    [sparememb7] = y
    //Accessed by unused routine.
    [sparememb8] = y
    //Reset index to palette data.
    [paldataindex] = y
    //Reset index into screen flash palette data.
    [screenflashpalindex] = y
    //Reset index into IntroStarPntr table.
    [introstaroffset] = y
    //Reset index into fade out palette data.
    [fadedataindex] = y
    [0x0] = y
    //Set $0000 to point to address $6000.
    x = 0x60

def _0002:
    [0x1] = x
    a = x
    a = a & 0x3
    a = a << 1
    //The following loop Loads the -->
    y = a
    //RAM with the following values: -->
    [0x2] = y
    //$6000 thru $62FF = #$00.
    a = [ramvaluetbl:y]
    //$6300 thru $633F = #$C0.
    y = 0x0
def _0003:
    //$6340 thru $63FF = #$C4.
    [[0x0]:y] = a
    //$6400 thru $66FF = #$00.
    y++
    //$6700 thru $673F = #$C0.
    goto _0004 when zero
    //$6740 thru $67FF = #$C4.
    compare y to 0x40
    goto _0003 when ~zero
    y = [0x2]
    a = [ramvaluetbl+1:y]
    y = 0x40
    goto _0003 when ~negative
def _0004:
    x++
    compare x to 0x68
    goto _0002 when ~zero

    //Draw intro background next.
    [titleroutine]++
    //($98AE)Loads stars on intro screen.
    goto loadstarsprites

//The following table is used by the code above for writing values to RAM.

def ramvaluetbl:

    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0xc4

def drawintrobackground:

    //Intro music flag.
    a = 0x10
    //Never accessed by game.
    [abstatus] = a
    //Initiates intro music.
    [multisfxflag] = a
    //($C439)Turn screen off.
    call screenoff
    //($C158)Erase name table data.
    call clear_all_nametables
    //Lower address of PPU information.
    x = 0xf4
    //Upper address of PPU information.
    y = 0x82
    //($C20E) Writes background of intro screen to name tables.
    call prepareppuprocess_
    a = 0x1
    //Prepare to load palette data.
    [video.palette_pending] = a
    //Not accessed by game.
    [sparememc5] = a
    a = [video.ctrl]
    //Switch to name table 0
    a = a & 0xfc
    [video.ctrl] = a
    //Next routine sets up METROID fade in delay.
    [titleroutine]++
    a = 0x0
    //Not accessed by game.
    [sparememd7] = a
    //($C447)Turn screen on.
    goto screenon

def fadeindelay:

    a = [video.ctrl]
    //Switch to name table 0 or 2.
    a = a & 0xfe
    [video.ctrl] = a
    //Loads Timer3 with #$08. Delays Fade in routine.-->
    a = 0x8
    //Delays fade in by 80 frames (1.3 seconds).
    [timer3] = a
    a = a >> 1
    //Loads PalDataIndex with #$04
    [paldataindex] = a
    //Increment to next routine.
    [titleroutine]++
    return
 
def flasheffect:

    //Every third frame, run change palette-->
    a = [framecount]
    //Creates METROID flash effect.
    a = a & 0x3
    goto _0005 when ~zero
    //Uses only the first three palette-->
    a = [paldataindex]
    //data sets in the flash routine.
    a = a & 0x3
    [paldataindex] = a
    call loadpaldata
    //If Timer 3 has not expired, branch-->
    a = [timer3]
    //so routine will keep running.
    goto _0005 when ~zero
    a = [paldataindex]
    //Ensures the palette index is back at 0.
    compare a to 0x4
    goto _0005 when ~zero
    //Increment to next routine.
    [titleroutine]++
    //($87AB) Loads data for next routine.
    call loadsparkledata
    //Sets Timer 3 for a delay of 240 frames-->
    a = 0x18
    //(4 seconds).
    [timer3] = a
def _0005:
    return

def metroidfadein:

    a = [timer3]
    goto _0006 when ~zero
    //Every 16th FrameCount, Change palette.-->
    a = [framecount]
    //Causes the fade in effect.
    a = a & 0xf
    goto _0006 when ~zero
    //($8A8C)Load data into Palettes.
    call loadpaldata
    goto _0006 when ~zero
    //Set timer delay for METROID flash effect.-->
    a = 0x20
    //Delays flash by 320 frames (5.3 seconds).
    [timer3] = a
    [titleroutine]++
def _0006:
    return

def loadflashtimer:

    //If 320 frames have not passed, exit
    a = [timer3]
    goto _0006 when ~zero
    a = 0x8
    //Stores a value of 80 frames in Timer3-->
    [timer3] = a
    //(1.3 seconds).
    [titleroutine]++
    return

def metroidsparkle:

    //Wait until 3 seconds have passed since-->
    a = [timer3]
    //last routine before continuing.
    goto _0008 when ~zero
    //Check if sparkle sprites are done moving.
    a = [introspr0complete]
    a = a & [introspr1complete]
    //Is sparkle routine finished? If so,-->
    compare a to 0x1
    //go to next title routine, else continue-->
    goto _0007 when ~zero
    //with sparkle routine.
    [titleroutine]++
    goto _0008 when ~zero
def _0007:
    //($87CF)Update sparkle sprites on the screen.
    call updatesparklesprites
def _0008:
    return

def metroidfadeout:

    //Wait until the frame count is a multiple-->
    a = [framecount]
    //of eight before proceeding.
    a = a & 0x7
    goto _000A when ~zero
    //If FadeDataIndex is less than #$04, keep-->
    a = [fadedataindex]
    //doing the palette changing routine.
    compare a to 0x4
    goto _0009 when ~zero
    //($8897)Load initial sprite values for crosshair routine.
    call loadinitialspritedata
    a = 0x8
    //Load Timer3 with a delay of 80 frames(1.3 seconds).
    [timer3] = a
    //Set counter for slow sprite movement for 8 frames,
    [first4slowcntr] = a
    a = 0x0
    //Set SecondCrosshairSprites = #$00
    [secondcrosshairsprites] = a
    //Move to next routine
    [titleroutine]++
def _0009:
    //($8B5F)Fades METROID off the screen.
    call dofadeout
def _000A:
    return

def crosshairs:

    //Is it time to flash the screen white?-->
    a = [flashscreen]
    //If not, branch.
    goto _000B when zero
    //($8AA7)Flash screen white.
    call flashintroscreen
def _000B:
    //Wait 80 frames from last routine-->
    a = [timer3]
    //before running this one.
    goto _000F when ~zero
    a = [introspr0complete]
    //Check if first 4 sprites have completed-->
    a = a & [introspr1complete]
    //their movements.  If not, branch.
    a = a & [introspr2complete]
    a = a & [introspr3complete]
    goto _000D when zero
    //Prepare to flash screen and draw cross.
    a = 0x1
    //Branch if second crosshair sprites are already-->
    compare a to [secondcrosshairsprites]
    //active.
    goto _000C when zero
    //Indicates second crosshair sprites are active.
    [secondcrosshairsprites]++
    //Draw cross animation on screen.
    [drawcross] = a
    //Flash screen white.
    [flashscreen] = a
    a = 0x0
    //Reset index to cross sprite data.
    [crossdataindex] = a
def _000C:
    a = a & [introspr4complete]
    //Check if second 4 sprites have completed-->
    a = a & [introspr5complete]
    //their movements.  If not, branch.
    a = a & [introspr6complete]
    a = a & [introspr7complete]
    goto _000D when zero
    //Prepare to flash screen and draw cross.
    a = 0x1
    //Draw cross animation on screen.
    [drawcross] = a
    //Flash screen white.
    [flashscreen] = a
    //($98AE)Loads stars on intro screen.
    call loadstarsprites
    a = 0x0
    //Reset index to cross sprite data.
    [crossdataindex] = a
    //Do MoreCrosshairs next frame.
    [titleroutine]++
    //Branch always.
    goto _000E when ~zero
def _000D:
    //($88FE)Draw sprites that converge in center of screen.
    call drawcrosshairssprites
def _000E:
    //($8976)Draw cross sprites in middle of the screen.
    call drawcrosssprites
def _000F:
    return

def morecrosshairs:

    //Is it time to flash the screen white?-->
    a = [flashscreen]
    //If not, branch.
    goto _0010 when zero
    //($8976)Draw cross sprites in middle of the screen.
    call drawcrosssprites
    //($8AA7)Flash screen white.
    goto flashintroscreen
def _0010:
    //ChangeIntroNameTable is next routine to run.
    [titleroutine]++
    a = 0x60
    [objecty] = a
    //These values are written into memory, but they are-->
    a = 0x7c
    //not used later in the title routine.  This is the-->
    [objectx] = a
    //remnants of some abandoned code.
    a = [animresetindex]
    [animindex] = a
    return

def unusedintroroutine1:

    a = 0x1
    [sparemembb] = a
    a = 0x4
    [spritepagepos] = a
    [joy1.delta] = a
    //Unused intro routine.
    [joy1.status] = a
    [joy1.retrigger] = a
    a = 0x3
    [objaction] = a
    [scroll.dir] = a
    [titleroutine]++
    return

def unusedintroroutine2:

    a = [objaction]
    compare a to 0x4
    goto _0011 when ~zero
    a = 0x0
    [objaction] = a
    //Unused intro routine. It looks like this routine-->
    a = 0xb
    //was going to be used to manipulate sprite objects.
    [animresetindex] = a
    a = 0xc
    [animindex] = a
    a = 0x7
    [animframe] = a
    a = 0x8
    [timer3] = a
    a = 0x0
    //Not accessed by game.
    [sparememc9] = a
    //Not accessed by game.
    [sparememcb] = a
    [titleroutine]++
def _0011:
    return

def changeintronametable:

    a = [video.ctrl]
    //Change to name table 1.
    a = a | 0x1
    [video.ctrl] = a
    //Next routine to run is MessageFadeIn.
    [titleroutine]++
    a = 0x8
    //Set Timer3 for 80 frames(1.33 seconds).
    [timer3] = a
    //Index to FadeInPalData.
    a = 0x6
    [fadedataindex] = a
    a = 0x0
    //Not accessed by game.
    [sparememc9] = a
    return

def messagefadein:

    //Check if delay timer has expired.  If not, branch-->
    a = [timer3]
    //to exit, else run this rouine.
    goto _0013 when ~zero
    a = [framecount]
    //Perform next step of fade every 8th frame.
    a = a & 0x7
    goto _0013 when ~zero
    a = [fadedataindex]
    //Has end of fade in palette data been reached?-->
    compare a to 0xb
    //If not, branch.
    goto _0012 when ~zero
    a = 0x0
    //Clear FadeDataIndex.
    [fadedataindex] = a
    a = 0x30
    //Set Timer3 to 480 frames(8 seconds).
    [timer3] = a
    //Next routine is MessageFadeOut.
    [titleroutine]++
    //Branch always.
    goto _0013 when ~zero
def _0012:
    //($8B5F)Fade message onto screen.
    call dofadeout
def _0013:
    return

def messagefadeout:

    //Check if delay timer has expired.  If not, branch-->
    a = [timer3]
    //to exit, else run this rouine.
    goto _0015 when ~zero
    a = [framecount]
    //Perform next step of fade every 8th frame.
    a = a & 0x7
    goto _0015 when ~zero
    a = [fadedataindex]
    //Has end of fade out palette data been reached?-->
    compare a to 0x5
    //If not, branch.
    goto _0014 when ~zero
    a = 0x6
    //Set index to start of fade in data.
    [fadedataindex] = a
    a = 0x0
    //Not accessed by game.
    [sparememcb] = a
    //Next routine is DelayIntroReplay.
    [titleroutine]++
    //Branch always.
    goto _0015 when ~zero
def _0014:
    //($8B5F)Fade message off of screen.
    call dofadeout
def _0015:
    return

def delayintroreplay:

    //Increment to next routine.
    [titleroutine]++
    a = 0x10
    //Set Timer3 for a delay of 160 frames(2.6 seconds).
    [timer3] = a
    return

def unusedintroroutine3:

    a = [timer3]
    goto _0016 when ~zero
    a = [sparememb7]
    goto _0016 when ~zero
    a = [sparememb8]
    //Unused intro routine.
    a = a & 0xf
    goto _0016 when ~zero
    a = 0x1
    [sparememd2] = a
    a = 0x10
    [timer3] = a
    [titleroutine]++
def _0016:
    return

def prepintrorestart:

    //Check if delay timer has expired.  If not, branch-->
    a = [timer3]
    //to exit, else run this rouine.
    goto _0018 when ~zero
    //Not accessed by game.
    [sparememd2] = a
    //Not accessed by game.
    [sparemembb] = a
    //Clear IsSamus memory address.
    [issamus] = a
    y = 0x1f
def _0017:
    [objaction:y] = a
    //Clear RAM $0300 thru $031F.
    y--
    goto _0017 when ~negative
    //Change to name table 0.
    a = [video.ctrl]
    a = a & 0xfc
    [video.ctrl] = a
    //Y=0.
    y++
    //Accessed by unused routine.
    [sparememb7] = y
    //Accessed by unused routine.
    [sparememb8] = y
    [paldataindex] = y
    //Clear all index values from these addresses.
    [screenflashpalindex] = y
    [introstaroffset] = y
    [fadedataindex] = y
    //Not accessed by game.
    [sparememcd] = y
    [joy1.delta] = y
    //Clear addresses that were going to be written to by an-->
    [joy1.status] = y
    //unused intro routine.
    [joy1.retrigger] = y
    //Not accessed by game.
    [sparememd7] = y
    //Y=1.
    y++
    //Not accessed by game.
    [sparememce] = y
    //Y=2.
    y++
    //Not accessed by game.
    [sparememcc] = y
    //Not accessed by game.
    [sparememcf] = y
    //Next routine sets up METROID fade in delay.
    [titleroutine] = y
    //Check to see if intro music needs to be restarted.-->
    a = [intromusicrestart]
    //Branch if not.
    goto _0019 when ~zero
    a = 0x10
    //Restart intro music.
    [multisfxflag] = a
    //Set restart of intro music after another two cycles-->
    a = 0x2
    //of the title routines.
    [intromusicrestart] = a
def _0018:
    return
 
def _0019:
    //One title routine cycle complete. Decrement intro-->
    [intromusicrestart]--
    //music restart counter.
    return

def titlescreenoff:

    //($C439)Turn screen off.
    call screenoff
    //Next routine is TitleRoutineReturn.
    [titleroutine]++
    //This routine should not be reached.
    return

def titleroutinereturn:

    //Last title routine function. Should not be reached.
    return

//The following data fills name table 0 with the intro screen background graphics.

//Information to be stored in attribute table 0.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xc0
    //PPU string length.
    byte: 0x20
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xe0
    //PPU string length.
    byte: 0x20
    byte: 0xff, 0xff, 0xbf, 0xaf, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

//Writes row $22E0 (24th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0xe0
    //PPU string length.
    byte: 0x20
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xff, 0xff, 0x8e, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xff, 0xff, 0x8e, 0xff

//Writes row $2300 (25th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x0
    //PPU string length.
    byte: 0x20
    byte: 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81
    byte: 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81

//Writes row $2320 (26th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x20
    //PPU string length.
    byte: 0x20
    byte: 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83
    byte: 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83

//Writes row $2340 (27th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x40
    //PPU string length.
    byte: 0x20
    byte: 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85
    byte: 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85

//Writes row $2360 (28th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x60
    //PPU string length.
    byte: 0x20
    byte: 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87
    byte: 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87

//Writes row $2380 (29th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x80
    //PPU string length.
    byte: 0x20
    byte: 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89
    byte: 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89

//Writes row $23A0 (Bottom row).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xa0
    //PPU string length.
    byte: 0x20
    byte: 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b
    byte: 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b

//Writes some blank spaces in row $20A0 (6th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0xa8
    //PPU string length.
    byte: 0x4f
    //Since RLE bit set, repeat 16 blanks starting at $20A8.
    byte: 0xff

//Writes METROID graphics in row $2100 (9th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x3
    //PPU string length.
    byte: 0x1c
    byte: 0x40, 0x5d, 0x56, 0x5d, 0x43, 0x40, 0x5d, 0x43, 0x40, 0x5d, 0x5d, 0x43, 0x40, 0x5d, 0x5d, 0x63
    byte: 0x62, 0x5d, 0x5d, 0x63, 0x40, 0x43, 0x40, 0x5d, 0x5d, 0x63, 0x1d, 0x16

//Writes METROID graphics in row $2120 (10th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x23
    //PPU string length.
    byte: 0x1a
    byte: 0x44, 0x50, 0x50, 0x50, 0x47, 0x44, 0x57, 0x58, 0x74, 0x75, 0x76, 0x77, 0x44, 0x57, 0x69, 0x47
    byte: 0x44, 0x57, 0x69, 0x47, 0x44, 0x47, 0x44, 0x68, 0x69, 0x47

//Writes METROID graphics in row $2140 (11th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x43
    //PPU string length.
    byte: 0x1a
    byte: 0x44, 0x41, 0x7e, 0x49, 0x47, 0x44, 0x59, 0x5a, 0x78, 0x79, 0x7a, 0x7b, 0x44, 0x59, 0x6d, 0x70
    byte: 0x44, 0x73, 0x72, 0x47, 0x44, 0x47, 0x44, 0x73, 0x72, 0x47

//Writes METROID graphics in row $2160 (12th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x63
    //PPU string length.
    byte: 0x1a
    byte: 0x44, 0x42, 0x7f, 0x4a, 0x47, 0x44, 0x5b, 0x5c, 0xff, 0x44, 0x47, 0xff, 0x44, 0x5b, 0x6f, 0x71
    byte: 0x44, 0x45, 0x46, 0x47, 0x44, 0x47, 0x44, 0x45, 0x46, 0x47

//Writes METROID graphics in row $2180 (13th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x83
    //PPU string length.
    byte: 0x1a
    byte: 0x44, 0x47, 0xff, 0x44, 0x47, 0x44, 0x5f, 0x60, 0xff, 0x44, 0x47, 0xff, 0x44, 0x7d, 0x7c, 0x47
    byte: 0x44, 0x6a, 0x6b, 0x47, 0x44, 0x47, 0x44, 0x6a, 0x6b, 0x47

//Writes METROID graphics in row $21A0 (14th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xa3
    //PPU string length.
    byte: 0x1a
    byte: 0x4c, 0x4f, 0xff, 0x4c, 0x4f, 0x4c, 0x5e, 0x4f, 0xff, 0x4c, 0x4f, 0xff, 0x4c, 0x4d, 0x4e, 0x4f
    byte: 0x66, 0x5e, 0x5e, 0x64, 0x4c, 0x4f, 0x4c, 0x5e, 0x5e, 0x64

//Writes METROID graphics in row $21C0 (15th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xc3
    //PPU string length.
    byte: 0x1a
    byte: 0x51, 0x52, 0xff, 0x51, 0x52, 0x51, 0x61, 0x52, 0xff, 0x51, 0x52, 0xff, 0x51, 0x53, 0x54, 0x52
    byte: 0x67, 0x61, 0x61, 0x65, 0x51, 0x52, 0x51, 0x61, 0x61, 0x65

//Writes PUSH START BUTTON in row $2220 (18th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x27
    //PPU string length.
    byte: 0x15
//             '_    P    U    S    H    _    S    T    A    R    T    _    B    U    T    T
    byte: 0xff, 0x19, 0x1e, 0x1c, 0x11, 0xff, 0x1c, 0x1d, 0xa, 0x1b, 0x1d, 0xff, 0xb, 0x1e, 0x1d, 0x1d
//           O    N    _    _    _'
    byte: 0x18, 0x17, 0xff, 0xff, 0xff

//Writes C 1986 NINTENDO in row $2260 (20th row from top).
    //PPU memory high byte.
    byte: 0x22
    //PPU memory low byte.
    byte: 0x69
    //PPU string length.
    byte: 0x12
//             'C    _    1    9    8    6    _    N    I    N    T    E    N    D    O    _
    byte: 0x8f, 0xff, 0x1, 0x9, 0x8, 0x6, 0xff, 0x17, 0x12, 0x17, 0x1d, 0xe, 0x17, 0xd, 0x18, 0xff
//           _    _'
    byte: 0xff, 0xff

//The following data fills name table 1 with the intro screen background graphics.

//Information to be stored in attribute table 1.
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0xc0
    //PPU string length.
    byte: 0x20
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

//Writes row $27E0 (24th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0xe0
    //PPU string length.
    byte: 0x20
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

//Writes row $26E0 (24th row from top).
    //PPU memory high byte.
    byte: 0x26
    //PPU memory low byte.
    byte: 0xe0
    //PPU string length.
    byte: 0x20
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xff, 0xff, 0x8e, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x8c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8d, 0xff, 0xff, 0x8e, 0xff

//Writes row $2700 (25th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0x0
    //PPU string length.
    byte: 0x20
    byte: 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81
    byte: 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81, 0x80, 0x81

//Writes row $2720 (26th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0x20
    //PPU string length.
    byte: 0x20
    byte: 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83
    byte: 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83, 0x82, 0x83

//Writes row $2740 (27th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0x40
    //PPU string length.
    byte: 0x20
    byte: 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85
    byte: 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85, 0x84, 0x85

//Writes row $2760 (28th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0x60
    //PPU string length.
    byte: 0x20
    byte: 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87
    byte: 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87, 0x86, 0x87

//Writes row $2780 (29th row from top).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0x80
    //PPU string length.
    byte: 0x20
    byte: 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89
    byte: 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89, 0x88, 0x89

//Writes row $27A0 (bottom row).
    //PPU memory high byte.
    byte: 0x27
    //PPU memory low byte.
    byte: 0xa0
    //PPU string length.
    byte: 0x20
    byte: 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b
    byte: 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b, 0x8a, 0x8b

//Writes row $2480 (5th row from top).
    //PPU memory high byte.
    byte: 0x24
    //PPU memory low byte.
    byte: 0x88
    //PPU string length.
    byte: 0xf
//             'E    M    E    R    G    E    N    C    Y    _    O    R    D    E    R'
    byte: 0xe, 0x16, 0xe, 0x1b, 0x10, 0xe, 0x17, 0xc, 0x22, 0xff, 0x18, 0x1b, 0xd, 0xe, 0x1b

//Writes row $2500 (9th row from top).
    //PPU memory high byte.
    byte: 0x25
    //PPU memory low byte.
    byte: 0x4
    //PPU string length.
    byte: 0x1c
//             'D    E    F    E    A    T    _    T    H    E    _    M    E    T    R    0
    byte: 0xd, 0xe, 0xf, 0xe, 0xa, 0x1d, 0xff, 0x1d, 0x11, 0xe, 0xff, 0x16, 0xe, 0x1d, 0x1b, 0x18
//           I    D    _    O    F    _    _    _    _    _    _    _'
    byte: 0x12, 0xd, 0xff, 0x18, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

//Writes row $2540 (11th row from top).
    //PPU memory high byte.
    byte: 0x25
    //PPU memory low byte.
    byte: 0x44
    //PPU string length.
    byte: 0x1a
//             'T    H    E    _    P    L    A    N    E    T    _    Z    E    B    E    T
    byte: 0x1d, 0x11, 0xe, 0xff, 0x19, 0x15, 0xa, 0x17, 0xe, 0x1d, 0xff, 0x23, 0xe, 0xb, 0xe, 0x1d
//           H    _    A    N    D    _    _    _    _    _'
    byte: 0x11, 0xff, 0xa, 0x17, 0xd, 0xff, 0xff, 0xff, 0xff, 0xff

//Writes row $2580 (13th row from top).
    //PPU memory high byte.
    byte: 0x25
    //PPU memory low byte.
    byte: 0x84
    //PPU string length.
    byte: 0x1a
//             'D    E    S    T    R    O    Y    _    T    H    E    _    M    O    T    H
    byte: 0xd, 0xe, 0x1c, 0x1d, 0x1b, 0x18, 0x22, 0xff, 0x1d, 0x11, 0xe, 0xff, 0x16, 0x18, 0x1d, 0x11
//           E    R    _    B    R    A    I    N    _    _'
    byte: 0xe, 0x1b, 0xff, 0xb, 0x1b, 0xa, 0x12, 0x17, 0xff, 0xff

//Writes row $25C0 (15th row from top).
    //PPU memory high byte.
    byte: 0x25
    //PPU memory low byte.
    byte: 0xc4
    //PPU string length.
    byte: 0x1a
//             'T    H    E    _    M    E    C    H    A    N    I    C    A    L    _    L
    byte: 0x1d, 0x11, 0xe, 0xff, 0x16, 0xe, 0xc, 0x11, 0xa, 0x17, 0x12, 0xc, 0xa, 0x15, 0xff, 0x15
//           I    F    E    _    V    E    I    N    _    _'
    byte: 0x12, 0xf, 0xe, 0xff, 0x1f, 0xe, 0x12, 0x17, 0xff, 0xff

//Writes row $2620 (18th row from top).
    //PPU memory high byte.
    byte: 0x26
    //PPU memory low byte.
    byte: 0x27
    //PPU string length.
    byte: 0x15
//             'G    A    L    A    X    Y    _    F    E    D    E    R    A    L    _    P
    byte: 0x10, 0xa, 0x15, 0xa, 0x21, 0x22, 0xff, 0xf, 0xe, 0xd, 0xe, 0x1b, 0xa, 0x15, 0xff, 0x19
//           O    L    I    C    E'
    byte: 0x18, 0x15, 0x12, 0xc, 0xe

//Writes row $2660 (20th row from top).
    //PPU memory high byte.
    byte: 0x26
    //PPU memory low byte.
    byte: 0x69
    //PPU string length.
    byte: 0x12
//             '_    _    _    _    _    _    _    _    _    _    _    _    _    _    M    5
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0x5
//           1    0'
    byte: 0x1, 0x0

    //End PPU string write.
    byte: 0x0

//The following data does not appear to be used.
    byte: 0x46, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

//The following error message is diplayed if the player enters an incorrect password.
//             'E    R    R    O    R    _    T    R    Y    _    A    G    A    I    N'
    byte: 0xe, 0x1b, 0x1b, 0x18, 0x1b, 0xff, 0x1d, 0x1b, 0x22, 0xff, 0xa, 0x10, 0xa, 0x12, 0x17

//If the error message above is not being displayed on the password 
//screen, the following fifteen blanks spaces are used to cover it up.
//             '_    _    _    _    _    _    _    _    _    _    _    _    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

//Not used.
    byte: 0x79, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0
    byte: 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0
    byte: 0x0, 0x3, 0xa1, 0x87, 0xa2, 0x87, 0xa5, 0x87, 0xa8, 0x87, 0x0, 0x18, 0xcc, 0x0, 0x18, 0xcd
    byte: 0x0, 0x18, 0xce, 0x0

def loadsparkledata:

    x = 0xa
def _001A:
    a = [initsparkledatatbl:x]
    //Loads $6EA0 thru $6EAA with the table below.
    [introspr0ycoord:x] = a
    //Loads $6EB0 thru $6EBA with the table below.
    [introspr1ycoord:x] = a
    x--
    //Loop until all values from table below are loaded.
    goto _001A when ~negative
    a = 0x6b
    //$6EA0 thru $6EAA = #$3C, #$C6, #$01, #$18, #$00,-->
    [introspr1ycoord] = a
    //#$00, #$00, #$00, #$20, #$00, #$00, initial.
    a = 0xdc
    //$6EB0 thru $6EBA = #$6B, #$C6, #$01, #$DC, #$00,-->
    [introspr1xcoord] = a
    //#$00, #$00, #$00, #$20, #$00, #$00, initial.
    return

//Used by above routine to load Metroid initial sparkle data into $6EA0
//thru $6EAA and $6EB0 thru $6EBA.

def initsparkledatatbl:

    byte: 0x3c, 0xc6, 0x1, 0x18, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0

def updatesparklesprites:

    x = 0x0
    //($87D6)Performs calculations on top sparkle sprite.
    call doonesparkleupdate
    //Performs calculations on bottom sparkle sprite.
    x = 0x10

def doonesparkleupdate:

    //($87D9)Update sparkle sprite data.
    call sparkleupdate

def sparkleupdate:

    //If $6EA5 has not reached #$00, skip next routine.
    a = [introspr0nextcntr:x]
    goto _001B when ~zero
    //($881A)Update sparkle sprite screen position.
    call dosparklespritecoord
def _001B:
    a = [introspr0complete:x]
    //If sprite is already done, skip routine.
    goto _001D when ~zero
    [introspr0nextcntr:x]--

    a = [sparklespr0ychange:x]
    carry = 0
    //Updates sparkle sprite Y coord.
    a = a +# [introspr0ycoord:x]
    [introspr0ycoord:x] = a

    a = [sparklespr0xchange:x]
    carry = 0
    //Updates sparkle sprite X coord.
    a = a +# [introspr0xcoord:x]
    [introspr0xcoord:x] = a

    //Decrement IntroSpr0ChngCntr. If 0, time to change-->
    [introspr0chngcntr:x]--
    //sprite graphic.
    goto _001C when ~zero
    a = [introspr0patttbl:x]
    //If IntroSpr0ChngCntr=$00, the sparkle sprite graphic is-->
    a = a ^ 0x3
    //changed back and forth between pattern table-->
    [introspr0patttbl:x] = a
    //graphic $C6 and $C7.  IntroSpr0ChngCntr is reset to #$20.
    a = 0x20
    [introspr0chngcntr:x] = a
    a = a << 1
    //Flips pattern at $C5 in pattern table-->
    a = a ^ [introspr0cntrl:x]
    //horizontally when displayed.
    [introspr0cntrl:x] = a
def _001C:
    //($887B)Transfer sprite info into sprite RAM.
    goto writeintrosprite
def _001D:
    return

def dosparklespritecoord:

    a = x
    //($C2C0)Y=0 when working with top sparkle sprite-->
    call adiv8
    //and y=2 when working with bottom sparkle sprite.
    y = a
    //Base is $89AF.
    a = [sparkleaddresstbl:y]
    //When working with top sparkle sprite, E1,E0=$89B3-->
    [0x0] = a
    //and when botton sparkle sprite, E1,E0=$89E9.
    a = [sparkleaddresstbl+1:y]
    [0x1] = a
    //Loads index for finding sparkle data (x=$00 or $10).
    y = [introspr0index:x]
    a = [[0x0]:y]
    //If data byte MSB is set, set $6EA9 to #$01 and move to-->
    goto _001E when ~negative
    //next index for sparkle sprite data.
    a = 0x1
    [introspr0bytetype:x] = a
def _001E:
    goto _001F when ~zero
    //If value is equal to zero, sparkle sprite-->
    a = 0x1
    //processing is complete.
    [introspr0complete:x] = a
def _001F:
    [introspr0nextcntr:x] = a
    y++
    //Get x/y position byte.
    a = [[0x0]:y]
    //If MSB of second byte is set, branch.
    [introspr0bytetype:x]--
    goto _0020 when negative
    //This code is run when the MSB of the first byte-->
    a = 0x0
    //is set.  This allows the sprite to change X coord-->
    [sparklespr0ychange:x] = a
    //by more than 7.  Ensures Y coord does not change.
    a = [[0x0]:y]
    goto _0021 when negative
def _0020:
    //Store value twice so X and Y-->
    push a
    //coordinates can be extracted.
    push a
    a = 0x0
    //Set IntroSpr0ByteType to #$00 after processing.
    [introspr0bytetype:x] = a
    a = pop
    //($C2BF)Move upper 4 bits to lower 4 bits.
    call adiv16
    //($8871)Check if nibble to be converted to twos compliment.
    call nibblesubtract
    //Twos compliment stored if Y coord decreasing.
    [sparklespr0ychange:x] = a
    a = pop
    //Discard upper 4 bits.
    a = a & 0xf
    //($8871)Check if nibble to be converted to twos compliment.
    call nibblesubtract
def _0021:
    //Store amount to move spite in x direction.
    [sparklespr0xchange:x] = a
    [introspr0index:x]++
    //Add two to find index for next data byte.
    [introspr0index:x]++
    return

def nibblesubtract:

    //If bit 3 is set, nibble is a negative number-->
    compare a to 0x8
    //and lower three bits are converted to twos-->
    goto _0022 when ~carry
    //compliment for subtraction, else exit.
    a = a & 0x7
    //($C3D4)Prepare for subtraction with twos compliment.
    call twoscompliment
def _0022:
    return

def writeintrosprite:

    a = [introspr0ycoord:x]
    //Subtract #$01 from first byte to get proper y coordinate.
    carry = 1
    a = a -# 0x1
    [sprite04ram:x] = a
    a = [introspr0patttbl:x]
    //Load the four bytes for the-->
    [sprite04ram+1:x] = a
    //intro sprites into sprite RAM.
    a = [introspr0cntrl:x]
    [sprite04ram+2:x] = a
    a = [introspr0xcoord:x]
    [sprite04ram+3:x] = a
    return
 
def loadinitialspritedata:

    a = 0x20
    //Set delay for second 4 sprites to 32 frames.
    [second4delay] = a
    //Prepare to loop 64 times.
    x = 0x3f

def _0023:
    //Load data from tables below.
    a = [sprite0and4inittbl:x]
    //If #$FF, skip loading that byte and move to next item.
    compare a to [0xff]
    goto _0024 when zero
    //Store initial values for sprites 0 thru 3.
    [introspr0ycoord:x] = a
    //Store initial values for sprites 4 thru 7.
    [introspr4ycoord:x] = a
def _0024:
    x--
    //Loop until all data is loaded.
    goto _0023 when ~negative

    //Special case for sprite 6 and 7.
    a = 0xb8
    [introspr6ycoord] = a
    //Change sprite 6 and 7 initial y position.
    [introspr7ycoord] = a
    a = 0x16
    //Change sprite 6 and 7 y displacement. The combination-->
    [introspr6yrise] = a
    //of these two changes the slope of the sprite movement.
    [introspr7yrise] = a
    return
 
//The following tables are loaded into RAM as initial sprite control values for the crosshair sprites.

def sprite0and4inittbl:

    //Initial starting y screen position.
    byte: 0x20
    //Sprite pattern table index.
    byte: 0xc5
    //Sprite control byte.
    byte: 0x80
    //Initial starting x screen position.
    byte: 0x0
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Intro sprite x total movement distance.
    byte: 0x74
    //Intro sprite y total movement distance.
    byte: 0x58
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Sprite task complete idicator.
    byte: 0x0
    //Not used.
    byte: 0xff
    //x displacement of sprite movement(run).
    byte: 0x1d
    //y displacement of sprite movement(rise).
    byte: 0xe
    //Change sprite x coord in positive direction.
    byte: 0x1
    //Change sprite y coord in positive direction.
    byte: 0x1

def sprite1and5inittbl:

    //Initial starting y screen position.
    byte: 0x20
    //Sprite pattern table index.
    byte: 0xc5
    //Sprite control byte.
    byte: 0xc0
    //Initial starting x screen position.
    byte: 0xf8
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Intro sprite x total movement distance.
    byte: 0x7c
    //Intro sprite y total movement distance.
    byte: 0x58
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Sprite task complete idicator.
    byte: 0x0
    //Not used.
    byte: 0xff
    //x displacement of sprite movement(run).
    byte: 0x1f
    //y displacement of sprite movement(rise).
    byte: 0xe
    //Change sprite x coord in negative direction.
    byte: 0x80
    //Change sprite y coord in positive direction.
    byte: 0x1

def sprite2and6inittbl:

    //Initial starting y screen position.
    byte: 0xc8
    //Sprite pattern table index.
    byte: 0xc5
    //Sprite control byte.
    byte: 0x0
    //Initial starting x screen position.
    byte: 0x0
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Intro sprite x total movement distance.
    byte: 0x74
    //Intro sprite y total movement distance.
    byte: 0x60
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Sprite task complete idicator.
    byte: 0x0
    //Not used.
    byte: 0xff
    //x displacement of sprite movement(run).
    byte: 0x1d
    //y displacement of sprite movement(rise).
    byte: 0x1a
    //Change sprite x coord in positive direction.
    byte: 0x1
    //Change sprite y coord in negative direction.
    byte: 0x80

def sprite3and7inittbl:

    //Initial starting y screen position.
    byte: 0xc8
    //Sprite pattern table index.
    byte: 0xc5
    //Sprite control byte.
    byte: 0x40
    //Initial starting x screen position.
    byte: 0xf8
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Intro sprite x total movement distance.
    byte: 0x7c
    //Intro sprite y total movement distance.
    byte: 0x60
    //Not used.
    byte: 0xff
    //Not used.
    byte: 0xff
    //Sprite task complete idicator.
    byte: 0x0
    //Not used.
    byte: 0xff
    //x displacement of sprite movement(run).
    byte: 0x1f
    //y displacement of sprite movement(rise).
    byte: 0x1a
    //Change sprite x coord in negative direction.
    byte: 0x80
    //Change sprite y coord in negative direction.
    byte: 0x80

def drawcrosshairssprites:

    a = [first4slowcntr]
    //Has First4SlowCntr already hit 0? If so, branch.
    goto _0025 when zero
    [first4slowcntr]--
    //Is First4SlowCntr now equal to 0? if not, branch.
    goto _0025 when ~zero
    [introspr0xrun] = [introspr0xrun] << 1
    [introspr0yrise] = [introspr0yrise] << 1
    [introspr1xrun] = [introspr1xrun] << 1
    [introspr1yrise] = [introspr1yrise] << 1
    [introspr2xrun] = [introspr2xrun] << 1
    [introspr2yrise] = [introspr2yrise] << 1
    //Multiply the rise and run of the 8 sprites by 2.-->
    [introspr3xrun] = [introspr3xrun] << 1
    //This doubles their speed.
    [introspr3yrise] = [introspr3yrise] << 1
    [introspr4xrun] = [introspr4xrun] << 1
    [introspr4yrise] = [introspr4yrise] << 1
    [introspr5xrun] = [introspr5xrun] << 1
    [introspr5yrise] = [introspr5yrise] << 1
    [introspr6xrun] = [introspr6xrun] << 1
    [introspr6yrise] = [introspr6yrise] << 1
    [introspr7xrun] = [introspr7xrun] << 1
    [introspr7yrise] = [introspr7yrise] << 1
def _0025:
    x = 0x0
    //($8963)Move sprite 0.
    call dospritemovement
    x = 0x10
    //($8963)Move sprite 1.
    call dospritemovement
    x = 0x20
    //($8963)Move sprite 2.
    call dospritemovement
    x = 0x30
    //Check to see if the delay to start movement of the second-->
    a = [second4delay]
    //4 sprites has ended.  If so, start drawing those sprites.
    goto _0026 when zero
    [second4delay]--
    goto _0027 when ~zero
def _0026:
    //($8963)Move sprite 3.
    call dospritemovement
    x = 0x40
    //($8963)Move sprite 4.
    call dospritemovement
    x = 0x50
    //($8963)Move sprite 5.
    call dospritemovement
    x = 0x60
    //($8963)Move sprite 6.
    call dospritemovement
    //($8963)Move sprite 7.
    x = 0x70

def dospritemovement:

def _0027:
    //If the current sprite has finished-->
    a = [introspr0complete:x]
    //its movements, exit this routine.
    goto _0029 when ~zero
    //($981E)Calculate new sprite position.
    call updatespritecoords
    //If sprite not at final position, branch to move next frame.
    goto _0028 when carry
    //Sprite movement complete.
    a = 0x1
    [introspr0complete:x] = a
def _0028:
    //($887B)Write sprite data to sprite RAM.
    goto writeintrosprite
def _0029:
    return

def drawcrosssprites:

    //If not ready to draw crosshairs,-->
    a = [drawcross]
    //branch to exit.
    goto _002D when zero
    y = [crossdataindex]
    //Check to see if at last index in table.  If so, branch-->
    compare y to 0x4
    //to draw cross sprites.
    goto _002A when ~carry
    //If beyond last index, branch to exit.
    goto _002D when ~zero
    a = 0x0
    //If at last index, clear indicaor to draw cross sprites.
    [drawcross] = a
def _002A:
    a = [crossspriteindextbl:y]
    [0x0] = a
    //Reset index into CrossSpriteDataTbl
    y = 0x0

def _002B:
    //Get offet into sprite RAM to load sprite.
    x = [crossspritedatatbl:y]
    y++
def _002C:
    //Get sprite data byte.
    a = [crossspritedatatbl:y]
    //Store byte in sprite RAM.
    [sprite00ram:x] = a
    //Move to next sprite RAM address.
    x++
    //Move to next data byte in table.
    y++
    a = x
    //Is new sprite position reached?-->
    a = a & 0x3
    //if not, branch to load next sprite data byte.
    goto _002C when ~zero
    //Has all the sprites been loaded for cross graphic?-->
    compare y to [0x0]
    //If not, branch to load next set of sprite data.
    goto _002B when ~zero

    a = [framecount]
    //Increment index into CrossSpriteIndexTbl every-->
    a = a >> 1
    //other frame.  This updates the cross sprites-->
    goto _002D when ~carry
    //every two frames.
    [crossdataindex]++
def _002D:
    return

//The following table tells the routine above how many data bytes to load from CrossSpriteDataTbl.
//The more data that is loaded, the bigger the cross that is drawn on the screen.  The table below
//starts the cross out small, it then grows bigger and gets small again.

def crossspriteindextbl:

    byte: 0x5, 0x19, 0x41, 0x19, 0x5

//The following table is used to find the data for the sparkle routine in the table below:

def sparkleaddresstbl:

    //($89B3)Table for top sparkle data.
    word: topsparkledatatbl
    //($89E9)Table for bottom sparkle data.
    word: bottomsparkledatatbl

//The following two tables are the data tables for controlling the movement of the sparkle sprites
//in the title routine.  Here's how thw data in the tables work: The first byte is a counter byte.
//It is loaded into a memory address and decremented every frame. Whilt that value is not 0, the
//second byte is used to change the sprite's x and y coordinates in the screen.  The upper 4 bits
//of the second byte are amount to change the y coordinates every frame.  If bit 7 is set, the
//y coordinates of the sprite are reduced every frame by the amount stored in bits 4,5 and 6. The
//lower 4 bits of the second byte are used to change the x coordinates of the sprite in the same
//manner.  If bit 3 is set, the x coordinates of the sprite are reduced every frame by the amount
//stored in bits 0, 1 and 2.
//Special case: If MSB of the first byte is set(in the case of this data, the first byte is #$FF),
//The counter byte is set to only 1 frame and the second byte contains only x coordinates to move
//the sprite.  The y coordinates do not change.  This allows 8 bytes to move the x coordinate
//instead of only 4.  This allows the sprite to "jump" across the edges of the letters. If the MSB
//of the second byte is set, the x coordinate of the sprite is decreased by the amount stored in
//the other seven bytes.

def topsparkledatatbl:

    byte: 0x1, 0x0
    byte: 0x1, 0x0
    byte: 0x1, 0x1
    byte: 0x6, 0x0
    byte: 0x7, 0x1
    byte: 0x10, 0x1
    byte: 0x3, 0x1
    byte: 0x1, 0x0
    byte: 0x1, 0x1
    byte: 0x1, 0x0
    byte: 0x1, 0x1
    byte: 0x1, 0x0
    byte: 0x9, 0x1
    byte: 0x4, 0x0
    byte: 0x27, 0x1
    byte: 0x1, 0x0
    byte: 0x1, 0x0
    byte: 0x6, 0x1
    byte: 0x1, 0x0
    byte: 0x15, 0x1
    byte: 0x6, 0x0
    byte: 0x1, 0x1
    byte: 0x8, 0x1
    byte: 0xe, 0x2
    byte: 0x2, 0x3
    byte: 0x6, 0x4
    byte: 0x0, 0x0

def bottomsparkledatatbl:

    byte: 0x1, 0x0
    byte: 0x8, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x9
    byte: 0x1, 0x99
    byte: 0x1, 0x19
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x1, 0x10
    byte: 0x2, 0x11
    byte: 0x1, 0x10
    byte: 0x1, 0x11
    byte: 0x10, 0x9
    //MSB of first byte set. move sprite x pos -17 pixles.
    byte: 0xff, 0xef
    byte: 0x11, 0x9
    //MSB of first byte set. move sprite x pos -13 pixles.
    byte: 0xff, 0xf3
    byte: 0x1f, 0x9
    //MSB of first byte set. move sprite x pos -20 pixles.
    byte: 0xff, 0xec
    byte: 0xf, 0x9
    //MSB of first byte set. move sprite x pos -19 pixles.
    byte: 0xff, 0xed
    byte: 0x16, 0x9
    byte: 0x0, 0x0

//The following table is used by the DrawCrossSprites routine to draw the sprites on the screen that
//make up the cross that appears during the Crosshairs routine.  The single byte is the index into
//the sprite RAM where the sprite data is to be written.  The 4 bytes that follow it are the actual
//sprite data bytes.

def crossspritedatatbl:

    //Load following sprite data into Sprite04RAM.
    byte: 0x10
    //Sprite data.
    byte: 0x5a, 0xc0, 0x0, 0x79
    //Load following sprite data into Sprite05RAM.
    byte: 0x14
    //Sprite data.
    byte: 0x52, 0xc8, 0x0, 0x79
    //Load following sprite data into Sprite06RAM.
    byte: 0x18
    //Sprite data.
    byte: 0x5a, 0xc2, 0x40, 0x71
    //Load following sprite data into Sprite07RAM.
    byte: 0x1c
    //Sprite data.
    byte: 0x5a, 0xc2, 0x0, 0x81
    //Load following sprite data into Sprite08RAM.
    byte: 0x20
    //Sprite data.
    byte: 0x62, 0xc8, 0x80, 0x79
    //Load following sprite data into Sprite05RAM.
    byte: 0x14
    //Sprite data.
    byte: 0x52, 0xc9, 0x0, 0x79
    //Load following sprite data into Sprite06RAM.
    byte: 0x18
    //Sprite data.
    byte: 0x5a, 0xc1, 0x0, 0x71
    //Load following sprite data into Sprite07RAM.
    byte: 0x1c
    //Sprite data.
    byte: 0x5a, 0xc1, 0x0, 0x81
    //Load following sprite data into Sprite08RAM.
    byte: 0x20
    //Sprite data.
    byte: 0x62, 0xc9, 0x0, 0x79
    //Load following sprite data into Sprite09RAM.
    byte: 0x24
    //Sprite data.
    byte: 0x4a, 0xc8, 0x0, 0x79
    //Load following sprite data into Sprite0ARAM.
    byte: 0x28
    //Sprite data.
    byte: 0x5a, 0xc2, 0x40, 0x69
    //Load following sprite data into Sprite0BRAM.
    byte: 0x2c
    //Sprite data.
    byte: 0x5a, 0xc2, 0x0, 0x89
    //Load following sprite data into Sprite0CRAM.
    byte: 0x30
    //Sprite data.
    byte: 0x6a, 0xc8, 0x80, 0x79

def loadpaldata:

    y = [paldataindex]
    //Chooses which set of palette data-->
    a = [palselecttbl:y]
    //to load from the table below.
    compare a to 0xff
    goto _002E when zero
    //Prepare to write palette data.
    [video.palette_pending] = a
    [paldataindex]++
def _002E:
    return

//The table below is used by above routine to pick the proper palette.

def palselecttbl:

    byte: 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xc, 0xff

def flashintroscreen:

    //Load index into table below.
    y = [screenflashpalindex]
    //Load palette data byte.
    a = [screenflashpaltbl:y]
    //Has the end of the table been reached?-->
    compare a to 0xff
    //If not, branch.
    goto _002F when ~zero
    a = 0x0
    //Clear screen flash palette index and reset-->
    [screenflashpalindex] = a
    //screen flash control address.
    [flashscreen] = a
    //Branch always.
    goto _0030 when zero
def _002F:
    //Store palette change data.
    [video.palette_pending] = a
    //Increment index into table below.
    [screenflashpalindex]++
def _0030:
    return

def screenflashpaltbl:

    byte: 0x11, 0x1, 0x11, 0x1, 0x11, 0x11, 0x1, 0x11, 0x1, 0xff

//----------------------------------[ Intro star palette routines ]-----------------------------------

def starpalswitch:

    a = [framecount]
    //Change star palette every 16th frame.
    a = a & 0xf
    goto _0031 when ~zero
    a = [ppustrindex]
    //Is any other PPU data waiting? If so, exit.
    goto _0032 when zero
def _0031:
    return

def _0032:
    a = 0x19
    //Prepare to write to the sprite palette-->
    [0x0] = a
    //starting at address $3F19.
    a = 0x3f
    [0x1] = a
    //Use only first 3 bits of byte since the pointer-->
    a = [introstaroffset]
    //table only has 8 entries.
    a = a & 0x7
    //*2 to find entry in IntroStarPntr table.
    a = a << 1
    y = a
    //Stores starting address of palette data to write-->
    a = [introstarpntr:y]
    //into $02 and $03 from IntroStarPntr table.
    [0x2] = a
    a = [introstarpntr+1:y]
    [0x3] = a
    //Increment index for next palette change.
    [introstaroffset]++
    //($C37E)Prepare and write new palette data.
    call prepppupalettestring
    a = 0x1d
    [0x0] = a
    //Prepare another write to the sprite palette.-->
    a = 0x3f
    //This tie starting at address $3F1D.
    [0x1] = a
    y++
    //($C2B3)Find new data base of palette data.
    call addytoptr02
    //($C37E)Prepare and write new palette data.
    goto prepppupalettestring

//The following table is a list of pointers into the table below. It contains
//the palette data for the twinkling stars in the intro scene.  The palette data
//is changed every 16 frames by the above routine.

def introstarpntr:

    word: title_page_8B0F, 0x8b19, 0x8b23, 0x8b2d, 0x8b37, 0x8b41, 0x8b4b, 0x8b55

//The following table contains the platette data that is changed in the intro
//scene to give the stars a twinkling effect. All entries in the table are
//non-repeating. 

def introstarpal:

def title_page_8B0F:
    byte: 0x3, 0xf, 0x2, 0x13, 0x0, 0x3, 0x0, 0x34, 0xf, 0x0
    byte: 0x3, 0x6, 0x1, 0x23, 0x0, 0x3, 0xf, 0x34, 0x9, 0x0
    byte: 0x3, 0x16, 0xf, 0x23, 0x0, 0x3, 0xf, 0x24, 0x1a, 0x0
    byte: 0x3, 0x17, 0xf, 0x13, 0x0, 0x3, 0x0, 0x4, 0x28, 0x0
    byte: 0x3, 0x17, 0x1, 0x14, 0x0, 0x3, 0x10, 0xf, 0x28, 0x0
    byte: 0x3, 0x16, 0x2, 0xf, 0x0, 0x3, 0x30, 0xf, 0x1a, 0x0
    byte: 0x3, 0x6, 0x12, 0xf, 0x0, 0x3, 0x30, 0x4, 0x9, 0x0
    byte: 0x3, 0xf, 0x12, 0x14, 0x0, 0x3, 0x10, 0x24, 0xf, 0x0

//----------------------------------------------------------------------------------------------------

def dofadeout:

    //Load palette data from table below.
    y = [fadedataindex]
    a = [fadeoutpaldata:y]
    //If palette data = #$FF, exit.
    compare a to 0xff
    goto _0033 when zero
    //Store new palette data.
    [video.palette_pending] = a
    [fadedataindex]++
def _0033:
    return

def fadeoutpaldata:

    byte: 0xd, 0xe, 0xf, 0x10, 0x1, 0xff

def fadeinpaldata:

    byte: 0x1, 0x10, 0xf, 0xe, 0xd, 0xff

//----------------------------------------[ Password routines ]---------------------------------------

def processuniqueitems:

    a = [numberofuniqueitems]
    //Store NumberOfUniqueItems at $03.
    [0x3] = a
    y = 0x0
    //Set $04 to #$00.
    [0x4] = y
def _0034:
    //Use $04 at index into unique itme list.
    y = [0x4]
    y++
    a = [uniqueitemhistory-1:y]
    //Load the two bytes representing the aquired-->
    [0x0] = a
    //Unique item and store them in $00 and $01.
    y++
    a = [uniqueitemhistory-1:y]
    [0x1] = a
    //Increment $04 by two (load unique item complete).
    [0x4] = y
    //($8B9C)Find unique item.
    call uniqueitemsearch
    y = [0x4]
    //If all unique items processed, return, else-->
    compare y to [0x3]
    //branch to process next unique item.
    goto _0034 when ~carry
    return

def uniqueitemsearch:

    x = 0x0
def _0035:
    //Transfer X to A(Item number).
    a = x
    //Multiply by 2.
    a = a << 1
    //Store multiplied value in y.
    y = a
    //Load unique item reference starting at $9029(2 bytes).
    a = [itemdata:y]
    compare a to [0x0]
    goto _0036 when ~zero
    //Get next byte of unique item.
    a = [itemdata+1:y]
    compare a to [0x1]
    //If unique item found, branch to UniqueItemFound.
    goto _0037 when zero
def _0036:
    x++
    //If the unque item is a Zeebetite, return-->
    compare x to 0x3c
    //else branch to find next unique item.
    goto _0035 when ~carry
    return

//The following routine sets the item bits for aquired items in addresses $6988 thru $698E.-->
//Items 1 thru 7 masked in $6988, 8 thru 15 in $6989, etc.

def uniqueitemfound:

def _0037:
    a = x
    //($C2C0)Divide by 8.
    call adiv8
    //Shifts 5 MSBs to LSBs of item # and saves results in $05.
    [0x5] = a
    //($C2C6)Multiply by 8.
    call amul8
    //Restores 5 MSBs of item # and drops 3 LSBs// saves in $02.
    [0x2] = a
    a = x
    carry = 1
    a = a -# [0x2]
    //Remove 5 MSBs and stores 3 LSBs in $06.
    [0x6] = a
    x = [0x5]
    a = [passwordbyte00:x]
    y = [0x6]
    a = a | [passwordbitmasktbl:y]
    //Masks each unique item in the proper item address-->
    [passwordbyte00:x] = a
    //(addresses $6988 thru $698E).
    return
 
def loaduniqueitems:

    a = 0x0
    [numberofuniqueitems] = a
    //$05 offset of password byte currently processing(0 thru 7).
    [0x5] = a
    //$06 bit of password byte currently processing(0 thru 7).
    [0x6] = a
    a = 0x3b
    //Maximum number of unique items(59 or #$3B).
    [0x7] = a
    y = [0x5]
    a = [passwordbyte00:y]
    //$08 stores contents of password byte currently processing.
    [0x8] = a
    x = 0x0
    //Stores number of unique items processed(#$0 thru #$3B).
    [0x9] = x
    x = [0x6]
    //If start of new byte, branch.
    goto _0039 when zero

    x = 0x1
    [0x2] = x
    carry = 0
def _0038:
    a = a >>> 1
    //This code does not appear to ever be executed.
    [0x8] = a
    x = [0x2]
    compare x to [0x6]
    goto _0039 when zero
    [0x2]++
    goto _0038

def processnextitem:

    //Locates next password byte to process-->
    y = [0x5]
    //and loads it into $08.
    a = [passwordbyte00:y]
    [0x8] = a

def processnewitembyte:

def _0039:
    a = [0x8]
    //Rotates next bit to be processed to the carry flag.
    a = a >>> 1
    [0x8] = a
    goto _003A when ~carry
    //($8C39)Store item in unique item history.
    call samushasitem
def _003A:
    //If last bit of item byte has been-->
    y = [0x6]
    //checked, move to next byte.
    compare y to 0x7
    goto _003B when carry
    [0x6]++
    [0x9]++
    //If all 59 unique items have been-->
    x = [0x9]
    //searched through, exit.
    compare x to [0x7]
    goto _003C when carry
    //($8C0A)Repeat routine for next item byte.
    goto processnewitembyte
def _003B:
    y = 0x0
    [0x6] = y
    [0x5]++
    [0x9]++
    //If all 59 unique items have been-->
    x = [0x9]
    //searched through, exit.
    compare x to [0x7]
    goto _003C when carry
    //($8C03)Process next item.
    goto processnextitem
def _003C:
    return
 
def samushasitem:

    //$05 becomes the upper part of the item offset-->
    a = [0x5]
    //while $06 becomes the lower part of the item offset.
    call amul8
    carry = 0
    a = a +# [0x6]
    //* 2. Each item is two bytes in length.
    a = a << 1
    y = a
    a = [itemdata+1:y]
    //$00 and $01 store the two bytes of-->
    [0x1] = a
    //the unique item to process.
    a = [itemdata:y]
    [0x0] = a
    y = [numberofuniqueitems]
    //Store the two bytes of the unique item-->
    [uniqueitemhistory:y] = a
    //in RAM in the unique item history.
    a = [0x1]
    y++
    [uniqueitemhistory:y] = a
    y++
    //Keeps a running total of unique items.
    [numberofuniqueitems] = y
    return

def checkpassword:

    //($8F60)Convert password characters to password bytes.
    call consolidatepassword
    //($8DDE)Verify password is correct.
    call validatepassword
    //Branch if incorrect password.
    goto _003D when carry
    //($92D4)Preliminary housekeeping before game starts.
    goto initializegame
def _003D:
    a = [multisfxflag]
    //Set IncorrectPassword SFX flag.
    a = a | 0x1
    [multisfxflag] = a
    a = 0xc
    //Set Timer3 time for 120 frames (2 seconds).
    [timer3] = a
    a = 0x18
    //Run EnterPassword routine.
    [titleroutine] = a
    return

def calculatepassword:

    a = 0x0
    //Clears values at addresses -->
    y = 0xf
def _003E:
    //$6988 thru $6997 and -->
    [passwordbyte00:y] = a
    //$699A thru $69A9.
    [passwordchar00:y] = a
    y--
    goto _003E when ~negative
    //($8B79)Determine what items Samus has collected.
    call processuniqueitems
    a = [passwordbyte07]
    //Check to see if mother brain has been defeated,-->
    a = a & 0x4
    //If so, restore mother brain, zeebetites and-->
    goto _003F when zero
    //all missile doors in Tourian as punishment for-->
    a = 0x0
    //dying after mother brain defeated. Only reset in the-->
    [passwordbyte07] = a
    //password.  Continuing without resetting will not-->
    a = [passwordbyte06]
    //restore those items.
    a = a & 0x3
    [passwordbyte06] = a
def _003F:
    //Store InArea in bits 0 thru 5 in-->
    a = [inarea]
    //address $6990.
    a = a & 0x3f
    y = [justinbailey]
    goto _0040 when zero
    //Sets MSB of $6990 is Samus is suitless.
    a = a | 0x80
def _0040:
    [passwordbyte08] = a
    a = [samusgear]
    //SamusGear stored in $6991.
    [passwordbyte09] = a
    a = [missilecount]
    //MissileCount stored in $6992.
    [passwordbyte0a] = a
    a = 0x0
    [0x0] = a
    a = [kraidstatuestatus]
    a = a & 0x80
    //If statue not up, branch.
    goto _0041 when zero
    a = [0x0]
    //Set bit 7 of $00-->
    a = a | 0x80
    //if Kraid statue up.
    [0x0] = a
def _0041:
    a = [kraidstatuestatus]
    a = a & 0x1
    //Branch if Kraid not yet defeated.
    goto _0042 when zero
    a = [0x0]
    //Set bit 6 of $00-->
    a = a | 0x40
    //If Kraid defeated.
    [0x0] = a
def _0042:
    a = [ridleystatuestatus]
    a = a & 0x80
    //Branch if Ridley statue not up.
    goto _0043 when zero
    a = [0x0]
    //Set bit 5 of $00-->
    a = a | 0x20
    //if Ridley statue up.
    [0x0] = a
def _0043:
    a = [ridleystatuestatus]
    a = a & 0x2
    //Branch if Ridley not yet defeated.
    goto _0044 when zero
    a = [0x0]
    //Set bit 4 of $00-->
    a = a | 0x10
    //if Ridley defeated.
    [0x0] = a
def _0044:
    a = [0x0]
    //Stores statue statuses in 4 MSB at $6997.
    [passwordbyte0f] = a
    y = 0x3
def _0045:
    //Store SamusAge in $6993,-->
    a = [samusage:y]
    //SamusAge+1 in $6994 and-->
    [passwordbyte0b:y] = a
    //SamusAe+2 in $6995.
    y--
    goto _0045 when ~negative
def _0046:
    call 0xc000
    a = [randomnumber1]
    //Store the value of $2E at $6998-->
    a = a & 0xf
    //When any of the 4 LSB are set. (Does not-->
    goto _0046 when zero
    //allow RandomNumber1 to be a multiple of 16).
    [passwordbyte10] = a
    //($8E17)Calculate checksum and scramble password.
    call passwordchecksumandscramble
    //($8E6C)Calculate password characters.
    goto loadpasswordchar

def loadpassworddata:

    //If invincible Samus active, skip-->
    a = [narpassword]
    //further password processing.
    goto _0049 when ~zero
    //($8BD4)Load unique items from password.
    call loaduniqueitems
    //($8D3D)Calculate number of missiles from password.
    call loadtanksandmissiles
    y = 0x0
    //If MSB in PasswordByte08 is set,-->
    a = [passwordbyte08]
    //Samus is not wearing her suit.
    a = a & 0x80
    goto _0047 when zero
    y++
def _0047:
    [justinbailey] = y
    //Extract first 5 bits from PasswordByte08-->
    a = [passwordbyte08]
    //and use it to determine starting area.
    a = a & 0x3f
    [inarea] = a
    y = 0x3
def _0048:
    //Load Samus' age.
    a = [passwordbyte0b:y]
    [samusage:y] = a
    y--
    //Loop to load all 3 age bytes.
    goto _0048 when ~negative
def _0049:
    return
 
def loadtanksandmissiles:

    //Loads Samus gear.
    a = [passwordbyte09]
    //Save Samus gear.
    [samusgear] = a
    //Loads current number of missiles.
    a = [passwordbyte0a]
    //Save missile count.
    [missilecount] = a
    a = 0x0
    [0x0] = a
    [0x2] = a
    a = [passwordbyte0f]
    //If MSB is set, Kraid statue is up.
    a = a & 0x80
    goto _004A when zero
    a = [0x0]
    //If Kraid statue is up, set MSB in $00.
    a = a | 0x80
    [0x0] = a
def _004A:
    a = [passwordbyte0f]
    //If bit 6 is set, Kraid is defeated.
    a = a & 0x40
    goto _004B when zero
    a = [0x0]
    //If Kraid is defeated, set LSB in $00.
    a = a | 0x1
    [0x0] = a
def _004B:
    a = [0x0]
    //Store Kraid status.
    [kraidstatuestatus] = a
    a = [passwordbyte0f]
    //If bit 5 is set, Ridley statue is up.
    a = a & 0x20
    goto _004C when zero
    a = [0x2]
    //If Ridley statue is up, set MSB in $02.
    a = a | 0x80
    [0x2] = a
def _004C:
    a = [passwordbyte0f]
    //If bit 4 is set, Ridley is defeated.
    a = a & 0x10
    goto _004D when zero
    a = [0x2]
    //If Ridley is defeated, set bit 1 of $02.
    a = a | 0x2
    [0x2] = a
def _004D:
    a = [0x2]
    //Store Ridley status.
    [ridleystatuestatus] = a
    a = 0x0
    [0x0] = a
    [0x2] = a
    y = 0x0
def _004E:
    //Load second byte of item and compare-->
    a = [uniqueitemhistory+1:y]
    //the 6 MSBs to #$20. If it matches,-->
    a = a & 0xfc
    //an energy tank has been found.
    compare a to 0x20
    goto _004F when ~zero
    //Increment number of energy tanks found.
    [0x0]++
    goto incrementtonextitem
def _004F:
    //Load second byte of item and compare the 6 MSBs to-->
    compare a to 0x24
    //#$24. If it matches, missiles have been found.
    goto _0050 when ~zero
    //Increment number of missiles found.
    [0x2]++

def incrementtonextitem:

def _0050:
    y++
    //Increment twice. Each item is 2 bytes.
    y++
    //7 extra item slots in unique item history.
    compare y to 0x84
    //Loop until all unique item history checked.
    goto _004E when ~carry
    a = [0x0]
    //Ensure the Tank Count does not exceed 6-->
    compare a to 0x6
    //tanks. Then stores the number of-->
    goto _0051 when ~carry
    //energy tanks found in TankCount.
    a = 0x6
def _0051:
    [tankcount] = a
    a = 0x0
    y = [0x2]
    //Branch if no missiles found.
    goto _0053 when zero
    carry = 0
def _0052:
    a = a +# 0x5
    //For every missile item found, this-->
    y--
    //loop adds 5 missiles to MaxMissiles.
    goto _0052 when ~zero
def _0053:
    y = [kraidstatuestatus]
    goto _0054 when zero
    //75 missiles are added to MaxMissiles-->
    a = a +# 0x4b
    //if Kraid has been defeated and another-->
    goto _0055 when carry
def _0054:
    //75 missiles are added if the ridley-->
    y = [ridleystatuestatus]
    //has been defeated.
    goto _0056 when zero
    a = a +# 0x4b
    goto _0056 when ~carry
def _0055:
    //If number of missiles exceeds 255, it stays at 255.
    a = 0xff
def _0056:
    [maxmissiles] = a
    return

def validatepassword:

    a = [narpassword]
    //If invincible Samus already active, branch.
    goto _0058 when ~zero
    y = 0xf
def _0057:
    a = [passwordchar00:y]
    //If NARPASSWORD was entered at the-->
    compare a to [narpasswordtbl:y]
    //password screen, activate invincible-->
    goto _0058 when ~zero
    //Samus, else continue to process password.
    y--
    goto _0057 when ~negative
    a = 0x1
    [narpassword] = a
    goto _0059 when ~zero
def _0058:
    //($8E4E)Unscramble password.
    call unscramblepassword
    //($8E21)Calculate password checksum.
    call passwordchecksum
    //Verify proper checksum.
    compare a to [passwordbyte11]
    goto _0059 when zero
    //If password is invalid, sets carry flag.
    carry = 1
    goto _005A when carry
def _0059:
    //If password is valid, clears carry flag.
    carry = 0
def _005A:
    return

//The table below is used by the code above. It checks to see if NARPASSWORD has been entered.
//NOTE: any characters after the 16th character will be ignored if the first 16 characters
//match the values below.

def narpasswordtbl:

    //N
    byte: 0x17
    //A
    byte: 0xa
    //R
    byte: 0x1b
    //P
    byte: 0x19
    //A
    byte: 0xa
    //S
    byte: 0x1c
    //S
    byte: 0x1c
    //W
    byte: 0x20
    //O
    byte: 0x18
    //R
    byte: 0x1b
    //D
    byte: 0xd
    //0(or no entry).
    byte: 0x0
    //0(or no entry).
    byte: 0x0
    //0(or no entry).
    byte: 0x0
    //0(or no entry).
    byte: 0x0
    //0(or no entry).
    byte: 0x0

def passwordchecksumandscramble:

    //($8E21)Store the combined added value of-->
    call passwordchecksum
    //addresses $6988 thu $6998 in $6999.
    [passwordbyte11] = a
    //($8E2D)Scramble password.
    call passwordscramble
    return
 
def passwordchecksum:

    y = 0x10
    a = 0x0
def _005B:
    //Add the values at addresses-->
    carry = 0
    //$6988 thru $6998 together.
    a = a +# [passwordbyte00:y]
    y--
    goto _005B when ~negative
    return
 
def passwordscramble:

    a = [passwordbyte10]
    [0x2] = a
def _005C:
    //Store contents of $6988 in $00 for-->
    a = [passwordbyte00]
    //further processing after rotation.
    [0x0] = a
    x = 0x0
    y = 0xf
def _005D:
    //Rotate right, including carry, all values in-->
    [passwordbyte00:x] = [passwordbyte00:x] >>> 1
    //addresses $6988 thru $6997.
    x++
    y--
    goto _005D when ~negative
    //Rotate right $6988 to ensure the LSB-->
    [0x0] = [0x0] >>> 1
    //from address $6997 is rotated to the-->
    a = [0x0]
    //MSB of $6988.
    [passwordbyte00] = a
    [0x2]--
    //Continue rotating until $02 = 0.
    goto _005C when ~zero
    return

def unscramblepassword:

    //Stores random number used to scramble the password.
    a = [passwordbyte10]
    [0x2] = a
def _005E:
    //Preserve MSB that may have been rolled from $6988.
    a = [passwordbyte0f]
    [0x0] = a
    x = 0xf
def _005F:
    //The following loop rolls left the first 16 bytes-->
    [passwordbyte00:x] = [passwordbyte00:x] <<< 1
    //of the password one time.
    x--
    goto _005F when ~negative
    //Rolls byte in $6997 to ensure MSB from $6988 is not lost.
    [0x0] = [0x0] <<< 1
    a = [0x0]
    [passwordbyte0f] = a
    [0x2]--
    //Loop repeats the number of times decided by the random-->
    goto _005E when ~zero
    //number in $6998 to properly unscramble the password.
    return

//The following code takes the 18 password bytes and converts them into 24 characters
//to be displayed to the player as the password.  NOTE: the two MSBs will always be 0.

def loadpasswordchar:

    //Password byte #$00.
    y = 0x0
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar00] = a
    //Password bytes #$00 and #$01.
    y = 0x0
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar01] = a
    //Password bytes #$01 and #$02.
    y = 0x1
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar02] = a
    //Password byte #$02.
    y = 0x2
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar03] = a
    //Password byte #$03.
    y = 0x3
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar04] = a
    //Password bytes #$03 and #$04.
    y = 0x3
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar05] = a
    //Password bytes #$04 and #$05.
    y = 0x4
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar06] = a
    //Password byte #$05.
    y = 0x5
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar07] = a
    //Password byte #$06.
    y = 0x6
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar08] = a
    //Password bytes #$06 and #$07.
    y = 0x6
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar09] = a
    //Password bytes #$07 and #$08.
    y = 0x7
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar0a] = a
    //Password byte #$08.
    y = 0x8
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar0b] = a
    //Password byte #$09.
    y = 0x9
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar0c] = a
    //Password bytes #$09 and #$0A.
    y = 0x9
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar0d] = a
    //Password bytes #$0A and #$0B.
    y = 0xa
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar0e] = a
    //Password byte #$0B.
    y = 0xb
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar0f] = a
    //Password byte #$0C.
    y = 0xc
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar10] = a
    //Password bytes #$0C and #$0D.
    y = 0xc
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar11] = a
    //Password bytes #$0D and #$0E.
    y = 0xd
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar12] = a
    //Password byte #$0E.
    y = 0xe
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar13] = a
    //Password byte #$0F.
    y = 0xf
    //($8F2D)
    call sixupperbits
    //Store results.
    [passwordchar14] = a
    //Password bytes #$0F and #$10.
    y = 0xf
    //($8F33)
    call twolowerandfourupper
    //Store results.
    [passwordchar15] = a
    //Password bytes #$10 and #$11.
    y = 0x10
    //($8F46)
    call fourlowerandtwoupper
    //Store results.
    [passwordchar16] = a
    //Password byte #$11.
    y = 0x11
    //($8F5A)
    call sixlowerbits
    //Store results.
    [passwordchar17] = a
    return

def sixupperbits:

    //Uses six upper bits to create a new byte.-->
    a = [passwordbyte00:y]
    //Bits are right shifted twice and two lower-->
    a = a >> 1
    //bits are discarded.
    a = a >> 1
    return
 
def twolowerandfourupper:

    a = [passwordbyte00:y]
    //Saves two lower bits and stores them-->
    a = a & 0x3
    //($C2C5)in bits 4 and 5.
    call amul16
    [0x0] = a
    //Saves upper 4 bits and stores them-->
    a = [passwordbyte01:y]
    //($C2BF)bits 0, 1, 2 and 3.
    call adiv16
    //Add two sets of bits together to make a byte-->
    a = a | [0x0]
    //where bits 6 and 7 = 0.
    return
 
def fourlowerandtwoupper:

    a = [passwordbyte00:y]
    //Keep lower 4 bits.
    a = a & 0xf
    //Move lower 4 bits to bits 5, 4, 3 and 2.
    a = a << 1
    a = a << 1
    [0x0] = a
    //Move upper two bits-->
    a = [passwordbyte01:y]
    //to bits 1 and 0.
    a = a <<< 1
    a = a <<< 1
    a = a <<< 1
    //Add two sets of bits together to make a byte-->
    a = a & 0x3
    //where bits 6 and 7 = 0.
    a = a | [0x0]
    return

def sixlowerbits:

    //Discard bits 6 and 7.
    a = [passwordbyte00:y]
    a = a & 0x3f
    return

//The following routine converts the 24 user entered password characters into the 18 password
//bytes used by the program to store Samus' stats and unique item history.

def consolidatepassword:

    //Password characters #$00 and #$01.
    y = 0x0
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte00] = a
    //Password characters #$01 and #$02.
    y = 0x1
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte01] = a
    //Password characters #$02 and #$03.
    y = 0x2
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte02] = a
    //Password characters #$04 and #$05.
    y = 0x4
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte03] = a
    //Password characters #$05 and #$05.
    y = 0x5
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte04] = a
    //Password characters #$06 and #$07.
    y = 0x6
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte05] = a
    //Password characters #$08 and #$09.
    y = 0x8
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte06] = a
    //Password characters #$09 and #$0A.
    y = 0x9
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte07] = a
    //Password characters #$0A and #$0B.
    y = 0xa
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte08] = a
    //Password characters #$0C and #$0D.
    y = 0xc
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte09] = a
    //Password characters #$0D and #$0E.
    y = 0xd
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte0a] = a
    //Password characters #$0E and #$0F.
    y = 0xe
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte0b] = a
    //Password characters #$10 and #$11.
    y = 0x10
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte0c] = a
    //Password characters #$11 and #$12.
    y = 0x11
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte0d] = a
    //Password characters #$12 and #$13.
    y = 0x12
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte0e] = a
    //Password characters #$15 and #$15.
    y = 0x14
    //($8FF1)
    call sixlowerandtwoupper
    //Store results.
    [passwordbyte0f] = a
    //Password characters #$15 and #$16.
    y = 0x15
    //($9001)
    call fourlowerandfivethrutwo
    //Store results.
    [passwordbyte10] = a
    //Password characters #$16 and #$17.
    y = 0x16
    //($9011)
    call twolowerandsixlower
    //Store results.
    [passwordbyte11] = a
    return

def sixlowerandtwoupper:

    //Remove upper two bits and transfer-->
    a = [passwordchar00:y]
    //lower six bits to upper six bits.
    a = a << 1
    a = a << 1
    [0x0] = a
    //Move bits 4and 5 to lower two-->
    a = [passwordchar01:y]
    //($C2BF)bits and discard the rest.
    call adiv16
    //Combine the two bytes together.
    a = a | [0x0]
    return

def fourlowerandfivethrutwo:

    //Take four lower bits and transfer-->
    a = [passwordchar00:y]
    //($C2C5)them to upper four bits. Discard the rest.
    call amul16
    [0x0] = a
    //Remove two lower bits and transfer-->
    a = [passwordchar01:y]
    //bits 5 thru 2 to lower four bits.
    a = a >> 1
    a = a >> 1
    //Combine the two bytes together.
    a = a | [0x0]
    return
 
def twolowerandsixlower:

    //Shifts two lower bits to two higest bits-->
    a = [passwordchar00:y]
    //and discards the rest
    a = a >>> 1
    a = a >>> 1
    a = a >>> 1
    a = a & 0xc0
    [0x0] = a
    //Add six lower bits to previous results.
    a = [passwordchar01:y]
    a = a | [0x0]
    return

def passwordbitmasktbl:

    byte: 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80

//The following table contains the unique items in the game.  The two bytes can be deciphered
//as follows:IIIIIIXX XXXYYYYY. I = item type, X = X coordinate on world map, Y = Y coordinate
//on world map.  The items have the following values of IIIIII:
//High jump     = 000001
//Long beam     = 000010 (Not considered a unique item).
//Screw attack  = 000011
//Maru Mari     = 000100
//Varia suit    = 000101
//Wave beam     = 000110 (Not considered a unique item).
//Ice beam      = 000111 (Not considered a unique item).
//Energy tank   = 001000
//Missiles      = 001001
//Missile door  = 001010
//Bombs         = 001100
//Mother brain  = 001110
//1st Zeebetite = 001111
//2nd Zeebetite = 010000
//3rd Zeebetite = 010001
//4th Zeebetite = 010010
//5th Zeebetite = 010011

def itemdata:

    //Maru Mari at coord 02,0E                    (Item 0)
    word: 0x104e
    //Missiles at coord 12,0B                     (Item 1)
    word: 0x264b
    //Red door to long beam at coord 07,05        (Item 2)
    word: 0x28e5
    //Red door to Tourian elevator at coord 05,02 (Item 3)
    word: 0x2882
    //Energy tank at coord 19,07                  (Item 4)
    word: 0x2327
    //Red door to bombs at coord 1A,05            (Item 5)
    word: 0x2b25
    //Bombs at coord 19,05                        (Item 6)
    word: 0x325
    //Red door to ice beam at coord 13,09         (Item 7)
    word: 0x2a69
    //Missiles at coord 18,03                     (Item 8)
    word: 0x2703
    //Energy tank at coord 1B,03                  (Item 9)
    word: 0x2363
    //Red door to varia suit at coord 0F,02       (Item 10)
    word: 0x29e2
    //Varia suit at coord 0F,02                   (Item 11)
    word: 0x15e2
    //Energy tank at coord 09,0E                  (Item 12)
    word: 0x212e
    //Missiles at coord 12,0E                     (Item 13)
    word: 0x264e
    //Missiles at coord 11,0F                     (Item 14)
    word: 0x262f
    //Red door to ice beam at coord 1B,0C         (Item 15)
    word: 0x2b4c
    //Missiles at coord 1B,0A                     (Item 16)
    word: 0x276a
    //Missiles at coord 1C,0A                     (Item 17)
    word: 0x278a
    //Missiles at coord 1C,0B                     (Item 18)
    word: 0x278b
    //Missiles at coord 1B,0B                     (Item 19)
    word: 0x276b
    //Missiles at coord 1A,0B                     (Item 20)
    word: 0x274b
    //Missiles at coord 14,0F                     (Item 21)
    word: 0x268f
    //Missiles at coord 13,0F                     (Item 22)
    word: 0x266f
    //Red door to high jump at coord 1C,11        (Item 23)
    word: 0x2b71
    //High jump at coord 1B,11                    (Item 24)
    word: 0x771
    //Red door to screw attack at coord 0E,10     (Item 25)
    word: 0x29f0
    //Screw attack at coord 0D,1D                 (Item 26)
    word: 0xdf0
    //Missiles at coord 13,16                     (Item 27)
    word: 0x2676
    //Misslies at coord 14,16                     (Item 28)
    word: 0x2696
    //Red door to wave beam at coord 1C,15        (Item 29)
    word: 0x2a55
    //Energy tank at coord 1A,13                  (Item 30)
    word: 0x2353
    //Missiles at coord 1C,14                     (Item 31)
    word: 0x2794
    //Red door at coord 07,15                     (Item 32)
    word: 0x28f5
    //Missiles at coord 09,15                     (Item 33)
    word: 0x2535
    //Missiles at coord 04,15                     (Item 34)
    word: 0x2495
    //Red door at coord 07,16                     (Item 35)
    word: 0x28f6
    //Energy tank at coord 0A,16                  (Item 36)
    word: 0x2156
    //Red door at coord 07,18                     (Item 37)
    word: 0x28f8
    //Red door at coord 03,1B                     (Item 38)
    word: 0x287b
    //Missiles at coord 05,1B                     (Item 39)
    word: 0x24bb
    //Missiles at coord 0A,19                     (Item 40)
    word: 0x2559
    //Red door to Kraid at coord 08,1D            (Item 41)
    word: 0x291d
    //Energy tank at coord 08,1D(Kraid's room)    (Item 42)
    word: 0x211d
    //Missiles at coord 12,18                     (Item 43)
    word: 0x2658
    //Red door at coord 11,19                     (Item 44)
    word: 0x2a39
    //Energy tank at coord 11,19                  (Item 45)
    word: 0x2239
    //Missiles at coord 14,1E                     (Item 46)
    word: 0x269e
    //purple door at coord 10,1D(Ridley's room)   (Item 47)
    word: 0x2a1d
    //Energy tank at coord 0F,1D                  (Item 48)
    word: 0x21fd
    //Missile at coord 18,1B                      (Item 49)
    word: 0x271b
    //Orange door at coord 03,07                  (Item 50)
    word: 0x2867
    //Red door at coord 09,07                     (Item 51)
    word: 0x2927
    //Red door at coord 0A,0B                     (Item 52)
    word: 0x292b
    //1st Zeebetite in mother brain room          (Item 53)
    word: 0x3c00
    //2nd Zeebetite in mother brain room          (Item 54)
    word: 0x4000
    //3rd Zeebetite in mother brain room          (Item 55)
    word: 0x4400
    //4th Zeebetite in mother brain room          (Item 56)
    word: 0x4800
    //5th Zeebetite in mother brain room          (Item 57)
    word: 0x4c00
    //Mother brain                                (Item 58)
    word: 0x3800

def clearall:

    //($C439)Turn screen off.
    call screenoff
    //Turn off screen, clear sprites and name tables.
    call clear_all_nametables
    call clear_all_sprites
    //Set Name table address to $2000.
    a = [video.ctrl]
    a = a & 0xfc
    [video.ctrl] = a
    a = 0x0
    //Reset scroll offsets.
    [scroll.y] = a
    [scroll.x] = a
    //($C42C)Wait for NMI to end.
    call waitnmipass
    //($C47D)Set PPU for horizontal write and turn off VBlank.
    goto vboffandhorzwrite

def startcontinuescreen:

    //($909F)Turn off screen, erase sprites and nametables.
    call clearall
    //Low address for PPU write.
    x = 0x84
    //High address for PPU write.
    y = 0x99
    //($9449)Clears screen and writes "START CONTINUE".
    call prepareppuprocess
    y = 0x0
    //Set selection sprite at START.
    [startcontinue] = y
    a = 0xd
    //Change palette and title routine.
    [video.palette_pending] = a
    //Next routine is ChooseStartContinue.
    a = 0x16
    [titleroutine] = a

def turnondisplay:

    //($C487)Turn on the nonmaskable interrupt.
    call nmion
    //($C447)Turn screen on.
    goto screenon

def choosestartcontinue:

    a = [joy1.delta]
    //Checks both select and start buttons.
    a = a & 0x30
    //Check if START has been pressed.
    compare a to 0x10
    //Branch if START not pressed.
    goto _0061 when ~zero
    y = [startcontinue]
    //if CONTINUE selected, branch.
    goto _0060 when ~zero
    //($932B)Zero out all stats.
    goto initializestats
def _0060:
    //Next routine is LoadPasswordScreen.
    y = 0x17
    [titleroutine] = y
def _0061:
    //check if SELECT has been pressed.
    compare a to 0x20
    //Branch if SELECT not pressed.
    goto _0062 when ~zero
    a = [startcontinue]
    //Chooses between START and CONTINUE-->
    a = a ^ 0x1
    //on game select screen.
    [startcontinue] = a
    a = [trianglesfxflag]
    //Set SFX flag for select being pressed.-->
    a = a | 0x8
    //Uses triangle channel.
    [trianglesfxflag] = a
def _0062:
    y = [startcontinue]
    //Get y pos of selection sprite.
    a = [startconttbl:y]
    [sprite00ram] = a
    //Load sprite info for square selection sprite.
    a = 0x6e
    [sprite00ram+1] = a
    a = 0x3
    [sprite00ram+2] = a
    //Set data for selection sprite.
    a = 0x50
    [sprite00ram+3] = a
    return

def startconttbl:

    //Y sprite position for START.
    byte: 0x60
    //Y sprite position for CONTINUE.
    byte: 0x78

def loadpasswordscreen:

    //($909F)Turn off screen, erase sprites and nametables.
    call clearall
    //Loads PPU with info to display-->
    x = 0xe3
    //PASS WORD PLEASE.
    y = 0x99
    //($9449)Load "PASSWORD PLEASE" on screen.
    call prepareppuprocess
    //($C6D6)Loads the font for the password.
    call initgfx7
    //($940B)Write password character to screen.
    call displayinputcharacters
    a = 0x13
    //Change palette.
    [video.palette_pending] = a
    a = 0x0
    //Sets character select cursor to-->
    [inputrow] = a
    //upper left character (0).
    [inputcolumn] = a
    [timer3] = a
    a = 0x0
    //Sets password cursor to password character 0.
    [passwordcursor] = a
    y = 0x0
    //Appears to have no function.
    [passwordstat00] = y
    [titleroutine]++
    //($90D1)Turn on screen and NMI.
    goto turnondisplay

def enterpassword:

    //($C1A3)Remove sprites from screen.
    call clear_all_sprites
    a = [joy1.delta]
    //Check to see if START has been pressed.
    a = a & 0x10
    //If not, branch.
    goto _0063 when zero
    //($8C5E)Check if password is correct.
    goto checkpassword
def _0063:
    x = 0x1
    //Prepare to write the password screen data to PPU.
    [video.ppu_pending] = x
    x = [ppustrindex]
    //Upper byte of PPU string.
    a = 0x21
    //($C36B)Write byte to PPU.
    call writeppubyte
    //Lower byte of PPU string.
    a = 0xa8
    //($C36B)Write byte to PPU.
    call writeppubyte
    //PPU string length.
    a = 0xf
    //($C36B)Write byte to PPU.
    call writeppubyte
    a = [timer3]
    goto _0064 when zero
    a = 0x59
    //Writes 'ERROR TRY AGAIN' on the screen-->
    [0x2] = a
    //if Timer3 is anything but #$00.
    a = 0x87
    [0x3] = a
    goto _0065
def _0064:
    a = 0x68
    [0x2] = a
    a = 0x87
    //Writes the blank lines that cover-->
    [0x3] = a
def _0065:
    //the message 'ERROR TRY AGAIN'.
    y = 0x0
def _0066:
    a = [[0x2]:y]
    call writeppubyte
    y++
    compare y to 0xf
    goto _0066 when ~zero
    //If button A pressed, branch.
    a = [joy1.delta]
    goto _0067 when negative
    //($91FB)Check if backspace pressed.
    goto checkbackspace
def _0067:
    //Initiate BombLaunch SFX if a character-->
    a = [trianglesfxflag]
    //has been written to the screen.
    a = a | 0x1
    [trianglesfxflag] = a
    a = [passwordcursor]
    //Check to see if password cursor is on-->
    compare a to 0x12
    //character 19 thru 24.  If not, branch.
    goto _0068 when ~carry
    carry = 0
    //Will equal #$50 thru #$55.
    a = a +# 0x3e
    //($91BF)
    goto loadrowandcolumn
def _0068:
    //Check to see if password cursor is on-->
    compare a to 0xc
    //character 13 thru 18.  If not, branch.
    goto _0069 when ~carry
    carry = 0
    //Will equal #$49 thru #$4E.
    a = a +# 0x3d
    //($91BF)
    goto loadrowandcolumn
def _0069:
    //Check to see if password cursor is on-->
    compare a to 0x6
    //character 7 thru 12.  If not, branch.
    goto _006A when ~carry
    carry = 0
    //Will equal #$10 thru #$15.
    a = a +# 0xa
    //($91BF)
    goto loadrowandcolumn
def _006A:
    carry = 0
    //Will equal #$09 thru #$0E.
    a = a +# 0x9

def loadrowandcolumn:

def _006B:
    [0x6] = a
    a = [inputrow]
    //*2. address pointer is two bytes.
    a = a << 1
    y = a
    //Store lower byte of row pointer.
    a = [passwordrowtbl:y]
    [0x0] = a
    //Store upper byte of row pointer.
    a = [passwordrowtbl+1:y]
    [0x1] = a
    //Uses InputColumn value to find proper index-->
    y = [inputcolumn]
    //of current character selected.
    a = [[0x0]:y]
    //Temp storage of A.
    push a
    //Store value of current character slected.
    [tileinfo0] = a
    a = 0x11
    [tilesize] = a
    //Replace password character tile with-->
    x = [0x6]
    //the one selected by the player.
    y = 0x21
    //($9450)
    call prepareerasetiles
    x = [passwordcursor]
    //Store the currently selected password character-->
    a = pop
    //in the proper PasswordChar RAM location.
    [passwordchar00:x] = a
    a = [passwordcursor]
    carry = 0
    a = a +# 0x1
    compare a to 0x18
    //Increment PasswordCursor.  If at last character,-->
    goto _006C when ~carry
    //loop back to the first character.
    a = 0x0
def _006C:
    [passwordcursor] = a

def checkbackspace:

    a = [joy1.delta]
    //If button B (backspace) has not-->
    a = a & 0x40
    //been pressed, branch.
    goto _006E when zero
    a = [passwordcursor]
    //Subtract 1 from PasswordCursor.  If-->
    carry = 1
    //PasswordCursor is negative, load-->
    a = a -# 0x1
    //PasswordCursor with #$17 (last character).
    goto _006D when carry
    a = 0x17
def _006D:
    [passwordcursor] = a
def _006E:
    //Appears to have no function.
    y = [passwordstat00]
    a = [framecount]
    //If FrameCount bit 3 not set, branch.
    a = a & 0x8
    goto _0071 when zero
    a = 0x3f
    //Load A with #$3F if PasswordCursor is on-->
    x = [passwordcursor]
    //character 0 thru 11, else load it with #$4F.
    compare x to 0xc
    goto _006F when ~carry
    a = 0x4f
def _006F:
    //Set Y-coord of password cursor sprite.
    [sprite01ram] = a
    a = 0x6e
    //Set pattern for password cursor sprite.
    [sprite01ram+1] = a
    a = 0x20
    //Set attributes for password cursor sprite.
    [sprite01ram+2] = a
    //If the password cursor is at the 12th-->
    a = [passwordcursor]
    //character or less, branch.
    compare a to 0xc
    goto _0070 when ~carry
    //Calculate how many characters the password cursor-->
    a = a -# 0xc
def _0070:
    //is from the left if on the second row of password.
    x = a
    //Load X position of PasswordCursor.
    a = [cursorpostbl:x]
    [sprite01ram+3] = a
def _0071:
    //Load X and Y with row and column-->
    x = [inputrow]
    //of current character selected.
    y = [inputcolumn]
    a = [joy1.retrigger]
    //If no directional buttons are in-->
    a = a & 0xf
    //retrigger mode, branch.
    goto _007B when zero
    //Temp storage of A.
    push a
    //Initiate BeepSFX when the player pushes-->
    a = [trianglesfxflag]
    //a button on the directional pad.
    a = a | 0x8
    [trianglesfxflag] = a
    //Restore A.
    a = pop
    //Put status of right directional button in carry bit.
    a = a >> 1
    //Branch if right button has not been pressed.
    goto _0074 when ~carry
    y++
    //Increment Y(column).  If Y is greater than #$0C,-->
    compare y to 0xd
    //increment X(Row).  If X is greater than #$04,-->
    goto _0073 when ~zero
    //set X to #$00(start back at top row) and store-->
    x++
    //new row in InputRow.
    compare x to 0x5
    goto _0072 when ~zero
    x = 0x0
def _0072:
    [inputrow] = x
    //Store new column in InputColumn.
    y = 0x0
def _0073:
    [inputcolumn] = y
def _0074:
    //Put status of left directional button in carry bit.
    a = a >> 1
    //Branch if left button has not been pressed.
    goto _0077 when ~carry
    y--
    //Decrement Y(column).  If Y is less than #$00,-->
    goto _0076 when ~negative
    //Decrement X(row).  If X is less than #$00,-->
    x--
    //set X to #$04(last row) and store new row-->
    goto _0075 when ~negative
    //in InputRow.
    x = 0x4
def _0075:
    [inputrow] = x
    //Store new column in InputColumn.
    y = 0xc
def _0076:
    [inputcolumn] = y
def _0077:
    //Put status of down directional button in carry bit.
    a = a >> 1
    //Branch if down button has not been pressed.
    goto _0079 when ~carry
    x++
    //Increment X(row).  if X is greater than #$04,-->
    compare x to 0x5
    //set X to #$00(first row) and store new-->
    goto _0078 when ~zero
    //row in InputRow.
    x = 0x0
def _0078:
    [inputrow] = x
def _0079:
    //Put status of up directional button in carry bit.
    a = a >> 1
    //Branch if up button has not been pressed.
    goto _007B when ~carry
    x--
    //Decrement X(row).  if X is less than #$00,-->
    goto _007A when ~negative
    //set X to #$04(last row) and store new-->
    x = 0x4
def _007A:
    //row in InputRow.
    [inputrow] = x
def _007B:
    a = [framecount]
    //If FrameCount bit 3 not set, branch.
    a = a & 0x8
    goto _007C when zero
    //Set Y-coord of character selection sprite.
    a = [charselectytbl:x]
    [sprite02ram] = a
    //Set pattern for character selection sprite.
    a = 0x6e
    [sprite02ram+1] = a
    //Set attributes for character selection sprite.
    a = 0x20
    [sprite02ram+2] = a
    //Set x-Coord of character selection sprite.
    a = [charselectxtbl:y]
    [sprite02ram+3] = a
def _007C:
    return

//The following data does not appear to be used in the program.
    byte: 0x21, 0x20

//The following table is used to determine the proper Y position of the character
//selection sprite on password entry screen.

def charselectytbl:
 
    byte: 0x77, 0x87, 0x97, 0xa7, 0xb7

//The following table is used to determine the proper X position of the character
//selection sprite on password entry screen.

def charselectxtbl:

    byte: 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0

//When the PasswordCursor is on the second row of the password, the following table is used
//to determine the proper x position of the password cursor sprite(password characters 12-23).

def cursorpostbl:

    byte: 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8

def initializegame:

    //($C1D4)Clear RAM.
    call clearram_33_df
    //($C578)Reset Samus stats for a new game.
    call clearsamusstats
    //($8D12)Load data from password.
    call loadpassworddata
    y = 0x0
    [spritepagepos] = y
    //Clear object data.
    [pageindex] = y
    [objectcntrl] = y
    [objecthi] = y
    //($CB8E)Turn off music.
    call silencemusic
    a = 0x5a
    //Set animframe index. changed by initializing routines.
    [animframe] = a
    //x is the index into the position tables below.
    x = 0x1
    //Load starting area.
    a = [inarea]
    a = a & 0xf
    //If in area other than Brinstar, get second item in tables.
    goto _007D when ~zero
    //Starting in Brinstar. Get forst item in each table.
    x--
def _007D:
    a = [restartypostbl:x]
    //Set Samus restart y position on screen.
    [objecty] = a
    a = [restartxpostbl:x]
    //Set Samus restart x position on screen.
    [objectx] = a
    //The combination of SamusStat02 and 03 keep track of how-->
    [samusstat02]++
    //many times Samus has died and beaten the game as they are-->
    goto _007E when ~zero
    //incremented every time this routine is run, but they are-->
    [samusstat03]++
def _007E:
    //not accessed anywhere else.
    a = 0x1
    //Initialize starting area.
    [mainroutine] = a
    //($C45D)Turn off screen.
    call screennmioff
    //($C5DC)Load Samus GFX into pattern table.
    call loadsamusgfx
    //($C487)Turn on the non-maskable interrupt.
    call nmion
    //Load area Samus is to start in.
    a = [inarea]
    a = a & 0xf
    y = a
    //Change to proper memory page.
    a = [switch_bank_table:y]
    [switchpending] = a
def title_page_9324:
    return

//The following two tables are used to find Samus y and x positions on the screen after the game
//restarts.  The third entry in each table are not used.

def restartypostbl:

    //Brinstar
    byte: 0x64
    //All other areas.
    byte: 0x8c
    //Not used.
    byte: 0x5c

def restartxpostbl:

    //Brinstar
    byte: 0x78
    //All other areas.
    byte: 0x78
    //Not used.
    byte: 0x5c

def initializestats:

    a = 0x0
    [samusstat00] = a
    [tankcount] = a
    [samusgear] = a
    [missilecount] = a
    [maxmissiles] = a
    //Set all of Samus' stats to 0 when starting new game.
    [kraidstatuestatus] = a
    [ridleystatuestatus] = a
    [samusage] = a
    [samusage+1] = a
    [samusage+2] = a
    [samusstat01] = a
    [atending] = a
    [justinbailey] = a
    a = 0x2
    //Prepare to switch to Brinstar memory page.
    [switchpending] = a
    return

def displaypassword:

    //Wait for "GAME OVER" to be displayed-->
    a = [timer3]
    //for 160 frames (2.6 seconds).
    goto title_page_9324 when ~zero
    //($909F)Turn off screen, erase sprites and nametables.
    call clearall
    //Low byte of start of PPU data.
    x = 0x7f
    //High byte of start of PPU data.
    y = 0x93
    //($9449)Clears screen and writes "PASS WORD".
    call prepareppuprocess
    //($C6D6)Loads the font for the password.
    call initgfx7
    //($8C7A)Calculates the password.
    call calculatepassword
    //($C487)Turn on the nonmaskable interrupt.
    call nmion
    //($93C6)Displays password on screen.
    call passwordtoscreen
    //($C42C)Wait for NMI to end.
    call waitnmipass
    a = 0x13
    //Change palette.
    [video.palette_pending] = a
    [titleroutine]++
    //($C447)Turn screen on.
    goto screenon

//Information below is for above routine to display "PASS WORD" on the screen.
    //PPU memory high byte.
    byte: 0x21
    //PPU memory low byte.
    byte: 0x4b
    //PPU string length.
    byte: 0x9
//             'P    A    S    S    _    W    O    R    D'
    byte: 0x19, 0xa, 0x1c, 0x1c, 0xff, 0x20, 0x18, 0x1b, 0xd

//Information to be stored in attribute table 0.
    //PPU memory high byte.
    byte: 0x23
    //PPU memory low byte.
    byte: 0xd0
    //RLE bit set, repeat entry 8 times.
    byte: 0x48
    //Clears line below "PASS WORD".
    byte: 0x0

    //PPU memory high byte.
    byte: 0x23
    //PPU memory low byte.
    byte: 0xd8
    //RLE bit set, repeat entry 32 times.
    byte: 0x60
    //Turn color on to display password characters.
    byte: 0x55

    //End PPU string write.
    byte: 0x0

def waitforstart:

    //Waits for START to be ressed proceed-->
    a = [joy1.delta]
    //past the GAME OVER screen.
    a = a & 0x10
    //If start not pressed, branch.
    goto _007F when zero
    //($8C5E)Check if password is correct.
    goto checkpassword
def _007F:
    return

def gameover:

    //($909F)Turn off screen, erase sprites and nametables.
    call clearall
    //Low byte of start of PPU data.
    x = 0xb9
    //High byte of start of PPU data.
    y = 0x93
    //($9449)Clears screen and writes "GAME OVER".
    call prepareppuprocess
    //($C6D6)Loads the font for the password.
    call initgfx7
    //($C487)Turn on the nonmaskable interrupt.
    call nmion
    //Load Timer3 with a delay of 160 frames-->
    a = 0x10
    //(2.6 seconds) for displaying "GAME OVER".
    [timer3] = a
    //Loads TitleRoutine with -->
    a = 0x19
    //DisplayPassword.
    [titleroutine] = a
    //($C447)Turn screen on.
    goto screenon

//Information below is for above routine to display "GAME OVER" on the screen.
    //PPU memory high byte.
    byte: 0x21
    //PPU memory low byte.
    byte: 0x8c
    //PPU string length.
    byte: 0x9
//             'G    A    M    E    _    O    V    E    R'
    byte: 0x10, 0xa, 0x16, 0xe, 0xff, 0x18, 0x1f, 0xe, 0x1b

    //End PPU string write.
    byte: 0x0

def passwordtoscreen:

    //($C42C)Wait for NMI to end.
    call waitnmipass
    //Index to find password characters(base=$699A).
    y = 0x5
    //($93F9)Load tiles on screen.
    call loadpasswordtiles
    //PPU low address byte.
    x = 0xa9
    //PPU high address byte.
    y = 0x21
    //($9450)Erase tiles on screen.
    call prepareerasetiles
    //Index to find password characters(base=$699A).
    y = 0xb
    //($93F9)Load tiles on screen.
    call loadpasswordtiles
    //PPU low address byte.
    x = 0xb0
    //PPU high address byte.
    y = 0x21
    //($9450)Erase tiles on screen.
    call prepareerasetiles
    //Index to find password characters(base=$699A).
    y = 0x11
    //($93F9)Load tiles on screen.
    call loadpasswordtiles
    //PPU low address byte.
    x = 0xe9
    //PPU high address byte.
    y = 0x21
    //($9450)Erase tiles on screen.
    call prepareerasetiles
    //Index to find password characters(base=$699A).
    y = 0x17
    //($93F9)Load tiles on screen.
    call loadpasswordtiles
    //PPU low address byte.
    x = 0xf0
    //PPU high address byte.
    y = 0x21
    //($9450)Erase tiles on screen.
    goto prepareerasetiles

def loadpasswordtiles:

    //Tiles to replace are one block-->
    a = 0x16
    //high and 6 blocks long.
    [tilesize] = a
    x = 0x5
def _0080:
    a = [passwordchar00:y]
    [tileinfo0:x] = a
    //Transfer password characters to-->
    y--
    //TileInfo addresses.
    x--
    ////
    goto _0080 when ~negative
    return

def displayinputcharacters:

    //Clear address latches.
    a = [nes.ppu.status]
    y = 0x0
    //Initially sets $00 an $01.
    a = y
    //to #$00.
    [0x0] = a
    //Also, initialy sets x and y to #$00.
    [0x1] = a
def _0081:
    a = a << 1
    x = a
    a = [passwordrowstbl:x]
    [nes.ppu.address] = a
    //Displays the list of characters -->
    a = [passwordrowstbl+1:x]
    //to choose from on the password-->
    [nes.ppu.address] = a
    //entry screen.
    x = 0x0
def _0082:
    //Base is $99A2.
    a = [passwordrow0:y]
    [nes.ppu.data] = a
    //Blank tile.
    a = 0xff
    [nes.ppu.data] = a
    y++
    x++
    //13 characters in current row?
    compare x to 0xd
    //if not, add another character.
    goto _0082 when ~zero
    [0x1]++
    a = [0x1]
    //5 rows?
    compare a to 0x5
    //If not, go to next row.
    goto _0081 when ~zero
    return

//The table below is used by the code above to determine the positions
//of the five character rows on the password entry screen.

def passwordrowstbl:

    byte: 0x21, 0xe4
    //The two entries in each row are the upper and lower address-->
    byte: 0x22, 0x24
    //bytes to start writing to the name table, respectively.
    byte: 0x22, 0x64
    byte: 0x22, 0xa4
    byte: 0x22, 0xe4


def prepareppuprocess:

    //Lower byte of pointer to PPU string
    [0x0] = x
    //Upper byte of pointer to PPU string
    [0x1] = y
    //($C30C)
    goto processppustring

def prepareerasetiles:

    //PPU low address byte
    [0x0] = x
    //PPU high address byte
    [0x1] = y
    x = 0x80
    y = 0x7
    //Address of byte where tile size-->
    [0x2] = x
    //of tile to be erased is stored.
    [0x3] = y
    //($C328)Erase the selected tiles.
    goto erasetile

//---------------------------------------[ Unused intro routines ]------------------------------------

//The following routines are intro routines that are not used in this version of the game.  It
//appears that the intro routine was originally going to be more complex with a more advanced
//sprite control mechanism and name table writing routines. The intro routines are a mess! In
//addition to unused routines, there are several unused memory addresses that are written to but
//never read.

def unusedintroroutine4:

    [ppustrindex] = x
    a = 0x0
    //The following unused routine writes something to the-->
    [ppudatastring:x] = a
    //PPU string and prepares for a PPU write.
    a = 0x1
    [video.ppu_pending] = a
    return

def unusedintroroutine5:

    [0x5] = a
    a = a & 0xf0
    a = a >> 1
    a = a >> 1
    a = a >> 1
    a = a >> 1
    call _0083
    //Unused intro routine. It looks like originally the-->
    a = [0x5]
    //title routines were going to write data to the name-->
    a = a & 0xf
def _0083:
    //tables in the middle of the title sequences.
    [ppudatastring:x] = a
    x++
    a = x
    compare a to 0x55
    goto _0085 when ~carry
    x = [ppustrindex]
def _0084:
    a = 0x0
    [ppudatastring:x] = a
    goto _0084 when zero
def _0085:
    return

def unusedintroroutine6:

    a = y
    push a
    //($C2C5)Multiply by 16.
    call amul16
    y = a
    a = [0x684b:y]
    [0xb] = a
    a = [0x684a:y]
    [0xa] = a
    //($94DA)
    call unusedintroroutine8
    a = [0x6]
    //Another unused intro routine.
    [0x683d:x] = a
    a = [0x7]
    [0x683c:x] = a
    a = pop
    y = a
    return

def unusedintroroutine7:

    a = y
    push a
    //($C2C5)Multiply by 16.
    call amul16
    y = a
    a = [0x684d:y]
    [0xb] = a
    a = [0x684c:y]
    [0xa] = a
    //($94DA)
    call unusedintroroutine8
    a = [0x6]
    [0x6834:x] = a
    a = [0x7]
    [0x6833:x] = a
    //Another unused intro routine.
    a = [0x6842:y]
    push a
    a = x
    a = a >> 1
    y = a
    a = pop
    [0x6839:y] = a
    a = pop
    y = a
    return

def unusedintroroutine8:

    a = 0xff
    [0x1] = a
    [0x2] = a
    [0x3] = a
    carry = 1
def _0086:
    a = [0xa]
    a = a -# 0xe8
    [0xa] = a
    a = [0xb]
    a = a -# 0x3
    [0xb] = a
    [0x3]++
    goto _0086 when carry
    a = [0xa]
    a = a +# 0xe8
    [0xa] = a
    a = [0xb]
    a = a +# 0x3
    [0xb] = a
    a = [0xa]
def _0087:
    //Unused intro routine. Looks like the intro routines may-->
    carry = 1
def _0088:
    //have had more complicated sprite control routines-->
    a = a -# 0x64
    //that it does now.
    [0x2]++
    goto _0088 when carry
    [0xb]--
    goto _0087 when ~negative
    a = a +# 0x64
    carry = 1
def _0089:
    a = a -# 0xa
    [0x1]++
    goto _0089 when carry
    a = a +# 0xa
    [0x6] = a
    a = [0x1]
    //($C2C5)Multiply by 16.
    call amul16
    a = a | [0x6]
    [0x6] = a
    a = [0x3]
    //($C2C5)Multiply by 16.
    call amul16
    a = a | [0x2]
    [0x7] = a
    return

//Not used.
    byte: 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0

//--------------------------------------[ Palette data ]---------------------------------------------

//The following table points to the palette data
//used in the intro and ending portions of the game.

def palettecolorspointertable:

    //($9586)
    word: palette00
    //($95AA)
    word: palette01
    //($95CE)
    word: palette02
    //($95F2)
    word: palette03
    //($9616)
    word: palette04
    //($963A)
    word: palette05
    //($965E)
    word: palette06
    //($9682)
    word: palette07
    //($96A6)
    word: palette08
    //($96CA)
    word: palette09
    //($96EE)
    word: palette0a
    //($9712)
    word: palette0b
    //($9736)
    word: palette0c
    //($975A)
    word: palette0d
    //($977E)
    word: palette0e
    //($97A2)
    word: palette0f
    //($97C6)
    word: palette10
    //($97EA)
    word: palette11
    //($97F2)
    word: palette12

def palette00:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette01 info.
    byte: 0x0

def palette01:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x35, 0x35, 0x4, 0xf, 0x35, 0x14, 0x4
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette02 info.
    byte: 0x0

def palette02:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x39, 0x39, 0x9, 0xf, 0x39, 0x29, 0x9
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette03 info.
    byte: 0x0

def palette03:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x36, 0x36, 0x6, 0xf, 0x36, 0x15, 0x6
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette04 info.
    byte: 0x0

def palette04:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x27, 0x27, 0x12, 0xf, 0x27, 0x21, 0x12
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x31, 0x20, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette05 info.
    byte: 0x0

def palette05:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x1, 0x1, 0xf, 0xf, 0x1, 0xf, 0xf
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette06 info.
    byte: 0x0

def palette06:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x1, 0x1, 0xf, 0xf, 0x1, 0x1, 0xf
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette07 info.
    byte: 0x0

def palette07:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x2, 0x2, 0x1, 0xf, 0x2, 0x2, 0x1
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette08 info.
    byte: 0x0

def palette08:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x2, 0x2, 0x1, 0xf, 0x2, 0x1, 0x1
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette09 info.
    byte: 0x0

def palette09:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x12, 0x12, 0x2, 0xf, 0x12, 0x12, 0x2
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette0A info.
    byte: 0x0

def palette0a:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x11, 0x11, 0x2, 0xf, 0x11, 0x2, 0x2
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette0B info.
    byte: 0x0

def palette0b:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x31, 0x31, 0x1, 0xf, 0x31, 0x11, 0x1
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette0C info.
    byte: 0x0

def palette0c:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x12, 0x30, 0x21, 0xf, 0x27, 0x28, 0x29, 0xf, 0x31, 0x31, 0x1
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x2a, 0x27, 0xf, 0x12, 0x30, 0x21, 0xf, 0x27, 0x24, 0x2c, 0xf, 0x15, 0x21, 0x38

    //End Palette0D info.
    byte: 0x0

def palette0d:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x12, 0x12, 0x1, 0xf, 0x12, 0x2, 0x1
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette0E info.
    byte: 0x0

def palette0e:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x2, 0x2, 0xf, 0xf, 0x2, 0x1, 0xf
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette0F info.
    byte: 0x0

def palette0f:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x28, 0x18, 0x8, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x1, 0x1, 0xf, 0xf, 0x1, 0xf, 0xf
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x1a, 0x27, 0xf, 0x37, 0x3a, 0x1b, 0xf, 0x17, 0x31, 0x37, 0xf, 0x32, 0x22, 0x12

    //End Palette10 info.
    byte: 0x0

def palette10:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0x30, 0x28, 0x18, 0x8, 0x30, 0x29, 0x1b, 0x1a, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30
//The following values are written to the sprite palette:
    byte: 0x30, 0x16, 0x1a, 0x27, 0x30, 0x37, 0x3a, 0x1b, 0x30, 0x17, 0x31, 0x37, 0x30, 0x32, 0x22, 0x12

    //End Palette11 info.
    byte: 0x0

def palette11:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x4
//The following values are written to the background palette:
    byte: 0xf, 0x30, 0x30, 0x21

    //End Palette12 info.
    byte: 0x0

def palette12:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x10
//The following values are written to the background palette:
    byte: 0xf, 0x30, 0x30, 0xf, 0xf, 0x2a, 0x2a, 0x21, 0xf, 0x31, 0x31, 0xf, 0xf, 0x2a, 0x2a, 0x21

    //End Palette13 data.
    byte: 0x0

def endgamepal0b:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x0
    //Palette data length.
    byte: 0x10
//The following values are written to the background palette:
    byte: 0xf, 0x2c, 0x2c, 0x2c, 0xf, 0x2c, 0x2c, 0x2c, 0xf, 0x2c, 0x2c, 0x2c, 0xf, 0x2c, 0x2c, 0x2c

def endgamepal0c:

    //Upper byte of PPU palette adress.
    byte: 0x3f
    //Lower byte of PPU palette adress.
    byte: 0x10
    //Palette data length.
    byte: 0x50
    //Repeat bit set. Fill sprite palette with #$0F.
    byte: 0xf

    //End EndGamePal0C data.
    byte: 0x0

def updatespritecoords:

    //Load sprite run(sprite x component).
    a = [introspr0xrun:x]
    //($9871)Calculate sprite displacement in x direction.
    call calcdisplacement
    //Get byte describing if sprite increasing or decreasing pos.
    y = [introspr0xdir:x]
    goto _008A when ~negative

    //If MSB is set, sprite is decreasing position. convert-->
    a = a ^ 0xff
    //value in A (result from CalcDisplacement) to twos compliment.
    carry = 0
    a = a +# 0x1

def _008A:
    carry = 0
    //Add change to sprite x coord.
    a = a +# [introspr0xcoord:x]
    [introspr0xcoord:x] = a
    carry = 1
    //Subtract total sprite movemnt value from current sprite x pos.
    a = a -# [introspr0xchange:x]
    //Transfer processor status to A.
    push p
    a = pop
    //Eor carry bit with direction byte to see if sprite has-->
    a = a ^ [introspr0xdir:x]
    //reached its end point.
    a = a >> 1
    ////Branch if sprite has reached the end of x movement.
    goto _008B when ~carry

    //Load sprite rise(sprite y component).
    a = [introspr0yrise:x]
    //($9871)Calculate sprite displacement in y direction.
    call calcdisplacement
    //Get byte describing if sprite increasing or decreasing pos.
    y = [introspr0ydir:x]
    goto _008B when ~negative

    //If MSB is set, sprite is decreasing position. convert-->
    a = a ^ 0xff
    //value in A (result from CalcDisplacement) to twos compliment.
    carry = 0
    a = a +# 0x1

def _008B:
    carry = 0
    //Add change to sprite y coord.
    a = a +# [introspr0ycoord:x]
    [introspr0ycoord:x] = a
    carry = 1
    //Subtract total sprite movemnt value from current sprite y pos.
    a = a -# [introspr0ychange:x]
    //Transfer processor status to A.
    push p
    a = pop
    //Eor carry bit with direction byte to see if sprite has-->
    a = a ^ [introspr0ydir:x]
    //reached its end point.
    a = a >> 1
    //Branch if sprite has not reached the end of y movement.
    goto _008D when carry

def _008C:
    //After sprite has reached its final position, this code-->
    a = [introspr0ychange:x]
    //explicitly writes final the x and y coords to to sprite-->
    [introspr0ycoord:x] = a
    //position addresses to make sure the sprites don't-->
    a = [introspr0xchange:x]
    //overshoot their mark.
    [introspr0xcoord:x] = a
def _008D:
    return

def calcdisplacement:

    [0x4] = a
    //Time division. The higher the number, the slower the sprite.
    a = 0x8
    [0x0] = a
def _008E:
    [0x4] = [0x4] >> 1
    goto _008F when ~carry
    a = [framecount]
    //Calculate the change in the sprite position by taking the-->
    a = a & [0x0]
    //value in a and dividing it by the time division. The time-->
    goto _008F when ~zero
    //time division in this case is #$08.
    [0x4]++
def _008F:
    [0x0] = [0x0] >> 1
    goto _008E when ~zero
    a = [0x4]
    //Return A/time.
    return

//This function decrements the y coordinate of the 40 intro star sprites.

def decspriteycoord:

    a = [titleroutine]
    compare a to 0x1d
    //If the end game is playing, branch to exit.
    goto _0091 when carry
    a = [spriteloadpending]
    //If no sprite load is pending, branch to exit.
    goto _0091 when zero
    a = [framecount]
    a = a >> 1
    //If not on an odd numbered frame, branch to exit.
    goto _0091 when carry
    x = 0x9f
def _0090:
    //Decrement y coord of the intro star sprites.
    [introstarsprite00:x]--
    //Decrement y coord of 40 sprites.
    [sprite18ram:x]--
    x--
    x--
    //Move to next sprite.
    x--
    x--
    compare x to 0xff
    //Loop 40 times.
    goto _0090 when ~zero
    a = 0x0
    //Sprite RAM load complete.
    [spriteloadpending] = a
def _0091:
    return

def loadstarsprites:

    y = 0x9f
def _0092:
    a = [introstarsprite00:y]
    //Store RAM contents of $6E00 thru $6E9F -->
    [sprite18ram:y] = a
    //in sprite RAM at locations $0260 thru $02FF.
    y--
    compare y to 0xff
    goto _0092 when ~zero
    a = 0x0
    //Set $C8 to #$00.
    [spriteloadpending] = a
    return

//The following values are loaded into RAM $6E00 thru $6E9F in InitBank0
//routine.  These values are then loaded into sprite RAM at $0260 thru $02FF
//in above routine.  They are the stars in the title screen.

def introstarsdata:

    byte: 0x73, 0xcc, 0x22, 0xf2, 0x48, 0xcd, 0x63, 0xee, 0x2a, 0xce, 0xa2, 0xdc, 0x36, 0xcf, 0xe2, 0xc6
    byte: 0x11, 0xcc, 0x23, 0xb7, 0x53, 0xcd, 0x63, 0xa0, 0xbb, 0xce, 0xa2, 0x9a, 0xf, 0xcf, 0xe2, 0x8b
    byte: 0x85, 0xcc, 0xe2, 0x70, 0x9d, 0xcd, 0xa3, 0x6b, 0xa0, 0xce, 0x63, 0x58, 0x63, 0xcf, 0x23, 0x4f
    byte: 0xa, 0xcc, 0x22, 0x39, 0x1f, 0xcd, 0x23, 0x2a, 0x7f, 0xce, 0xa3, 0x1f, 0x56, 0xcf, 0xa2, 0x3
    byte: 0x4d, 0xcc, 0xe3, 0xaf, 0x3e, 0xcd, 0x63, 0x2b, 0x61, 0xce, 0xe2, 0x4f, 0x29, 0xcf, 0x62, 0x6f
    byte: 0x8a, 0xcc, 0x23, 0x82, 0x98, 0xcd, 0xa3, 0x7, 0xae, 0xce, 0xe2, 0xca, 0xb6, 0xcf, 0x63, 0xe3
    byte: 0xf, 0xcc, 0x62, 0x18, 0x1f, 0xcd, 0x22, 0x38, 0x22, 0xce, 0xa3, 0x5f, 0x53, 0xcf, 0xe2, 0x78
    byte: 0x48, 0xcc, 0xe3, 0x94, 0x37, 0xcd, 0xa3, 0xb3, 0x6f, 0xce, 0xa3, 0xdc, 0x78, 0xcf, 0x22, 0xfe
    byte: 0x83, 0xcc, 0x62, 0xb, 0x9f, 0xcd, 0x23, 0x26, 0xa0, 0xce, 0x62, 0x39, 0xbd, 0xcf, 0xa2, 0x1c
    byte: 0x7, 0xcc, 0xe3, 0xa4, 0x87, 0xcd, 0x63, 0x5d, 0x5a, 0xce, 0x62, 0x4f, 0x38, 0xcf, 0x23, 0x85

//Not used.
    byte: 0x3f, 0x0, 0x20, 0x2, 0x20, 0x1b, 0x3a, 0x2, 0x20, 0x21, 0x1, 0x2, 0x2c, 0x30, 0x27, 0x2
    byte: 0x26, 0x31, 0x17, 0x2, 0x16, 0x19, 0x27, 0x2, 0x16, 0x20, 0x27, 0x2, 0x16, 0x20, 0x11, 0x2
    byte: 0x1, 0x20, 0x21, 0x0

    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x8c
    //PPU string length.
    byte: 0x5
//             'S    T    A    R    T'
    byte: 0x1c, 0x1d, 0xa, 0x1b, 0x1d

    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xec
    //PPU string length.
    byte: 0x8
//             'C    O    N    T    I    N    U    E'
    byte: 0xc, 0x18, 0x17, 0x1d, 0x12, 0x17, 0x1e, 0xe

    //End PPU string write
    byte: 0x0

//The following pointer table is used to find the start
//of each row on the password screen in the data below.

def passwordrowtbl:

    //($99A2)
    word: passwordrow0
    //($99AF)
    word: passwordrow1
    //($99BC)
    word: passwordrow2
    //($99C9)
    word: passwordrow3
    //($99D6)
    word: passwordrow4

//The following data is used to load the name table With the password characters:
def passwordrow0:

    //0
    byte: 0x0
    //1
    byte: 0x1
    //2
    byte: 0x2
    //3
    byte: 0x3
    //4
    byte: 0x4
    //5
    byte: 0x5
    //6
    byte: 0x6
    //7
    byte: 0x7
    //8
    byte: 0x8
    //9
    byte: 0x9
    //A
    byte: 0xa
    //B
    byte: 0xb
    //C
    byte: 0xc

def passwordrow1:

    //D
    byte: 0xd
    //E
    byte: 0xe
    //F
    byte: 0xf
    //G
    byte: 0x10
    //H
    byte: 0x11
    //I
    byte: 0x12
    //J
    byte: 0x13
    //K
    byte: 0x14
    //L
    byte: 0x15
    //M
    byte: 0x16
    //N
    byte: 0x17
    //O
    byte: 0x18
    //P
    byte: 0x19

def passwordrow2:

    //Q
    byte: 0x1a
    //R
    byte: 0x1b
    //S
    byte: 0x1c
    //T
    byte: 0x1d
    //U
    byte: 0x1e
    //V
    byte: 0x1f
    //W
    byte: 0x20
    //X
    byte: 0x21
    //Y
    byte: 0x22
    //Z
    byte: 0x23
    //a
    byte: 0x24
    //b
    byte: 0x25
    //c
    byte: 0x26

def passwordrow3:

    //d
    byte: 0x27
    //e
    byte: 0x28
    //f
    byte: 0x29
    //g
    byte: 0x2a
    //h
    byte: 0x2b
    //i
    byte: 0x2c
    //j
    byte: 0x2d
    //k
    byte: 0x2e
    //l
    byte: 0x2f
    //m
    byte: 0x30
    //n
    byte: 0x31
    //o
    byte: 0x32
    //p
    byte: 0x33

def passwordrow4:

    //q
    byte: 0x34
    //r
    byte: 0x35
    //s
    byte: 0x36
    //t
    byte: 0x37
    //u
    byte: 0x38
    //v
    byte: 0x39
    //w
    byte: 0x3a
    //x
    byte: 0x3b
    //y
    byte: 0x3c
    //z
    byte: 0x3d
    //?
    byte: 0x3e
    //-
    byte: 0x3f
    //Space
    byte: 0xff

//Writes 'PASSWORD PLEASE' on name table 0 in row $2080 (5th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x88
    //PPU string length.
    byte: 0x10
//             'P    A    S    S    _    W    O    R    D    _    P    L    E    A    S    E'
    byte: 0x19, 0xa, 0x1c, 0x1c, 0xff, 0x20, 0x18, 0x1b, 0xd, 0xff, 0x19, 0x15, 0xe, 0xa, 0x1c, 0xe

//Clears attribute table 0 starting at address $23C0.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xc0
    //PPU string length.
    byte: 0x50
    //Repeat bit set. Repeats entry 16 times.
    byte: 0x0

//Writes to attribute table 0 starting at address $23D0.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xd0
    //PPU string length.
    byte: 0x48
    //Repeat bit set. Repeats entry 8 times.
    byte: 0x55

//Writes to attribute table 0 starting at address $23D8.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xd8
    //PPU string length.
    byte: 0x60
    //Repeat bit set. Repeats entry 32 times.
    byte: 0xff

//Writes to attribute table 0 starting at address $23DA.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xda
    //PPU string length.
    byte: 0x44
    //Repeat bit set. Repeats entry 4 times.
    byte: 0xf0

    //End PPU string write.
    byte: 0x0

//----------------------------------------[ Ending routines ]-----------------------------------------

//The following routine is accessed via the NMI routine every frame.
def nmiscreenwrite:

    a = [titleroutine]
    //If titleRoutine not at end game, exit.
    compare a to 0x1d
    goto exit100 when ~carry
    //($9C45)Display end credits on screen.
    call loadcredits
    a = [endmsgwrite]
    //If not time to write end message, branch
    goto _0093 when zero
    compare a to 0x5
    //If end message is finished being written, branch
    goto _0093 when carry
    a = a << 1
    y = a
    //Writes the end message on name table 0
    x = [endmessagestringtbl0-2:y]
    a = [endmessagestringtbl0-1:y]
    y = a
    //($C20E)Prepare to write to PPU.
    call prepareppuprocess_
def _0093:
    a = [hideshowendmsg]
    //If not time to erase end message, branch
    goto exit100 when zero
    compare a to 0x5
    //If end message is finished being erased, branch
    goto exit100 when carry
    a = a << 1
    y = a
    //Erases the end message on name table 0
    x = [endmessagestringtbl1-2:y]
    a = [endmessagestringtbl1-1:y]
    y = a
    //($C20E)Prepare to write to PPU.
    goto prepareppuprocess_

def exit100:

    //Exit from above and below routines.
    return
 
def restart:

    a = [joy1.status]
    //If start has not been pressed, branch to exit.
    a = a & 0x10
    goto exit100 when zero
    y = 0x11
    a = 0x0
def _0094:
    //Erase PasswordByte00 thru PasswordByte11.
    [passwordbyte00:y] = a
    y--
    goto _0094 when ~negative
    //Y = #$00.
    y++
def _0095:
    [uniqueitemhistory:y] = a
    //Erase Unique item history.
    y++
    goto _0095 when ~zero
    a = [samusgear]
    a = a & 0x10
    //If Samus does not have Maru Mari, branch.-->
    goto _0096 when zero
    //Else load Maru Mari data into PasswordByte00.
    a = 0x1
    [passwordbyte00] = a
def _0096:
    a = [samusgear]
    a = a & 0x1
    //If Samus does not have bombs, branch.-->
    goto _0097 when zero
    //Else load bomb data into PasswordByte00.
    a = [passwordbyte00]
    a = a | 0x40
    [passwordbyte00] = a
def _0097:
    a = [samusgear]
    a = a & 0x20
    //If Samus does not have varia suit, branch.-->
    goto _0098 when zero
    //Else load varia suit data into PasswordByte01.
    a = 0x8
    [passwordbyte01] = a
def _0098:
    a = [samusgear]
    a = a & 0x2
    //If Samus does not have high jump, branch.-->
    goto _0099 when zero
    //Else load high jump data into PasswordByte03.
    a = 0x1
    [passwordbyte03] = a
def _0099:
    a = [samusgear]
    //If Samus does not have Maru Mari, branch.-->
    a = a & 0x10
    //Else load screw attack data into PasswordByte03.-->
    goto _009A when zero
    //A programmer error?  Should check for screw-->
    a = [passwordbyte03]
    //attack data.
    a = a | 0x4
    [passwordbyte03] = a
def _009A:
    a = [samusgear]
    //Store Samus gear data in PasswordByte09.
    [passwordbyte09] = a
    a = 0x0
    y = [justinbailey]
    //If Samus is wearing suit, branch.  Else-->
    goto _009B when zero
    //load suitless Samus data into PasswordByte08.
    a = 0x80
def _009B:
    [passwordbyte08] = a
    //($92D4)Clear RAM to restart game at beginning.
    goto initializegame

def endgame:

    //($9EAA)Load stars in end scene onto screen.
    call loadendstarsprites
    //Skips palette change when rolling credits.
    a = [iscredits]
    goto _009C when ~zero
    a = [framecount]
    //Changes star palettes every 16th frame.
    a = a & 0xf
    goto _009C when ~zero
    [video.palette_pending]++
    //Reset palette data to #$01 after it-->
    a = [video.palette_pending]
    //reaches #$09.
    compare a to 0x9
    goto _009C when ~zero
    a = 0x1
    [video.palette_pending] = a
def _009C:
    //RoomPtr used in end of game to determine-->
    a = [roomptr]
    //($C27C)which subroutine to run below.
    call choose_routine

    //($9AD5)Load end GFX to pattern tables.
    word: loadendgfx
    //($9B1C)Show Samus and end message.
    word: showendsamus
    //($9B34)Samus flashes and changes.
    word: endsamusflash
    //($9B93)Samus waving in ending if suitless.
    word: samuswave
    //($9BCD)Fade out Samus in ending.
    word: endfadeout
    //($9BFC)Rolls ending credits.
    word: rollcredits
    //($9A39)Starts at beginning after game completed.
    word: restart
    //($C45C)Rts.
    word: exitsub

def loadendgfx:

    //($909F)Turn off screen, erase sprites and nametables.
    call clearall
    //($C5D0)Prepare to load end GFX.
    call initendgfx
    a = 0x4
    //Checks if game was played as suitless-->
    y = [justinbailey]
    //Samus.  If so, branch.
    goto _009D when ~zero
    //Loads SpritePointerIndex with #$00(suit on).
    a = 0x0
def _009D:
    [endingtype] = a
    //Loads SpritePointerIndex with #$08(suitless).
    a = a << 1
    [spritepointerindex] = a
    //Loads the screen where Samus stands on-->
    x = 0x52
    //the surface of the planet in end of game.
    y = 0xa0
    //($C20E)Prepare to write to PPU.
    call prepareppuprocess_
    //($C487)Turn on non-maskable interrupt.
    call nmion
    //Initiate end game music.
    a = 0x20
    [multisfxflag] = a
    //Loads Timer3 with a delay of 960 frames-->
    a = 0x60
    //(16 seconds).
    [timer3] = a
    //#$36/#$03 = #$12.  Number of sprites-->
    a = 0x36
    //used to draw end graphic of Samus.
    [spritebytecounter] = a
    a = 0x0
    [spriteattribbyte] = a
    [colorcntindex] = a
    //The following values are-->
    [iscredits] = a
    //initialized to #$00.
    [endmsgwrite] = a
    [hideshowendmsg] = a
    [creditpagenumber] = a
    a = 0x1
    //Change palette.
    [video.palette_pending] = a
    a = 0x8
    //Initialize ClrChangeCounter with #$08.
    [clrchangecounter] = a
    [roomptr]++
    //($C447)Turn screen on.
    goto screenon

def showendsamus:

    //($9C9A)Load end image of Samus.
    call loadendsamussprites
    //Once 960 frames (16 seconds) have expired,-->
    a = [timer3]
    //Move to EndSamusFlash routine.
    goto _009E when ~zero
    [roomptr]++
    return

def _009E:
    //After 160 frames have past-->
    compare a to 0x50
    //(2.6 seconds), write end message.
    goto _009F when ~zero
    [endmsgwrite]++
    return
def _009F:
    //After 950 frames have past-->
    compare a to 0x1
    //(15.8 seconds), erase end message.
    goto _00A0 when ~zero
    [hideshowendmsg]++
def _00A0:
    return

def endsamusflash:

    //If FrameCount not divisible by 32, branch.
    a = [framecount]
    a = a & 0x1f
    goto _00A3 when ~zero
    //Every 32 frame, increment the ColorCntInex-->
    [colorcntindex]++
    //value.  Flashing Samus lasts for 512-->
    a = [colorcntindex]
    //frames (8.5 seconds).
    compare a to 0x8
    goto _00A1 when ~zero
    //($CAF5)Choose which Samus ending to show.
    call chooseending
    //($8C7A)Calculate game password.
    call calculatepassword
    a = [endingtype]
    //When EndSamusFlash routine is half way-->
    a = a << 1
    //done, this code will calculate the-->
    [spritepointerindex] = a
    //password and choose the proper ending.
    a = 0x36
    [spritebytecounter] = a
def _00A1:
    compare a to 0x10
    //Once flashing Samus is compete, set Timer3-->
    goto _00A3 when ~zero
    //for a 160 frame(2.6 seconds) delay.
    [timer3] = a
    y = 0x0
    a = [endingtype]
    //If one of the suitless Samus endings,-->
    compare a to 0x4
    //increment sprite color for proper-->
    goto _00A2 when ~carry
    //color to be displayed and increment-->
    y++
def _00A2:
    //RoomPtr and erase the sprites.
    [spriteattribbyte] = y
    [roomptr]++
    //($C1A3)Clear all sprites off the screen.
    goto clear_all_sprites
def _00A3:
    //Decrement ClrChangeCounter.
    [clrchangecounter]--
    goto _00A4 when ~zero
    y = [colorcntindex]
    //When ClrChangeCounter=#$00, fetch new-->
    a = [palchangetable:y]
    //ClrChangeCounter value. and increment-->
    [clrchangecounter] = a
    //sprite color.
    [spriteattribbyte]++
    a = [spriteattribbyte]
    compare a to 0x3
    goto _00A4 when ~zero
    //If sprite color=#$03, set sprite-->
    a = 0x0
    //color to #$00.
    [spriteattribbyte] = a
def _00A4:
    //($9C9A)Load end image of Samus.
    goto loadendsamussprites

//The following table is used by the above routine to load ClrChangeCounter.  ClrChangeCounter
//decrements every frame, When ClrChangeCounter reaches zero, the sprite colors for Samus
//changes.  This has the effect of making Samus flash.  The flashing starts slow, speeds up,
//then slows down again.
def palchangetable:

    byte: 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8
 
def samuswave:

    //If 160 frame timer from previous routine-->
    a = [timer3]
    //has not expired, branch(waves for 2.6 seconds).
    goto _00A5 when ~zero
    a = 0x10
    //Load Timer3 with 160 frame delay-->
    [timer3] = a
    //(2.6 seconds).
    a = 0x8
    //Change palette
    [video.palette_pending] = a
    //Increment RoomPtr
    [roomptr]++
    return

def _00A5:
    //If suitless Samus-->
    a = [endingtype]
    //ending, branch.
    compare a to 0x4
    goto _00A6 when carry
    //($9C9A)
    goto loadendsamussprites
def _00A6:
    //If jumpsuit Samus ending,-->
    a = a -# 0x4
    //WaveSpritePointer=#$00, if bikini-->
    a = a << 1
    //Samus ending, WaveSpritePointer=#$04.
    a = a << 1
    [wavespritepointer] = a
    a = [framecount]
    //Every eigth frame count, change wave sprite data.
    a = a & 0x8
    goto _00A7 when ~zero
    //Load WaveSpriteCounter with #$10(16 bytes of-->
    y = 0x10
    //sprite data to be loaded).
    [wavespritecounter] = y
    //Branch always.
    goto _00A8 when ~zero
def _00A7:
    [wavespritepointer]++
    //When bit 3 of FrameCount is not set,-->
    [wavespritepointer]++
    //Samus' waving hand is down.
    y = 0x10
    [wavespritecounter] = y
def _00A8:
    //Load SpriteByteCounter in preparation for-->
    a = 0x2d
    //refreshing Samus sprite bytes.
    [spritebytecounter] = a
    //($9C7F)Load sprites for waving Samus.
    goto loadwavesprites

def endfadeout:

    //If 160 frame delay from last routine has not-->
    a = [timer3]
    //yet expired, branch.
    goto _00AA when ~zero
    a = [iscredits]
    //Branch always.
    goto _00A9 when ~zero

    //*This code does not appear to be used.
    a = 0x8
    //*Change palette.
    [video.palette_pending] = a
    //*Increment IsCredits.
    [iscredits]++

def _00A9:
    a = [framecount]
    //Every seventh frame, increment the palette info-->
    a = a & 0x7
    //If PalDataPending is not equal to #$0C, keep-->
    goto _00AA when ~zero
    //incrementing every seventh frame until it does.-->
    [video.palette_pending]++
    //This creates the fade out effect.
    a = [video.palette_pending]
    compare a to 0xc
    goto _00AA when ~zero
    //After fadeout complete, load Timer3 with 160 frame-->
    a = 0x10
    //delay(2.6 seconds) and increment RoomPtr.
    [timer3] = a
    [roomptr]++
def _00AA:
    a = [endingtype]
    //If suitless Samus ending, load hand wave sprites,-->
    compare a to 0x4
    //else just load regular Samus sprites
    goto _00AB when carry
    //($9C9A)Load end image of Samus.
    goto loadendsamussprites
def _00AB:
    //($9C7F)Load sprites for waving Samus.
    goto loadwavesprites

def rollcredits:

    //If 160 frame timer delay from previous-->
    a = [timer3]
    //routine has expired, branch.
    goto _00AC when zero
    //If not 20 frames left in Timer3, branch to exit.
    compare a to 0x2
    goto _00AF when ~zero
    //($C439)When 20 frames left in Timer3,-->
    call screenoff
    //($C16D)clear name table 0 and sprites.-->
    call clear_nametable_0
    //($C1A3)prepares screen for credits.
    call clear_all_sprites
    a = 0xd
    //Change to proper palette for credits.
    [video.palette_pending] = a
    //($C447)Turn screen on.
    call screenon
    //($C43F)Wait for NMI to end.
    goto waitnmipass_
def _00AC:
    //If first page of credits has not started to-->
    a = [creditpagenumber]
    //roll, start it now, else branch.
    goto _00AD when ~zero
    [creditpagenumber]++
def _00AD:
    //If not at last page of credits, branch.
    compare a to 0x6
    goto _00AE when ~zero
    a = [scroll.y]
    //If last page of credits is not finished-->
    compare a to 0x88
    //scrolling, branch.  Else increment to next-->
    goto _00AE when ~carry
    //routine.
    [roomptr]++
    return

def _00AE:
    //credits scroll up one position every 3 frames.
    a = [framecount]
    a = a & 0x3
    //Ready to scroll? If not, branch.
    goto _00AF when ~zero
    [scroll.y]++
    //Load ScrollY and check it to see if its-->
    a = [scroll.y]
    //position is at the very bottom on name table.-->
    compare a to 0xf0
    //if not, branch.
    goto _00AF when ~zero
    [creditpagenumber]++
    a = 0x0
    //When Scrolly is at bottom of the name table,-->
    [scroll.y] = a
    //Swap to next name table(0 or 2) and increment-->
    a = [video.ctrl]
    //CreditPageNumber.
    a = a ^ 0x2
    [video.ctrl] = a
def _00AF:
    return

//The following routine is checked every frame and is accessed via the NMIScreenWrite routine.
//The LoadCredits routine works like this: The Y scroll position is checked every frame.  When
//it is in the first four positions of the current name table (0, 1, 2 or 3), or the four
//positions right after 127 (128, 129, 130 and 131), the routine will then load the ending
//credits into the positions on the name table that were just scrolled over.  For example, If
//the scroll window is currently half way down name table 0, the LoadCredits routine will load
//the contents of the upper half of name table 0.  Also, name table 0 contains odd numbered
//pages and name table 2 contains even numbered pages.

def loadcredits:

    y = [creditpagenumber]
    //If credits are not being displayed, exit.
    goto _00B3 when zero
    compare y to 0x7
    //If CreditPageNumber is higher than #$06, exit.
    goto _00B3 when carry
    x = 0x0
    //If ScrollY is less than #$80 (128), branch.
    a = [scroll.y]
    goto _00B0 when ~negative
    //Load X with sign bit (#$01) and remove-->
    x++
    //sign bit from A.
    carry = 1
    a = a -# 0x80
def _00B0:
    compare a to 0x4
    //If ScrollY is not #$04, branch to exit.
    goto _00B3 when carry
    //Store #$00, #$01, #$02 or #$03 in address $01.
    [0x1] = a
    //Y now contains CreditPageNumber - 1.
    y--
    a = x
    //If ScrollY is #$80 (128) or greater, branch.
    goto _00B1 when ~zero
    //Y now contains CreditPageNumber - 2.
    y--
    //If on Credit page less than two , branch to exit.
    goto _00B3 when negative
    a = y
    //Start with CreditPageNumber - 2-->
    a = a << 1
    //* 8 + 4 + $01 * 2.
    a = a << 1
    //This formula is used when ScrollY = 0, 1, 2 and 3.
    a = a << 1
    //Result is index to find proper credits to load.
    a = a +# 0x4
    //Branch always.
    goto _00B2 when ~zero
def _00B1:
    a = y
    //Start with CreditPageNumber - 1-->
    a = a << 1
    //* 8 + $01 * 2.
    a = a << 1
    //This formula is used when ScrollY = 128,-->
    a = a << 1
def _00B2:
    //129, 130 and 131.
    a = a +# [0x1]
    //Result is index to find proper credits to load.
    a = a << 1
    y = a
    //Base is $A291. Lower byte of pointer to PPU string.
    x = [creditspointertbl:y]
    //Upper byte of pointer to PPU string.
    a = [creditspointertbl+1:y]
    y = a
    //($C20E)Prepare to write to PPU.
    goto prepareppuprocess_
def _00B3:
    return
 
def loadwavesprites:

    x = [wavespritepointer]
    a = [wavepointertable:x]
    //Load pointer to wave sprite data-->
    [0x0] = a
    //into addresses $00 and $01.
    a = [wavepointertable+1:x]
    [0x1] = a
    //Offset for sprite RAM load.
    x = 0x20
    y = 0x0
def _00B4:
    a = [[0x0]:y]
    //Load wave sprites into sprite RAM starting at-->
    [sprite00ram:x] = a
    //location $220 (Sprite08RAM).
    x++
    y++
    //Check to see if sprite RAM load complete.-->
    compare y to [wavespritecounter]
    //If not, branch and load another byte.
    goto _00B4 when ~zero

def loadendsamussprites:

    //Index for loading Samus sprite data into sprite RAM.
    x = 0x30
    y = [spritepointerindex]
    //Base is $9D5A.
    a = [endsamusaddrtbl:y]
    //Load $00 and $01 with pointer to the sprite-->
    [0x0] = a
    //data that shows Samus at the end of the game.
    a = [endsamusaddrtbl+1:y]
    [0x1] = a
    y = 0x0
def _00B5:
    //Load sprite data starting at Sprite0CRAM.
    a = [[0x0]:y]
    //Load sprite Y-coord.
    [sprite00ram:x] = a
    x++
    //Increment X and Y.
    y++
    a = [[0x0]:y]
    //If sprite pattern byte MSB cleared, branch.
    goto _00B6 when ~negative
    a = a & 0x7f
    //Remove MSB and write sprite pattern data-->
    [sprite00ram:x] = a
    //to sprite RAM.
    a = [spriteattribbyte]
    a = a ^ 0x40
    goto _00B7 when ~zero
def _00B6:
    //Writes sprite pattern byte to-->
    [sprite00ram:x] = a
    //sprite RAM if its MSB is not set.
    a = [spriteattribbyte]
def _00B7:
    x++
    //Writes sprite attribute byte to sprite RAM.
    [sprite00ram:x] = a
    y++
    //Increment X and Y.
    x++
    a = [[0x0]:y]
    //Load sprite X-coord.
    [sprite00ram:x] = a
    y++
    //Increment X and Y.
    x++
    compare y to [spritebytecounter]
    //Repeat until sprite load is complete.
    goto _00B5 when ~zero
    a = [roomptr]
    //If not running the EndSamusFlash routine, branch.
    compare a to 0x2
    goto _00B9 when ~carry
    a = [colorcntindex]
    //If EndSamusFlash routine is more than half-->
    compare a to 0x8
    //way done, Check ending type for the Samus helmet-->
    goto _00B9 when ~carry
    //off ending.  If not helmet off ending, branch.
    a = [endingtype]
    compare a to 0x3
    goto _00B9 when ~zero
    y = 0x0
    x = 0x0
def _00B8:
    //The following code loads the sprite graphics-->
    a = [samusheadspritetble:y]
    //when the helmet off ending is playing.  The-->
    [sprite00ram:x] = a
    //sprites below keep Samus head from flashing-->
    y++
    //while the rest of her body does.
    x++
    compare y to 0x18
    goto _00B8 when ~zero
def _00B9:
    return
 
//The following table is used by the routine above to keep Samus'
//head from flashing during the helmet off ending.

def samusheadspritetble:

    //Sprite00RAM
    byte: 0x93, 0x36, 0x1, 0x70
    //Sprite01RAM
    byte: 0x93, 0x37, 0x1, 0x78
    //Sprite02RAM
    byte: 0x93, 0x38, 0x1, 0x80
    //Sprite03RAM
    byte: 0x9b, 0x46, 0x1, 0x70
    //Sprite04RAM
    byte: 0x9b, 0x47, 0x1, 0x78
    //Sprite05RAM
    byte: 0x9b, 0x48, 0x1, 0x80

//The following table is a pointer table to the sprites that makes Samus wave in the end
//of the game when she is suitless.  The top two pointers are for when she is in the jumpsuit
//and the bottom two pointers are for when she is in the bikini.

def wavepointertable:

    //Jumpsuit Samus hand up.
    word: title_page_9D1A
    //Jumpsuit Samus hand down.
    word: title_page_9D2A
    //Bikini Samus hand up.
    word: title_page_9D3A
    //Bikini Samus hand down.
    word: title_page_9D4A

//Sprite data table used when Samus is in jumpsuit and her waving hand is up.
def jshanduptable:

def title_page_9D1A:
    byte: 0x9b, 0x1f, 0x1, 0x80, 0xa3, 0x2f, 0x1, 0x80, 0xab, 0x3f, 0x1, 0x80, 0xf4, 0x3f, 0x1, 0x80

//Sprite data table used when Samus is in jumpsuit and her waving hand is down.
def jshanddowntable:

def title_page_9D2A:
    byte: 0x9b, 0x2a, 0x1, 0x80, 0x9b, 0x2b, 0x1, 0x88, 0xa3, 0x3a, 0x1, 0x80, 0xab, 0x3f, 0x1, 0x80

//Sprite data table used when Samus is in bikini and her waving hand is up.
def bkhanduptable:

def title_page_9D3A:
    byte: 0x9b, 0xc, 0x1, 0x80, 0xa3, 0x1c, 0x1, 0x80, 0xab, 0x3f, 0x1, 0x80, 0xf4, 0x3f, 0x1, 0x80

//Sprite data table used when Samus is in bikini and her waving hand is down.
def bkhanddowntable:

def title_page_9D4A:
    byte: 0x9b, 0x4a, 0x1, 0x80, 0x9b, 0x4b, 0x1, 0x88, 0xa3, 0x4d, 0x1, 0x80, 0xab, 0x3f, 0x1, 0x80

def endsamusaddrtbl:

    //($9D66)Pointer to end graphic of Samus wearing suit.
    word: normalsamus
    //($9D9C)Pointer to end graphic of back turned Samus.
    word: backturnedsamus
    //($9DD2)Pointer to end graphic of fist raised Samus.
    word: fistraisedsamus
    //($9E08)Pointer to end graphic of helmet off Samus.
    word: helmetoffsamus
    //($9E3E)Pointer to end graphic of jumpsuit Samus.
    word: jumpsuitsamus
    //($9E74)Pointer to end graphic of bikini Samus.
    word: bikinisamus

//The following three bytes are loaded into sprite RAM.  The third byte (attribute byte) is
//not included.  Instead, if the MSB of the second byte (pattern byte) is set, the pattern
//byte is flipped horizontally (mirror image).  If pattern byte MSB is not set, the attribute
//byte is stored as #$00.  This is done so the code can generate the flashing Samus effect at
//the end of the game.

def normalsamus:

    byte: 0x93, 0x0, 0x70
    byte: 0x93, 0x1, 0x78
    //Mirrored pattern at pattern table location $00.
    byte: 0x93, 0x80, 0x80
    byte: 0x9b, 0x10, 0x70
    byte: 0x9b, 0x11, 0x78
    //Mirrored pattern at pattern table location $10.
    byte: 0x9b, 0x90, 0x80
    byte: 0xa3, 0x20, 0x70
    byte: 0xa3, 0x21, 0x78
    byte: 0xa3, 0x22, 0x80
    byte: 0xab, 0x30, 0x70
    byte: 0xab, 0x31, 0x78
    byte: 0xab, 0x32, 0x80
    byte: 0xb3, 0x40, 0x70
    byte: 0xb3, 0x41, 0x78
    byte: 0xb3, 0xc0, 0x80
    byte: 0xbb, 0x50, 0x70
    byte: 0xbb, 0x49, 0x78
    //Mirrored pattern at pattern table location $50.
    byte: 0xbb, 0xd0, 0x80

def backturnedsamus:

    byte: 0x93, 0x2, 0x70
    byte: 0x93, 0x3, 0x78
    byte: 0x93, 0x4, 0x80
    byte: 0x9b, 0x12, 0x70
    byte: 0x9b, 0x13, 0x78
    byte: 0x9b, 0x14, 0x80
    byte: 0xa3, 0x5, 0x70
    byte: 0xa3, 0x6, 0x78
    byte: 0xa3, 0x7, 0x80
    byte: 0xab, 0x15, 0x70
    byte: 0xab, 0x16, 0x78
    byte: 0xab, 0x17, 0x80
    byte: 0xb3, 0x8, 0x70
    byte: 0xb3, 0x9, 0x78
    //Mirrored pattern at pattern table location $08.
    byte: 0xb3, 0x88, 0x80
    byte: 0xbb, 0x18, 0x70
    byte: 0xbb, 0x19, 0x78
    //Mirrored pattern at pattern table location $18.
    byte: 0xbb, 0x98, 0x80

def fistraisedsamus:

    byte: 0x93, 0x0, 0x70
    byte: 0x93, 0x1, 0x78
    byte: 0x93, 0x34, 0x80
    byte: 0x9b, 0x10, 0x70
    byte: 0x9b, 0x11, 0x78
    byte: 0x9b, 0x44, 0x80
    byte: 0xa3, 0x20, 0x70
    byte: 0xa3, 0x21, 0x78
    byte: 0xa3, 0x33, 0x80
    byte: 0xab, 0x30, 0x70
    byte: 0xab, 0x31, 0x78
    byte: 0xab, 0x43, 0x80
    byte: 0xb3, 0x40, 0x70
    byte: 0xb3, 0x41, 0x78
    //Mirrored pattern at pattern table location $40.
    byte: 0xb3, 0xc0, 0x80
    byte: 0xbb, 0x50, 0x70
    byte: 0xbb, 0x49, 0x78
    //Mirrored pattern at pattern table location $50.
    byte: 0xbb, 0xd0, 0x80

def helmetoffsamus:

    byte: 0x93, 0xd, 0x70
    byte: 0x93, 0xe, 0x78
    byte: 0x93, 0xf, 0x80
    byte: 0x9b, 0x35, 0x70
    byte: 0x9b, 0x27, 0x78
    byte: 0x9b, 0x28, 0x80
    byte: 0xa3, 0x20, 0x70
    byte: 0xa3, 0x21, 0x78
    byte: 0xa3, 0x22, 0x80
    byte: 0xab, 0x30, 0x70
    byte: 0xab, 0x31, 0x78
    byte: 0xab, 0x32, 0x80
    byte: 0xb3, 0x40, 0x70
    byte: 0xb3, 0x41, 0x78
    //Mirrored pattern at pattern table location $40.
    byte: 0xb3, 0xc0, 0x80
    byte: 0xbb, 0x50, 0x70
    byte: 0xbb, 0x49, 0x78
    //Mirrored pattern at pattern table location $50.
    byte: 0xbb, 0xd0, 0x80

def jumpsuitsamus:

    byte: 0x93, 0xd, 0x70
    byte: 0x93, 0xe, 0x78
    byte: 0x93, 0xf, 0x80
    byte: 0x9b, 0x1d, 0x70
    byte: 0x9b, 0x1e, 0x78
    byte: 0xa3, 0x2d, 0x70
    byte: 0xa3, 0x2e, 0x78
    byte: 0xab, 0x3d, 0x70
    byte: 0xab, 0x3e, 0x78
    byte: 0xb3, 0x8, 0x70
    byte: 0xb3, 0x4e, 0x78
    byte: 0xb3, 0x4f, 0x80
    byte: 0xbb, 0x45, 0x70
    byte: 0xbb, 0x3b, 0x78
    byte: 0xbb, 0x51, 0x80
    byte: 0x9b, 0x29, 0x80
    byte: 0xa3, 0x39, 0x80
    byte: 0xab, 0x4c, 0x80

def bikinisamus:

    byte: 0x93, 0xd, 0x70
    byte: 0x93, 0xe, 0x78
    byte: 0x93, 0xf, 0x80
    byte: 0x9b, 0xa, 0x70
    byte: 0x9b, 0xb, 0x78
    byte: 0xa3, 0x1a, 0x70
    byte: 0xa3, 0x1b, 0x78
    byte: 0xab, 0x3d, 0x70
    byte: 0xab, 0x3e, 0x78
    byte: 0xb3, 0x8, 0x70
    byte: 0xb3, 0x4e, 0x78
    byte: 0xb3, 0x4f, 0x80
    byte: 0xbb, 0x45, 0x70
    byte: 0xbb, 0x3b, 0x78
    byte: 0xbb, 0x51, 0x80
    byte: 0x9b, 0x2c, 0x80
    byte: 0xa3, 0x3c, 0x80
    byte: 0xab, 0x4c, 0x80

def loadendstarsprites:

    y = 0x0
def _00BA:
    a = [endstardatatable:y]
    //Load the table below into sprite RAM-->
    [sprite1cram:y] = a
    //starting at address $0270.
    y++
    compare y to 0x9c
    goto _00BA when ~zero
    return

//Loaded into sprite RAM by routine above. Displays stars at the end of the game.

def endstardatatable:

    byte: 0x8, 0x23, 0x22, 0x10
    byte: 0x68, 0x23, 0x23, 0x60
    byte: 0x0, 0x23, 0x22, 0x60
    byte: 0x7f, 0x23, 0x23, 0x6a
    byte: 0x7f, 0x23, 0x22, 0xd4
    byte: 0x33, 0x23, 0x23, 0xb2
    byte: 0x93, 0x23, 0x22, 0x47
    byte: 0xb3, 0x23, 0x23, 0x95
    byte: 0xb, 0x23, 0x22, 0xe2
    byte: 0x1c, 0x23, 0x23, 0x34
    byte: 0x84, 0x23, 0x22, 0x18
    byte: 0xb2, 0x23, 0x23, 0xee
    byte: 0x40, 0x23, 0x22, 0x22
    byte: 0x5a, 0x23, 0x23, 0x68
    byte: 0x1a, 0x23, 0x22, 0x90
    byte: 0xaa, 0x23, 0x23, 0x22
    byte: 0x81, 0x24, 0x22, 0x88
    byte: 0x6a, 0x24, 0x23, 0xd0
    byte: 0xa8, 0x24, 0x22, 0xa0
    byte: 0x10, 0x24, 0x23, 0x70
    byte: 0x15, 0x25, 0x22, 0x42
    byte: 0x4a, 0x25, 0x23, 0x7d
    byte: 0x30, 0x25, 0x22, 0x50
    byte: 0x5a, 0x25, 0x23, 0x49
    byte: 0x50, 0x25, 0x22, 0xb9
    byte: 0x91, 0x25, 0x23, 0xb0
    byte: 0x19, 0x25, 0x22, 0xc0
    byte: 0x53, 0x25, 0x23, 0xba
    byte: 0xa4, 0x25, 0x22, 0xd6
    byte: 0x98, 0x25, 0x23, 0x1a
    byte: 0x68, 0x25, 0x22, 0xc
    byte: 0x97, 0x25, 0x23, 0xea
    byte: 0x33, 0x25, 0x22, 0x92
    byte: 0x43, 0x25, 0x23, 0x65
    byte: 0xac, 0x25, 0x22, 0x4a
    byte: 0x2a, 0x25, 0x23, 0x71
    byte: 0x7c, 0x26, 0x22, 0xb2
    byte: 0x73, 0x26, 0x23, 0xe7
    byte: 0xc, 0x26, 0x22, 0xaa

def endgamepalwrite:

    //If no palette data pending, branch to exit.
    a = [video.palette_pending]
    goto _00BC when zero
    //If PalDataPending has loaded last palette,-->
    compare a to 0xc
    //branch to exit.
    goto _00BC when zero
    //Once end palettes have been cycled through,-->
    compare a to 0xd
    //start over.
    goto _00BB when ~zero
    y = 0x0
    [video.palette_pending] = y
def _00BB:
    //* 2, pointer is two bytes.
    a = a << 1
    y = a
    //High byte of PPU data pointer.
    a = [endgamepalpntrtbl-1:y]
    //Low byte of PPU data pointer.
    x = [endgamepalpntrtbl-2:y]
    y = a
    //($C20E)Prepare to write data string to PPU.
    call prepareppuprocess_
    a = 0x3f
    [nes.ppu.address] = a
    a = 0x0
    //Set PPU address to $3F00.
    [nes.ppu.address] = a
    [nes.ppu.address] = a
    //Set PPU address to $0000.
    [nes.ppu.address] = a
def _00BC:
    return

//The following pointer table is used by the routine above to
//find the proper palette data during the EndGame routine.

def endgamepalpntrtbl:

    //($9F9B)
    word: endgamepal00
    //($9FBF)
    word: endgamepal01
    //($9FCB)
    word: endgamepal02
    //($9FD7)
    word: endgamepal03
    //($9FE3)
    word: endgamepal04
    //($9FEF)
    word: endgamepal05
    //($9FFB)
    word: endgamepal06
    //($A007)
    word: endgamepal07
    //($A013)
    word: endgamepal08
    //($A02E)
    word: endgamepal09
    //($A049)
    word: endgamepal0a
    //($A049)
    word: endgamepal0a
    //($9806)
    word: endgamepal0b

def endgamepal00:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x0
    //PPU string length.
    byte: 0x20
//The following values are written to the background palette:
    byte: 0xf, 0x21, 0x11, 0x2, 0xf, 0x29, 0x1b, 0x1a, 0xf, 0x27, 0x28, 0x29, 0xf, 0x28, 0x18, 0x8
//The following values are written to the sprite palette:
    byte: 0xf, 0x16, 0x19, 0x27, 0xf, 0x36, 0x15, 0x17, 0xf, 0x12, 0x21, 0x20, 0xf, 0x35, 0x12, 0x16

    //End EndGamePal00 data.
    byte: 0x0

def endgamepal01:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x10, 0x20, 0x30, 0xf, 0xf, 0xf, 0xf

    //End EndGamePal01 data.
    byte: 0x0

def endgamepal02:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x12, 0x22, 0x32, 0xf, 0xb, 0x1b, 0x2b

    //End EndGamePal02 data.
    byte: 0x0

def endgamepal03:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x14, 0x24, 0x34, 0xf, 0x9, 0x19, 0x29

    //End EndGamePal03 data.
    byte: 0x0

def endgamepal04:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x16, 0x26, 0x36, 0xf, 0x7, 0x17, 0x27

    //End EndGamePal04 data.
    byte: 0x0

def endgamepal05:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x18, 0x28, 0x38, 0xf, 0x5, 0x15, 0x25

    //End EndGamePal05 data.
    byte: 0x0

def endgamepal06:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x1a, 0x2a, 0x3a, 0xf, 0x3, 0x13, 0x13

    //End EndGamePal06 data.
    byte: 0x0

def endgamepal07:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x18
    //PPU string length.
    byte: 0x8
//The following values are written to the sprite palette starting at $3F18:
    byte: 0xf, 0x1c, 0x2c, 0x3c, 0xf, 0x1, 0x11, 0x21

    //End EndGamePal07 data.
    byte: 0x0

def endgamepal08:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0xc
    //PPU string length.
    byte: 0x4
//The following values are written to the background palette starting at $3F0C:
    byte: 0xf, 0x18, 0x8, 0x7

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x10
    //PPU string length.
    byte: 0x10
//The following values are written to the sprite palette:
    byte: 0xf, 0x26, 0x5, 0x7, 0xf, 0x26, 0x5, 0x7, 0xf, 0x1, 0x1, 0x5, 0xf, 0x13, 0x1c, 0xc

    //End EndGamePal08 data.
    byte: 0x0

def endgamepal09:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0xc
    //PPU string length.
    byte: 0x4
//The following values are written to the background palette starting at $3F0C:
    byte: 0xf, 0x8, 0x7, 0xf

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x10
    //PPU string length.
    byte: 0x10
//The following values are written to the sprite palette:
    byte: 0xf, 0x6, 0x8, 0xf, 0xf, 0x6, 0x8, 0xf, 0xf, 0x0, 0x10, 0xf, 0xf, 0x1, 0xc, 0xf

    //End EndGamePal09 data.
    byte: 0x0

def endgamepal0a:

    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0xc
    //PPU string length.
    byte: 0x44
    //Repeat bit set. Fill background palette with #$0F-->
    byte: 0xf
                    //starting at $0C.
    //PPU address high byte.
    byte: 0x3f
    //PPU address low byte.
    byte: 0x10
    //PPU string length.
    byte: 0x50
    //Repeat bit set. Fill sprite palette with #$0F.
    byte: 0xf

    //End EndGamePal0A data.
    byte: 0x0

//The following data writes the end game backgroud graphics.

//Writes ground graphics on name table 0 in row $2300 (25th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x0
    //PPU string length.
    byte: 0x20
    byte: 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31
    byte: 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31, 0x30, 0x31

//Writes ground graphics on name table 0 in row $2320 (26th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x20
    //PPU string length.
    byte: 0x20
    byte: 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33
    byte: 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33, 0x32, 0x33

//Writes ground graphics on name table 0 in row $2340 (27th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x40
    //PPU string length.
    byte: 0x20
    byte: 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35
    byte: 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35, 0x34, 0x35

//Writes ground graphics on name table 0 in row $2360 (28th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x60
    //PPU string length.
    byte: 0x20
    byte: 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37
    byte: 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37, 0x36, 0x37

//Writes ground graphics on name table 0 in row $2380 (29th row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x80
    //PPU string length.
    byte: 0x20
    byte: 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39
    byte: 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39, 0x38, 0x39

//Writes ground graphics on name table 0 in row $23A0 (bottom row).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xa0
    //PPU string length.
    byte: 0x20
    byte: 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b
    byte: 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b, 0x3a, 0x3b

//Sets all color bits in attribute table 0 starting at $23F0.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xf0
    //PPU string length.
    byte: 0x50
    //Repeat bit set. Repeats entry 16 times.
    byte: 0xff

//Writes credits on name table 2 in row $2820 (2nd row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0x2e
    //PPU string length.
    byte: 0x5
//             'S    T    A    F    F'
    byte: 0x1c, 0x1d, 0xa, 0xf, 0xf

//Writes credits on name table 2 in row $28A0 (6th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xa8
    //PPU string length.
    byte: 0x13
//             'S    C    E    N    A    R    I    O    _    W    R    I    T    T    E    N'
    byte: 0x1c, 0xc, 0xe, 0x17, 0xa, 0x1b, 0x12, 0x18, 0xff, 0x20, 0x1b, 0x12, 0x1d, 0x1d, 0xe, 0x17
//             '_    B    Y'
    byte: 0xff, 0xb, 0x22

//Writes credits on name table 2 in row $28E0 (8th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xee
    //PPU string length.
    byte: 0x5
//             'K    A    N    O    H'
    byte: 0x14, 0xa, 0x17, 0x18, 0x11

//Writes credits on name table 2 in row $2960 (12th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0x66
    //PPU string length.
    byte: 0x15
//             'C    H    A    R    A    C    T    E    R    _    D    E    S    I    G    N'
    byte: 0xc, 0x11, 0xa, 0x1b, 0xa, 0xc, 0x1d, 0xe, 0x1b, 0xff, 0xd, 0xe, 0x1c, 0x12, 0x10, 0x17
//             'E    D    _    B    Y'
    byte: 0xe, 0xd, 0xff, 0xb, 0x22

//Writes credits on name table 2 in row $29A0 (14th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0xac
    //PPU string length.
    byte: 0x8
//             'K    I    Y    O    T    A    K    E'
    byte: 0x14, 0x12, 0x22, 0x18, 0x1d, 0xa, 0x14, 0xe

//Writes credits on name table 2 in row $2A20 (18th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0x2b
    //PPU string length.
    byte: 0xc
//             'N    E    W    _    M    A    T    S    U    O    K    A'
    byte: 0x17, 0xe, 0x20, 0xff, 0x16, 0xa, 0x1d, 0x1c, 0x1e, 0x18, 0x14, 0xa

//Writes credits on name table 2 in row $2A60 (20th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0x6c
    //PPU string length.
    byte: 0x9
//             'S    H    I    K    A    M    O    T    O'
    byte: 0x1c, 0x11, 0x12, 0x14, 0xa, 0x16, 0x18, 0x1d, 0x18

//Writes credits on name table 2 in row $2AE0 (24th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0xec
    //PPU string length.
    byte: 0x8
//             'M    U    S    I    C    _    B    Y'
    byte: 0x16, 0x1e, 0x1c, 0x12, 0xc, 0xff, 0xb, 0x22

//Writes credits on name table 2 in row $2B20 (26th row from top)
    //PPU address high byte.
    byte: 0x2b
    //PPU address low byte.
    byte: 0x2b
    //PPU string length.
    byte: 0xa
//             'H    I    P    _    T    A    N    A    K    A'
    byte: 0x11, 0x12, 0x19, 0xff, 0x1d, 0xa, 0x17, 0xa, 0x14, 0xa

//Writes credits on name table 2 in row $2BA0 (bottom row).
    //PPU address high byte.
    byte: 0x2b
    //PPU address low byte.
    byte: 0xa7
    //PPU string length.
    byte: 0x12
//             '_    M    A    I    N    _    P    R    O    G    R    A    M    M    E    R'
    byte: 0xff, 0x16, 0xa, 0x12, 0x17, 0xff, 0x19, 0x1b, 0x18, 0x10, 0x1b, 0xa, 0x16, 0x16, 0xe, 0x1b
//             'S    _'
    byte: 0x1c, 0xff

    //End PPU string write.
    byte: 0x0

//The following pointer table is accessed by the NMIScreenWrite routine. 
//It is used to locate the start of the PPU strings below.

def endmessagestringtbl0:

    word: title_page_A1C2, 0xa1eb, 0xa20f, 0xa240

//Writes end message on name table 0 in row $2060 (4th row from top).
def title_page_A1C2:
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x6d
    //PPU string length.
    byte: 0x8
//             'G    R    E    A    T    _    !    !'
    byte: 0x10, 0x1b, 0xe, 0xa, 0x1d, 0xff, 0x3f, 0x3f

//Writes end message on name table 0 in row $20C0 (7th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0xc3
    //PPU string length.
    byte: 0x1a
//             'Y    O    U    _    F    U    L    F    I    L    E    D    _    Y    O    U'
    byte: 0x22, 0x18, 0x1e, 0xff, 0xf, 0x1e, 0x15, 0xf, 0x12, 0x15, 0xe, 0xd, 0xff, 0x22, 0x18, 0x1e
//             'R    _    M    I    S    S    I    O    N    .'
    byte: 0x1b, 0xff, 0x16, 0x12, 0x1c, 0x1c, 0x12, 0x18, 0x17, 0x7

    //End PPU string write.
    byte: 0x0

//Writes end message on name table 0 in row $2100 (9th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x3
    //PPU string length.
    byte: 0x17
//             'I    T    _    W    I    L    L    _    R    E    V    I    V    E    _    P'
    byte: 0x12, 0x1d, 0xff, 0x20, 0x12, 0x15, 0x15, 0xff, 0x1b, 0xe, 0x1f, 0x12, 0x1f, 0xe, 0xff, 0x19
//             'E    A    C    E    _    I    N'
    byte: 0xe, 0xa, 0xc, 0xe, 0xff, 0x12, 0x17

//Writes end message on name table 0 in row $2140 (11th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x42
    //PPU string length.
    byte: 0x6
//             'S    P    A    C    E    .'
    byte: 0x1c, 0x19, 0xa, 0xc, 0xe, 0x7

    //End PPU string write.
    byte: 0x0

//Writes end message on name table 0 in row $2180 (13th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x83
    //PPU string length.
    byte: 0x18
//             'B    U    T    ,    I    T    _    M    A    Y    _    B    E    _    I    N'
    byte: 0xb, 0x1e, 0x1d, 0x0, 0x12, 0x1d, 0xff, 0x16, 0xa, 0x22, 0xff, 0xb, 0xe, 0xff, 0x12, 0x17
//             'V    A    D    E    D    _    B    Y'
    byte: 0x1f, 0xa, 0xd, 0xe, 0xd, 0xff, 0xb, 0x22

//Writes end message on name table 0 in row $21C0 (15th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xc2
    //PPU string length.
    byte: 0x12
//             'T    H    E    _    O    T    H    E    R    _    M    E    T    R    O    I'
    byte: 0x1d, 0x11, 0xe, 0xff, 0x18, 0x1d, 0x11, 0xe, 0x1b, 0xff, 0x16, 0xe, 0x1d, 0x1b, 0x18, 0x12
//             'D    .'
    byte: 0xd, 0x7

    //End PPU string write.
    byte: 0x0

//Writes end message on name table 0 in row $2200 (18th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x3
    //PPU string length.
    byte: 0x18
//             'P    R    A    Y    _    F    O    R    _    A    _    T    R    U    E    _'
    byte: 0x19, 0x1b, 0xa, 0x22, 0xff, 0xf, 0x18, 0x1b, 0xff, 0xa, 0xff, 0x1d, 0x1b, 0x1e, 0xe, 0xff
//             'P    E    A    C    E    _    I    N'
    byte: 0x19, 0xe, 0xa, 0xc, 0xe, 0xff, 0x12, 0x17

//Writes end message on name table 0 in row $2240 (19th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x42
    //PPU string length.
    byte: 0x6
//             'S    P    A    C    E    !'
    byte: 0x1c, 0x19, 0xa, 0xc, 0xe, 0x3f

    //End PPU string write.
    byte: 0x0

//The following pointer table is accessed by the NMIScreenWrite routine.
//It is used to locate the start of the PPU strings below.

def endmessagestringtbl1:

    word: title_page_A26D, 0xa276, 0xa27f, 0xa288

//Erases end message on name table 0 in row $2060 (4th row from top).
def title_page_A26D:
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x6d
    //PPU string length.
    byte: 0x48
    //Repeat bit set. Repeats entry 8 times.
    byte: 0xff

//Erases end message on name table 0 in row $20C0 (7th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0xc3
    //PPU string length.
    byte: 0x5a
    //Repeat bit set. Repeats entry 26 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Erases end message on name table 0 in row $2100 (9th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x3
    //PPU string length.
    byte: 0x57
    //Repeat bit set. Repeats entry 23 times.
    byte: 0xff

//Erases end message on name table 0 in row $2140 (11th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x42
    //PPU string length.
    byte: 0x4a
    //Repeat bit set. Repeats entry 10 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Erases end message on name table 0 in row $2180 (13th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x83
    //PPU string length.
    byte: 0x58
    //Repeat bit set. Repeats entry 24 times.
    byte: 0xff

//Erases end message on name table 0 in row $21C0 (15th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xc2
    //PPU string length.
    byte: 0x52
    //Repeat bit set. Repeats entry 12 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Erases end message on name table 0 in row $2200 (18th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x3
    //PPU string length.
    byte: 0x58
    //Repeat bit set. Repeats entry 24 times.
    byte: 0xff


//Erases end message on name table 0 in row $2240 (19th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x42
    //PPU string length.
    byte: 0x4a
    //Repeat bit set. Repeats entry 10 times.
    byte: 0xff

    //End PPU string write
    byte: 0x0

//The following table is used by the LoadCredits routine to load the end credits on the screen.

def creditspointertbl:

    word: title_page_A2E9, 0xa2fb, 0xa31a, 0xa31b, 0xa32d, 0xa339, 0xa34f, 0xa362, 0xa375, 0xa384, 0xa39f, 0xa3aa
    word: title_page_A3C8, 0xa3d8, 0xa3f1, 0xa412, 0xa417, 0xa426, 0xa442, 0xa46b, 0xa470, 0xa493, 0xa49c, 0xa4ad
    word: title_page_A4BD, 0xa4cd, 0xa4d2, 0xa4d7, 0xa4dc, 0xa4e1, 0xa4e6, 0xa4eb, 0xa4ef, 0xa4f0, 0xa508, 0xa51a
    word: title_page_A51F, 0xa524, title_page_A51F, 0xa524, 0xa538, 0xa53d, 0xa538, 0xa53d

//Writes credits on name table 0 in row $2020 (2nd row from top).
def title_page_A2E9:
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x2c
    //PPU string length.
    byte: 0xa
//             'H    A    I    _    Y    U    K    A    M    I'
    byte: 0x11, 0xa, 0x12, 0xff, 0x22, 0x1e, 0x14, 0xa, 0x16, 0x12

//Clears attribute table 0 starting at $23C0.
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xc0
    //PPU string length.
    byte: 0x60
    //Repeat bit set. Repeats entry 32 times.
    byte: 0x0

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2060 (4th row from top)
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x6a
    //PPU string length.
    byte: 0xd
//             'Z    A    R    U    _    S    O    B    A    J    I    M    A'
    byte: 0x23, 0xa, 0x1b, 0x1e, 0xff, 0x1c, 0x18, 0xb, 0xa, 0x13, 0x12, 0x16, 0xa

//Writes credits on name table 0 in row $20A0 (6th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0xab
    //PPU string length.
    byte: 0xb
//             'G    P    Z    _    S    E    N    G    O    K    U'
    byte: 0x10, 0x19, 0x23, 0xff, 0x1c, 0xe, 0x17, 0x10, 0x18, 0x14, 0x1e

    //End PPU string write.
    byte: 0x0
    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2160 (12th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x6a
    //PPU string length.
    byte: 0xa
//             'N    .    S    H    I    O    T    A    N    I'
    byte: 0x17, 0x7, 0x1c, 0x11, 0x12, 0x18, 0x1d, 0xa, 0x17, 0x12

//Clears attribute table 0 starting at $23E0
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xe0
    //PPU string length.
    byte: 0x60
    //Repeat bit set. Repeats entry 32 times.
    byte: 0x0

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $21E0 (16th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xeb
    //PPU string length.
    byte: 0x8
//             'M    .    H    O    U    D    A    I'
    byte: 0x16, 0x7, 0x11, 0x18, 0x1e, 0xd, 0xa, 0x12

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $22A0 (22nd row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0xa7
    //PPU string length.
    byte: 0x12
//             'S    P    E    C    I    A    L    _    T    H    A    N    K    S    _    _ '
    byte: 0x1c, 0x19, 0xe, 0xc, 0x12, 0xa, 0x15, 0xff, 0x1d, 0x11, 0xa, 0x17, 0x14, 0x1c, 0xff, 0xff
//             'T    O'
    byte: 0x1d, 0x18

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $22E0 (24nd row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0xec
    //PPU string length.
    byte: 0x8
//             'K    E    N    _    Z    U    R    I'
    byte: 0x14, 0xe, 0x17, 0xff, 0x23, 0x1e, 0x1b, 0x12

//Writes credits on name table 0 in row $2320 (26nd row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x2e
    //PPU string length.
    byte: 0x4
//             'S    U    M    I'
    byte: 0x1c, 0x1e, 0x16, 0x12

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2360 (28nd row from top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x6c
    //PPU string length.
    byte: 0x7
//             'I    N    U    S    A    W    A'
    byte: 0x12, 0x17, 0x1e, 0x1c, 0xa, 0x20, 0xa

//Writes credits on name table 0 in row $23A0 (bottom row).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xad
    //PPU string length.
    byte: 0x5
//             'K    A    C    H    O'
    byte: 0x14, 0xa, 0xc, 0x11, 0x18

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2820 (2nd row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0x28
    //PPU string length.
    byte: 0x4e
    //Repeat bit set. Repeats entry 14 times.
    byte: 0xff

//Writes credits on name table 2 in row $2860 (4th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0x6c
    //PPU string length.
    byte: 0x7
//             'H    Y    A    K    K    A    N'
    byte: 0x11, 0x22, 0xa, 0x14, 0x14, 0xa, 0x17

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $28A0 (6th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xa8
    //PPU string length.
    byte: 0x13
//             '_    _    _    _    _    G    O    Y    A    K    E    _    _    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x18, 0x22, 0xa, 0x14, 0xe, 0xff, 0xff, 0xff, 0xff, 0xff
//             '_    _    _'
    byte: 0xff, 0xff, 0xff

//Writes credits on name table 2 in row $28E0 (8th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xe8
    //PPU string length.
    byte: 0x4f
    //Repeat bit set. Repeats entry 15 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2920 (10th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0x2c
    //PPU string length.
    byte: 0x7
//             'H    A    R    A    D    A    _'
    byte: 0x11, 0xa, 0x1b, 0xa, 0xd, 0xa, 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2960 (12th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0x66
    //PPU string length.
    byte: 0x16
//             '_    _    _    _    _    _    _    P    E    N    P    E    N    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x19, 0xe, 0x17, 0x19, 0xe, 0x17, 0xff, 0xff, 0xff
//             '_    _    _    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

//Writes credits on name table 2 in row $29A0 (14th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0xa8
    //PPU string length.
    byte: 0x4f
    //Repeat bit set. Repeats entry 15 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $29E0 (16th row from top).
def title_page_A3C8:
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0xea
    //PPU string length.
    byte: 0xc
//             'C    O    N    V    E    R    T    E    D    _    B    Y'
    byte: 0xc, 0x18, 0x17, 0x1f, 0xe, 0x1b, 0x1d, 0xe, 0xd, 0xff, 0xb, 0x22

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2A20 (18th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0x26
    //PPU string length.
    byte: 0x11
//             '_    _    _    _    _    T    .    N    A    R    I    H    I    R    O    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x1d, 0x7, 0x17, 0xa, 0x1b, 0x12, 0x11, 0x12, 0x1b, 0x18, 0xff
//             '_'
    byte: 0xff

//Writes credits on name table 2 in row $2A60 (20th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0x67
    //PPU string length.
    byte: 0x51
    //Repeat bit set. Repeats entry 17 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2AE0 (24th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0xeb
    //PPU string length.
    byte: 0xb
//             'A    S    S    I    S    T    E    D    _    B    Y'
    byte: 0xa, 0x1c, 0x1c, 0x12, 0x1c, 0x1d, 0xe, 0xd, 0xff, 0xb, 0x22

//Writes credits on name table 2 in row $2B20 (26th row from top).
    //PPU address high byte.
    byte: 0x2b
    //PPU address low byte.
    byte: 0x28
    //PPU string length.
    byte: 0xf
//             '_    _    _    M    A    K    O    T    O    _    K    A    N    O    H'
    byte: 0xff, 0xff, 0xff, 0x16, 0xa, 0x14, 0x18, 0x1d, 0x18, 0xff, 0x14, 0xa, 0x17, 0x18, 0x11

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2BA0 (bottom row).
    //PPU address high byte.
    byte: 0x2b
    //PPU address low byte.
    byte: 0xa6
    //PPU string length.
    byte: 0x53
    //Repeat bit set. Repeats entry 19 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2020 (2nd row from the top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x2b
    //PPU string length.
    byte: 0xb
//             'D    I    R    E    C    T    E    D    _    B    Y'
    byte: 0xd, 0x12, 0x1b, 0xe, 0xc, 0x1d, 0xe, 0xd, 0xff, 0xb, 0x22

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2060 (4th row from the top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x67
    //PPU string length.
    byte: 0x14
//             '_    _    _    _    _    Y    A    M    A    M    O    T    O    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x22, 0xa, 0x16, 0xa, 0x16, 0x18, 0x1d, 0x18, 0xff, 0xff, 0xff
//             '_    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff

//Writes credits on name table 0 in row $20A0 (6th row from the top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0xaa
    //PPU string length.
    byte: 0x4e
    //Repeat bit set. Repeats entry 14 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2120 (10th row from the top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x27
    //PPU string length.
    byte: 0x11
//             '_    _    C    H    I    E    F    _    D    I    R    E    C    T    O    R'
    byte: 0xff, 0xff, 0xc, 0x11, 0x12, 0xe, 0xf, 0xff, 0xd, 0x12, 0x1b, 0xe, 0xc, 0x1d, 0x18, 0x1b
//             '_'
    byte: 0xff

//Writes credits on name table 0 in row $2160 (12th row from the top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x68
    //PPU string length.
    byte: 0x11
//             '_    _    S    A    T    O    R    U    _    O    K    A    D    A    _    _'
    byte: 0xff, 0xff, 0x1c, 0xa, 0x1d, 0x18, 0x1b, 0x1e, 0xff, 0x18, 0x14, 0xa, 0xd, 0xa, 0xff, 0xff
//             '_'
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $21E0 (16th row from the top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0xe6
    //PPU string length.
    byte: 0x58
    //Repeat bit set. Repeats entry 24 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2220 (18th row from the top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x2b
    //PPU string length.
    byte: 0x10
//             'P    R    O    D    U    C    E    D    _    B    Y    _    _    _    _    _'
    byte: 0x19, 0x1b, 0x18, 0xd, 0x1e, 0xc, 0xe, 0xd, 0xff, 0xb, 0x22, 0xff, 0xff, 0xff, 0xff, 0xff

//Writes credits on name table 0 in row $2260 (20th row from the top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x6a
    //PPU string length.
    byte: 0xc
//             'G    U    N    P    E    I    _    Y    O    K    O    I'
    byte: 0x10, 0x1e, 0x17, 0x19, 0xe, 0x12, 0xff, 0x22, 0x18, 0x14, 0x18, 0x12

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $22A0 (22nd row from the top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0xa6
    //PPU string length.
    byte: 0x53
    //Repeat bit set. Repeats entry 19 times.
    byte: 0xff

//Writes credits on name table 0 in row $22E0 (24th row from the top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0xe8
    //PPU string length.
    byte: 0x4f
    //Repeat bit set. Repeats entry 15 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2320 (26th row from the top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x29
    //PPU string length.
    byte: 0x4d
    //Repeat bit set. Repeats entry 13 times.
    byte: 0xff

//Writes credits on name table 0 in row $2340 (27th row from the top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x4b
    //PPU string length.
    byte: 0x9
//             'C    O    P    Y    R    I    G    H    T'
    byte: 0xc, 0x18, 0x19, 0x22, 0x1b, 0x12, 0x10, 0x11, 0x1d

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2360 (28th row from the top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x6b
    //PPU string length.
    byte: 0x4a
    //Repeat bit set. Repeats entry 10 times.
    byte: 0xff

//Writes credits on name table 0 in row $2380 (29th row from the top).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0x8e
    //PPU string length.
    byte: 0x4
//             '1    9    8    6'
    byte: 0x1, 0x9, 0x8, 0x6

//Writes credits on name table 0 in row $23A0 (bottom row).
    //PPU address high byte.
    byte: 0x23
    //PPU address low byte.
    byte: 0xa8
    //PPU string length.
    byte: 0x4f
    //Repeat bit set. Repeats entry 10 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2800 (top row)
def title_page_A4BD:
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xc
    //PPU string length.
    byte: 0x8
//             'N    I    N    T    E    N    D    O'
    byte: 0x17, 0x12, 0x17, 0x1d, 0xe, 0x17, 0xd, 0x18

//Writes credits on name table 2 in row $2860 (4th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0x66
    //PPU string length.
    byte: 0x51
    //Repeat bit set. Repeats entry 17 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $28A0 (6th row from top).
    //PPU address high byte.
    byte: 0x28
    //PPU address low byte.
    byte: 0xaa
    //PPU string length.
    byte: 0x4c
    //Repeat bit set. Repeats entry 12 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2920 (10th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0x26
    //PPU string length.
    byte: 0x5b
    //Repeat bit set. Repeats entry 27 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2960 (12th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0x67
    //PPU string length.
    byte: 0x52
    //Repeat bit set. Repeats entry 18 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $29E0 (16th row from top).
    //PPU address high byte.
    byte: 0x29
    //PPU address low byte.
    byte: 0xe6
    //PPU string length.
    byte: 0x54
    //Repeat bit set. Repeats entry 20 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2A20 (18th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0x28
    //PPU string length.
    byte: 0x55
    //Repeat bit set. Repeats entry 21 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2AE0 (24th row from top).
    //PPU address high byte.
    byte: 0x2a
    //PPU address low byte.
    byte: 0xe6
    //PPU string length.
    byte: 0x50
    //Repeat bit set. Repeats entry 16 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 2 in row $2B20 (26th row from top).
    //PPU address high byte.
    byte: 0x2b
    //PPU address low byte.
    byte: 0x29
    //PPU string length.
    byte: 0x4e
    //Repeat bit set. Repeats entry 14 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes the top half of 'The End' on name table 0 in row $2020 (2nd row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x26
    //PPU string length.
    byte: 0x14
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0x24, 0x25, 0x26, 0x27, 0xff, 0xff, 0x2c, 0x2d, 0x2e, 0x2f, 0xff
    byte: 0xff, 0xff, 0xff, 0xff

    //End PPU string write.
    byte: 0x0

//Writes the bottom half of 'The End' on name table 0 in row $2040 (3rd row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x4b
    //PPU string length.
    byte: 0xa
    byte: 0x28, 0x29, 0x2a, 0x2b, 0xff, 0xff, 0x2, 0x3, 0x4, 0x5

//Writes credits on name table 0 in row $2060 (4th row from top).
    //PPU address high byte.
    byte: 0x20
    //PPU address low byte.
    byte: 0x6a
    //PPU string length.
    byte: 0x4c
    //Repeat bit set. Repeats entry 12 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2120 (10th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x26
    //PPU string length.
    byte: 0x53
    //Repeat bit set. Repeats entry 19 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2160 (12th row from top).
def title_page_A51F:
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x6a
    //PPU string length.
    byte: 0x4c
    //Repeat bit set. Repeats entry 12 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

//Writes credits on name table 0 in row $2180 (13th row from top).
    //PPU address high byte.
    byte: 0x21
    //PPU address low byte.
    byte: 0x88
    //PPU string length.
    byte: 0x11
//             '_    _    _    _    _    _    _    _    _    _    _    _    _    _    _    _'
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
//             '_'
    byte: 0xff

//Writes credits on name table 0 in row $2220 (18th row from top).
    //PPU address high byte.
    byte: 0x22
    //PPU address low byte.
    byte: 0x26
    //PPU string length.
    byte: 0x4b
    //Repeat bit set. Repeats entry 11 times.
    byte: 0xff

    //End PPU string write.
    byte: 0x0

    //End PPU block write.
    byte: 0x0

//-------------------------------------------[ World map ]--------------------------------------------

def worldmap:

    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff, 0x8, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0x2c, 0x2b, 0x27, 0x15, 0x15, 0x16, 0x14, 0x13, 0x4, 0xff, 0x6, 0x8, 0xa
    byte: 0x1a, 0x29, 0x29, 0x28, 0x2e, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff
    byte: 0xff, 0xe, 0xff, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x3, 0x1f, 0x23
    byte: 0x25, 0x24, 0x26, 0x20, 0x1e, 0x1f, 0x21, 0x21, 0x7, 0x22, 0x1d, 0x1b, 0x21, 0x20, 0x4, 0xff
    byte: 0xff, 0x10, 0xff, 0xe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2, 0xff
    byte: 0xff, 0x10, 0xff, 0xb, 0xff, 0xff, 0x8, 0xa, 0x1a, 0x29, 0x28, 0x4, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xa, 0x1a, 0x29, 0x29, 0x28, 0x4, 0xff
    byte: 0xff, 0x10, 0xff, 0xb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0x8, 0xff, 0xff, 0xff, 0x8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff
    byte: 0xff, 0x10, 0xff, 0xf, 0x11, 0x13, 0x14, 0x14, 0x13, 0x12, 0xd, 0x3, 0x0, 0x5, 0xc, 0xe
    byte: 0xe, 0xd, 0x10, 0xc, 0xf, 0xd, 0x10, 0xc, 0xe, 0x1b, 0xf, 0xe, 0xf, 0xd, 0x4, 0xff
    byte: 0xff, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0x11, 0xff, 0xff, 0xff, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff
    byte: 0xff, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0x11, 0xa, 0x1a, 0x28, 0x4, 0xff, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff
    byte: 0xff, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0x8, 0xff, 0xff, 0xff, 0x8, 0xff, 0x8, 0x1b, 0x6, 0x19, 0x19, 0x2a, 0xb, 0xff
    byte: 0xff, 0xf, 0x4, 0x3, 0x2, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0x6, 0xff, 0x3, 0x12, 0x14
    byte: 0x15, 0x14, 0x7, 0x16, 0x15, 0x13, 0xb, 0xff, 0xc, 0x7, 0x19, 0x19, 0x19, 0x2a, 0xe, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x8, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1, 0xff, 0xa, 0x1b, 0x4, 0xf, 0x6, 0x2a, 0xe, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2, 0xff, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9, 0xff
    byte: 0xff, 0x8, 0x17, 0x9, 0x14, 0x13, 0x18, 0x12, 0x14, 0x19, 0x13, 0x4, 0xff, 0x8, 0x1d, 0x1f
    byte: 0x6, 0x1f, 0x19, 0x1e, 0x1e, 0x1c, 0x3, 0x28, 0x29, 0x29, 0x29, 0x2b, 0x29, 0x2a, 0xe, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff, 0x8, 0x1d, 0x1f
    byte: 0x1e, 0x19, 0x7, 0x19, 0x19, 0x2c, 0x6, 0x6, 0x2b, 0x2b, 0x1a, 0x1a, 0x1a, 0x2a, 0xb, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0xb, 0xff, 0xff, 0xb, 0xff, 0x6, 0x7, 0x4
    byte: 0xf, 0x10, 0xb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff, 0x7, 0x17, 0x18, 0xc, 0xff, 0x8, 0x21, 0x25
    byte: 0x25, 0x22, 0x3, 0x21, 0x25, 0x20, 0x0, 0x27, 0x2c, 0x2c, 0x6, 0x4, 0xf, 0x10, 0xe, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3, 0x1c, 0x7, 0x17, 0x18, 0xc, 0xff, 0xa, 0x21, 0x23
    byte: 0x25, 0x22, 0x3, 0x21, 0x24, 0x24, 0x24, 0x23, 0x23, 0x6, 0x24, 0x25, 0x22, 0x11, 0x2d, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0x1, 0x7, 0x17, 0x18, 0xc, 0xff, 0x9, 0xff, 0xff
    byte: 0xff, 0x6, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7, 0x26, 0x25, 0x22, 0xb, 0x2d, 0xff
    byte: 0xff, 0xb, 0xff, 0xff, 0xff, 0xff, 0xff, 0x2, 0xb, 0xff, 0xff, 0x8, 0xff, 0xa, 0x12, 0x14
    byte: 0x13, 0x3, 0x12, 0x15, 0x13, 0xd, 0x12, 0x14, 0x6, 0x14, 0x18, 0x15, 0x19, 0x7, 0x9, 0xff
    byte: 0xff, 0x9, 0x17, 0x1c, 0x10, 0x19, 0x18, 0x3, 0x13, 0x10, 0x18, 0xc, 0xff, 0x6, 0xff, 0xff
    byte: 0xff, 0x9, 0x4, 0xf, 0x10, 0xb, 0xff, 0xff, 0x8, 0x12, 0x16, 0x16, 0x16, 0x13, 0xe, 0xff
    byte: 0xff, 0xa, 0x17, 0x1c, 0x1c, 0x1c, 0x18, 0x3, 0x13, 0x19, 0x12, 0xb, 0xff, 0x0, 0xff, 0xff
    byte: 0xb, 0x8, 0x12, 0x19, 0x19, 0x7, 0xff, 0xff, 0x8, 0x5, 0xff, 0xff, 0xff, 0xff, 0x6, 0xff
    byte: 0xff, 0x5, 0xff, 0xff, 0xb, 0xff, 0xff, 0x8, 0xff, 0xff, 0xff, 0xff, 0xb, 0xff, 0xff, 0xff
    byte: 0xff, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5, 0x6, 0x1, 0xff, 0xff, 0xff, 0xff, 0xb, 0xff
    byte: 0xff, 0x5, 0xff, 0xff, 0x7, 0x17, 0x18, 0x4, 0x13, 0x14, 0x14, 0x16, 0xc, 0xff, 0x5, 0xff
    byte: 0xff, 0x5, 0xf, 0x18, 0x17, 0x18, 0x19, 0x29, 0x5, 0x2, 0xff, 0xff, 0xff, 0xff, 0x5, 0xff
    byte: 0xff, 0x5, 0xff, 0xff, 0x8, 0xff, 0xff, 0x5, 0xff, 0xb, 0x10, 0x18, 0xd, 0xff, 0xa, 0x20
    byte: 0x22, 0xd, 0x25, 0x26, 0x26, 0x26, 0x1d, 0xe, 0xe, 0x3, 0x23, 0x24, 0x24, 0x15, 0x7, 0xff
    byte: 0xff, 0x5, 0xff, 0xff, 0x23, 0x17, 0x18, 0x6, 0x22, 0xc, 0xff, 0xb, 0xe, 0xff, 0xb, 0xff
    byte: 0xff, 0x4, 0xff, 0xff, 0xff, 0xff, 0x5, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff
    byte: 0xff, 0x23, 0x22, 0x1a, 0x13, 0x10, 0x14, 0x1c, 0x16, 0x6, 0x21, 0xc, 0xe, 0xff, 0xa, 0x1c
    byte: 0x1d, 0x3, 0x20, 0x21, 0x21, 0x22, 0x6, 0x23, 0xf, 0x28, 0x27, 0x27, 0x27, 0x19, 0x7, 0xff
    byte: 0xff, 0xb, 0xff, 0x1e, 0x1f, 0x20, 0x20, 0x20, 0xf, 0x15, 0x21, 0x24, 0xe, 0xff, 0x4, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1d, 0x1b, 0x17, 0x18, 0xc, 0xff, 0x4, 0x11
    byte: 0x10, 0x12, 0x13, 0x14, 0x14, 0x15, 0x3, 0x1c, 0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1d, 0x7, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xb, 0xff, 0xc, 0x16
    byte: 0x18, 0x17, 0x18, 0x17, 0xf, 0x17, 0x17, 0x1a, 0x1a, 0x17, 0x1b, 0x1b, 0x17, 0x19, 0x9, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 
def copymap:

    a = 0x3e
    [0x0] = a
    a = 0xa5
    [0x1] = a
    a = 0x0
    [0x2] = a
    //Loads contents of world map into -->
    a = 0x70
    //RAM at addresses $7000 thru $73FF.
    [0x3] = a
    x = 0x4
def _00BD:
    y = 0x0
def _00BE:
    a = [[0x0]:y]
    [[0x2]:y] = a
    y++
    goto _00BE when ~zero
    [0x1]++
    [0x3]++
    x--
    goto _00BD when ~zero
    return
 
//Unused tile patterns.
    byte: 0x0, 0x40, 0x90, 0xd0, 0x8, 0x5c, 0xc, 0x0, 0x0, 0xc0, 0x70, 0xf8, 0xfc, 0xf4, 0xfc, 0x10
    byte: 0x22, 0x56, 0x3, 0x2b, 0x74, 0x37, 0xd, 0x3f, 0x5f, 0x7d, 0x7f, 0x7f, 0x5f, 0x3f, 0xf, 0x68
    byte: 0xf6, 0xbc, 0x5e, 0x3c, 0xde, 0x7c, 0xf0, 0xfc, 0xde, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xf0, 0x0
    byte: 0x0, 0x7f, 0x80, 0x80, 0xff, 0x7f, 0x0, 0x0, 0x7f, 0x80, 0x7f, 0xff, 0xff, 0x7f, 0x0, 0x0
    byte: 0x0, 0xfc, 0x1, 0x3, 0xff, 0xfe, 0x0, 0x0, 0xfe, 0x3, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0
    byte: 0x10, 0x20, 0x20, 0x0, 0x20, 0x0, 0x0, 0x3c, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3c, 0x7f
    byte: 0x7f, 0x3f, 0x1f, 0x80, 0xf, 0x8, 0x88, 0x12, 0x80, 0xc0, 0xe0, 0xe0, 0xef, 0xe8, 0xe8, 0xfc
    byte: 0xfc, 0xfc, 0xf8, 0x1c, 0xdc, 0x58, 0x5c, 0x48, 0x4, 0xc, 0x18, 0x1c, 0xdc, 0x18, 0x1c, 0xf
    byte: 0x0, 0x9f, 0x3f, 0x7f, 0xdb, 0x0, 0x0, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0xdb, 0x0, 0x0, 0xdc
    byte: 0x18, 0xec, 0xf4, 0xf8, 0x6c, 0x0, 0x0, 0x1c, 0x18, 0xfc, 0xfc, 0xfc, 0x6c, 0x0, 0x0, 0xff
    byte: 0xff, 0xc0, 0xc0, 0xcf, 0xcb, 0xcc, 0xcc, 0x0, 0x0, 0x1f, 0x3f, 0x3f, 0x38, 0x3b, 0x3b, 0xfc
    byte: 0xfc, 0xc, 0xc, 0xcc, 0x4c, 0xcc, 0xcc, 0x0, 0x4, 0xec, 0xfc, 0xfc, 0x3c, 0xbc, 0xbc, 0xcb
    byte: 0xcf, 0xc0, 0xc0, 0xff, 0xff, 0x0, 0x0, 0x3b, 0x30, 0x3f, 0x1f, 0x7f, 0xff, 0x0, 0x0, 0x4c
    byte: 0xcc, 0xc, 0xc, 0xfc, 0xfc, 0x0, 0x0, 0x3c, 0x3c, 0xfc, 0xec, 0xfc, 0xfc, 0x0, 0x0, 0xfe
    byte: 0x82, 0x82, 0x82, 0x82, 0xfe, 0x0, 0x0, 0x0, 0x7e, 0x56, 0x56, 0x7e, 0xfe, 0x0, 0x0, 0x20
    byte: 0x0, 0x0, 0x18, 0x20, 0x0, 0x0, 0x18, 0x1c, 0xf7, 0x3c, 0x18, 0x1c, 0xf7, 0x3c, 0x18, 0xe2
    byte: 0x80, 0x10, 0x20, 0x0, 0x0, 0x80, 0x0, 0xe2, 0x98, 0x2c, 0x5e, 0x7e, 0x3c, 0x98, 0x0, 0x7e
    byte: 0x0, 0x7e, 0x0, 0x7e, 0x0, 0x7e, 0x0, 0x6e, 0x0, 0x6e, 0x0, 0x6e, 0x0, 0x6e, 0x0, 0x10
    byte: 0xf4, 0x8, 0x4, 0xc5, 0x24, 0x23, 0x5, 0xe8, 0xf8, 0xe, 0xe6, 0xf7, 0x37, 0x2e, 0xfd, 0x0
    byte: 0x5f, 0x20, 0x48, 0xd7, 0x88, 0x18, 0x80, 0x3f, 0x3f, 0xe0, 0xc7, 0xcf, 0xb8, 0x98, 0x7f, 0xf8
    byte: 0x10, 0x10, 0x10, 0xd7, 0x8, 0x0, 0xef, 0xf8, 0x10, 0x30, 0xb7, 0xf7, 0x30, 0xdf, 0xef, 0xff
    byte: 0x0, 0x8, 0x8, 0xef, 0x8, 0x10, 0xef, 0xff, 0x0, 0x18, 0xdb, 0xff, 0x38, 0xf7, 0xef, 0xff
    byte: 0x7f, 0x3f, 0x5f, 0x4f, 0x7, 0x3, 0x1, 0x0, 0xb0, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xfe
    byte: 0xfe, 0xfe, 0xfa, 0xfa, 0xfe, 0xfe, 0xfe, 0x0, 0x1a, 0x6, 0xa, 0x1a, 0x3e, 0x7e, 0xfe, 0x1
    byte: 0x3, 0x7, 0x4f, 0x5f, 0x27, 0x7f, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0x0, 0x7e
    byte: 0xbe, 0xda, 0xea, 0xf6, 0xca, 0xfc, 0x0, 0xfe, 0xfe, 0xfa, 0xfa, 0xfe, 0xce, 0xfe, 0x0, 0xcf
    byte: 0xbf, 0x70, 0x60, 0xc4, 0xc8, 0xc0, 0xc0, 0x47, 0xbf, 0x70, 0x27, 0x4b, 0x57, 0x5f, 0xdf, 0xcc
    byte: 0xf4, 0x38, 0x18, 0xc, 0xc, 0xc, 0xc, 0xcc, 0xf4, 0x38, 0x98, 0xcc, 0xec, 0xec, 0xec, 0xc0
    byte: 0xc0, 0x60, 0x70, 0xbf, 0xcf, 0x0, 0x0, 0xdf, 0xcf, 0x67, 0x70, 0xbf, 0x4f, 0x0, 0x0, 0xc
    byte: 0xc, 0x18, 0x38, 0xf4, 0xcc, 0x0, 0x0, 0xec, 0xcc, 0x98, 0x38, 0xf4, 0xcc, 0x0, 0x0, 0xff
    byte: 0xff, 0xc0, 0xdf, 0xd0, 0xd0, 0xdf, 0xc0, 0x0, 0x0, 0x3f, 0x3f, 0x35, 0x35, 0x20, 0x3f, 0xfc
    byte: 0xfc, 0xc, 0xec, 0x2c, 0x2c, 0xec, 0xc, 0x0, 0x4, 0xfc, 0xfc, 0x5c, 0x5c, 0x1c, 0xfc, 0xff
    byte: 0x0, 0x0, 0xe4, 0x0, 0xcf, 0x0, 0x0, 0x7f, 0x0, 0x0, 0xe3, 0x0, 0xbf, 0x0, 0x0, 0xfc
    byte: 0x0, 0x0, 0xf9, 0x0, 0x87, 0x0, 0x0, 0xfc, 0x0, 0x0, 0xf7, 0x0, 0x67, 0x0, 0x0, 0xfe
    byte: 0x2, 0x2, 0x2, 0xfe, 0x0, 0x0, 0x7f, 0x0, 0xfe, 0xe, 0xfe, 0xfe, 0x0, 0x0, 0x0, 0x7f
    byte: 0x40, 0x40, 0x40, 0x7f, 0x0, 0x0, 0xfe, 0x0, 0x3f, 0x30, 0x3f, 0x7f, 0x0, 0x0, 0x0, 0x40
    byte: 0x40, 0x40, 0x7f, 0x0, 0x0, 0x0, 0xff, 0x3f, 0x30, 0x3f, 0x7f, 0x0, 0x0, 0xff, 0xff, 0x2
    byte: 0x2, 0x2, 0xfe, 0x0, 0x0, 0x0, 0xff, 0xfe, 0xe, 0xfe, 0xfe, 0x0, 0x0, 0xff, 0xff, 0xff
    byte: 0xff, 0xc0, 0xd0, 0xc0, 0xc0, 0xc0, 0xc0, 0x0, 0x0, 0x3f, 0x27, 0x3f, 0x3f, 0x3f, 0x3f, 0xfc
    byte: 0xfc, 0xc, 0x4c, 0xc, 0xc, 0xc, 0xc, 0x0, 0x4, 0xfc, 0x9c, 0xfc, 0xfc, 0xfc, 0xfc, 0xc0
    byte: 0xc0, 0xd0, 0xc0, 0xff, 0xff, 0x0, 0x0, 0x3f, 0x3f, 0x27, 0x3f, 0x3f, 0x7f, 0x0, 0x0, 0xc
    byte: 0xc, 0x4c, 0xc, 0xfc, 0xfc, 0x0, 0x0, 0xfc, 0xfc, 0x9c, 0xfc, 0xfc, 0xfc, 0x0, 0x0

//------------------------------------------[ Area music data ]---------------------------------------

//There are 3 control bytes associated with the music data and the rest are musical note indexes.
//If the byte has the binary format 1011xxxx ($Bx), then the byte is an index into the corresponding
//musical notes table and is used to set the note length until it is set by another note length
//byte. The lower 4 bits are the index into the note length table. Another control byte is the loop
//and counter btye. The loop and counter byte has the format 11xxxxxx. Bits 0 thru 6 contain the
//number of times to loop.  The third control byte is #$FF. This control byte marks the end of a loop
//and decrements the loop counter. If #$00 is found in the music data, the music has reached the end.
//A #$00 in any of the different music channel data segments will mark the end of the music. The
//remaining bytes are indexes into the MusicNotesTbl and should only be even numbers as there are 2
//bytes of data per musical note.

def endsq1data:

def title_page_AC00:
    byte: 0xc2
    //7/8 seconds    +
    byte: 0xb4
    //A3        |
    byte: 0x2a
    //C4        | Repeat 2 times.
    byte: 0x30
    //B3        |
    byte: 0x2e
    //A#3        +
    byte: 0x2c
    byte: 0xff
    //A3
    byte: 0x2a
    //A3
    byte: 0x2a
    byte: 0xc2
    //1/4 seconds    +
    byte: 0xb0
    //F#4        |
    byte: 0x3c
    //A4        |
    byte: 0x42
    //D5        |
    byte: 0x4c
    //F#5        |
    byte: 0x54
    //7/32 seconds    |
    byte: 0xb2
    //A5        |
    byte: 0x5a
    //G5        |
    byte: 0x56
    //F#5        |
    byte: 0x54
    //7/8 seconds    |
    byte: 0xb4
    //D5        |
    byte: 0x4c
    //1/4 seconds    |
    byte: 0xb0
    //E4        | Repeat 2 times.
    byte: 0x38
    //F#4        |
    byte: 0x3c
    //G4        |
    byte: 0x3e
    //A4        |
    byte: 0x42
    //7/32 seconds    |
    byte: 0xb2
    //D5        |
    byte: 0x4c
    //A4        |
    byte: 0x42
    //1/4 seconds    |
    byte: 0xb0
    //G5        |
    byte: 0x56
    //F#5        |
    byte: 0x54
    //D5        |
    byte: 0x4c
    //A4        |
    byte: 0x42
    //7/16 seconds    |
    byte: 0xb3
    //G4        |
    byte: 0x3e
    //D5        +
    byte: 0x4c
    byte: 0xff
    byte: 0xc2
    //7/16 seconds    +
    byte: 0xb3
    //C#5        |
    byte: 0x4a
    //7/32 seconds    |
    byte: 0xb2
    //D5        |
    byte: 0x4c
    //A4        |
    byte: 0x42
    //F#5        |
    byte: 0x54
    //E5        |
    byte: 0x50
    //G5        |
    byte: 0x56
    //F#5        |
    byte: 0x54
    //7/64 seconds    |
    byte: 0xb1
    //E5        |
    byte: 0x50
    //D5        | Repeat 2 times.
    byte: 0x4c
    //A#4        |
    byte: 0x44
    //G4        |
    byte: 0x3e
    //7/32 seconds    |
    byte: 0xb2
    //F#4        |
    byte: 0x3c
    //D5        |
    byte: 0x4c
    //7/64 seconds    |
    byte: 0xb1
    //Ab4        |
    byte: 0x40
    //B4        |
    byte: 0x46
    //7/32 seconds    |
    byte: 0xb2
    //E5        |
    byte: 0x50
    //D5        |
    byte: 0x4c
    //E5        +
    byte: 0x50
    byte: 0xff
    byte: 0xc4
    //7/16 seconds    +
    byte: 0xb3
    //A3        |
    byte: 0x2a
    //C4        | Repeat 4 times.
    byte: 0x30
    //B3        |
    byte: 0x2e
    //A#3        +
    byte: 0x2c
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //D4
    byte: 0x34
    //7/16 seconds
    byte: 0xb3
    //E4
    byte: 0x38
    //G4
    byte: 0x3e
    //7/8 seconds
    byte: 0xb4
    //F#4
    byte: 0x3c
    //7/16 seconds
    byte: 0xb3
    //G4
    byte: 0x3e
    //A#4
    byte: 0x44
    //1 13/16 seconds
    byte: 0xb5
    //D4
    byte: 0x34
    //7/64 seconds
    byte: 0xb1
    //A3
    byte: 0x2a
    //21/32 seconds
    byte: 0xb6
    //D3
    byte: 0x1c
    //7/32 seconds
    byte: 0xb2
    //No sound
    byte: 0x2
    //1 13/16 seconds
    byte: 0xb5
    //G3
    byte: 0x26
    //7/64 seconds
    byte: 0xb1
    //F#3
    byte: 0x24
    //21/64 seconds
    byte: 0xb8
    //D2
    byte: 0x6
    //A2
    byte: 0x12
    //D3
    byte: 0x1c
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //F#3
    byte: 0x24
    //A3
    byte: 0x2a
    //D4
    byte: 0x34
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //1 13/16 seconds
    byte: 0xb5
    //E4
    byte: 0x38
    //7/64 seconds
    byte: 0xb1
    //A#3
    byte: 0x2c
    //7/16 seconds
    byte: 0xb3
    //G3
    byte: 0x26
    //A3
    byte: 0x2a
    //1 13/16 seconds
    byte: 0xb5
    //A3
    byte: 0x2a
    //7/64 seconds
    byte: 0xb1
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //G3
    byte: 0x26
    //F#3
    byte: 0x24
    //D3
    byte: 0x1c
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //E3
    byte: 0x20
    //D3
    byte: 0x1c
    //E3
    byte: 0x20
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //7/8 seconds
    byte: 0xb4
    //D3
    byte: 0x1c
    //21/64 seconds
    byte: 0xb8
    //G3
    byte: 0x26
    //A#3
    byte: 0x2c
    //D4
    byte: 0x34
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //G4
    byte: 0x3e
    //A#4
    byte: 0x44
    //D5
    byte: 0x4c
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    byte: 0xc8
    //1/4 seconds    +
    byte: 0xb0
    //F#4        |
    byte: 0x3c
    //A4        |
    byte: 0x42
    //F#4        |
    byte: 0x3c
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //B4        |
    byte: 0x46
    //A4        |
    byte: 0x42
    //B4        | Repeat 8 times.
    byte: 0x46
    //D5        |
    byte: 0x4c
    //E5        |
    byte: 0x50
    //D5        |
    byte: 0x4c
    //E5        |
    byte: 0x50
    //E5        |
    byte: 0x50
    //F#5        |
    byte: 0x54
    //E5        |
    byte: 0x50
    //F#5        +
    byte: 0x54
    byte: 0xff
    byte: 0xc2
    //7/8 seconds    +
    byte: 0xb4
    //A3        |
    byte: 0x2a
    //7/16 seconds    |
    byte: 0xb3
    //D4        |
    byte: 0x34
    //1 13/16 seconds|
    byte: 0xb5
    //C#4        |
    byte: 0x32
    //7/64 seconds    |
    byte: 0xb1
    //B3        | Repeat 2 times.
    byte: 0x2e
    //7/8 seconds    |
    byte: 0xb4
    //A3        |
    byte: 0x2a
    //7/16 seconds    |
    byte: 0xb3
    //D3        |
    byte: 0x1c
    //1 13/16 seconds|
    byte: 0xb5
    //G3        |
    byte: 0x26
    //7/64 seconds    |
    byte: 0xb1
    //F#3        +
    byte: 0x24
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //A3
    byte: 0x2a
    //21/64 seconds
    byte: 0xb8
    //C3
    byte: 0x18
    //G3
    byte: 0x26
    //C4
    byte: 0x30
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //D3
    byte: 0x1c
    //G3
    byte: 0x26
    //C4
    byte: 0x30
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //7/8 seconds
    byte: 0xb4
    //D4
    byte: 0x34
    //21/64 seconds
    byte: 0xb8
    //F4
    byte: 0x3a
    //C4
    byte: 0x30
    //G3
    byte: 0x26
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //21/64 seconds
    byte: 0xb8
    //G4
    byte: 0x3e
    //E4
    byte: 0x38
    //C4
    byte: 0x30
    //9/32 seconds
    byte: 0xb9
    //No sound
    byte: 0x2
    //7/8 seconds
    byte: 0xb4
    //D4
    byte: 0x34
    //7/32 seconds
    byte: 0xb2
    //D3
    byte: 0x1c
    //A3
    byte: 0x2a
    //G3
    byte: 0x26
    //C4
    byte: 0x30
    byte: 0xc2
    //1/4 seconds    +
    byte: 0xb0
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //E4        |
    byte: 0x38
    //E4        | Repeat 2 times.
    byte: 0x38
    //E4        |
    byte: 0x38
    //No sound    |
    byte: 0x2
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //E4        |
    byte: 0x38
    //No sound    +
    byte: 0x2
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //E4
    byte: 0x38
    //7/32 seconds
    byte: 0xb2
    //No sound
    byte: 0x2
    //1/4 seconds
    byte: 0xb0
    //D3
    byte: 0x1c
    //No sound
    byte: 0x2
    //D3
    byte: 0x1c
    //D3
    byte: 0x1c
    //7/32 seconds
    byte: 0xb2
    //D2
    byte: 0x6
    //End of end music.
    byte: 0x0

def endtriangledata:

    byte: 0xca
    //1/4 seconds    +
    byte: 0xb0
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //A3        | Repeat 10 times.
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //No sound    |
    byte: 0x2
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc2
    //7/32 seconds    +
    byte: 0xb2
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //C#4        |
    byte: 0x32
    //C#4        |
    byte: 0x32
    //B3        |
    byte: 0x2e
    //B3        |
    byte: 0x2e
    //A3        |
    byte: 0x2a
    //A3        | Repeat 2 times.
    byte: 0x2a
    //G3        |
    byte: 0x26
    //G3        |
    byte: 0x26
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //E3        |
    byte: 0x20
    //E3        |
    byte: 0x20
    //A3        |
    byte: 0x2a
    //A3        +
    byte: 0x2a
    byte: 0xff
    byte: 0xc2
    //G3        +
    byte: 0x26
    //G3        |
    byte: 0x26
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //C4        |
    byte: 0x30
    //C4        |
    byte: 0x30
    //B3        |
    byte: 0x2e
    //B3        | Repeat 2 times.
    byte: 0x2e
    //A#3        |
    byte: 0x2c
    //A#3        |
    byte: 0x2c
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //Ab3        |
    byte: 0x28
    //Ab3        |
    byte: 0x28
    //A3        |
    byte: 0x2a
    //A3        +
    byte: 0x2a
    byte: 0xff
    byte: 0xc8
    //1/4 seconds    +
    byte: 0xb0
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //D3        | Repeat 8 times.
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    |
    byte: 0x2
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xd8
    //1/32 seconds    +
    byte: 0xba
    //D6        |
    byte: 0x64
    //No sound    |
    byte: 0x2
    //D6        |
    byte: 0x64
    //No sound    |
    byte: 0x2
    //9/32 seconds    |
    byte: 0xb9
    //No sound    |
    byte: 0x2
    //1/32 Seconds    |
    byte: 0xba
    //A6        |
    byte: 0x72
    //No sound    |
    byte: 0x2
    //A6        |
    byte: 0x72
    //No sound    |
    byte: 0x2
    //9/32 seconds    | Repeat 24 times.
    byte: 0xb9
    //No sound    |
    byte: 0x2
    //1/32 seconds    |
    byte: 0xba
    //D7        |
    byte: 0x7c
    //No sound    |
    byte: 0x2
    //D7        |
    byte: 0x7c
    //No sound    |
    byte: 0x2
    //9/32 seconds    |
    byte: 0xb9
    //No sound    |
    byte: 0x2
    //1/32 seconds    |
    byte: 0xba
    //A6        |
    byte: 0x72
    //No sound    |
    byte: 0x2
    //A6        |
    byte: 0x72
    //No sound    |
    byte: 0x2
    //9/32 seconds    |
    byte: 0xb9
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc4
    //7/64 seconds    +
    byte: 0xb1
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //No sound    |
    byte: 0x2
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //E3        |
    byte: 0x20
    //E3        |
    byte: 0x20
    //E3        |
    byte: 0x20
    //E3        |
    byte: 0x20
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        |
    byte: 0x2a
    //A3        | Repeat 4 times.
    byte: 0x2a
    //No sound    |
    byte: 0x2
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //F#3        |
    byte: 0x24
    //21/64 seconds    |
    byte: 0xb8
    //G3        |
    byte: 0x26
    //D3        |
    byte: 0x1c
    //E3        |
    byte: 0x20
    //9/32 seconds    |
    byte: 0xb9
    //No sound    |
    byte: 0x2
    //21/64 seconds    |
    byte: 0xb8
    //A#3        |
    byte: 0x2c
    //A3        |
    byte: 0x2a
    //G3        |
    byte: 0x26
    //9/32 seconds    |
    byte: 0xb9
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc3
    //1/4 seconds    +
    byte: 0xb0
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //No sound    |
    byte: 0x2
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //D4        | Repeat 3 times.
    byte: 0x34
    //D4        |
    byte: 0x34
    //No sound    |
    byte: 0x2
    //A#3        |
    byte: 0x2c
    //A#3        |
    byte: 0x2c
    //A#3        |
    byte: 0x2c
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //A#3        |
    byte: 0x2c
    //A#3        |
    byte: 0x2c
    //C4        |
    byte: 0x30
    //No sound    |
    byte: 0x2
    //C4        |
    byte: 0x30
    //C4        |
    byte: 0x30
    //C4        |
    byte: 0x30
    //C4        |
    byte: 0x30
    //C4        |
    byte: 0x30
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc2
    //D3        +
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //D3        | Repeat 2 times.
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    |
    byte: 0x2
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //D3        |
    byte: 0x1c
    //No sound    +
    byte: 0x2
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //D3
    byte: 0x1c
    //7/32 seconds
    byte: 0xb2
    //No sound
    byte: 0x2
    //1/4 seconds
    byte: 0xb0
    //D3
    byte: 0x1c
    //No sound
    byte: 0x2
    //D3
    byte: 0x1c
    //D3
    byte: 0x1c
    //7/32 seconds
    byte: 0xb2
    //D3
    byte: 0x1c

def endsq2data:

    byte: 0xc2
    //7/8 seconds    +
    byte: 0xb4
    //E3        |
    byte: 0x20
    //A3        | Repeat 2 times.
    byte: 0x2a
    //Ab3        |
    byte: 0x28
    //G3        +
    byte: 0x26
    byte: 0xff
    //E3
    byte: 0x20
    //E3
    byte: 0x20
    byte: 0xc2
    //1/4 seconds    +
    byte: 0xb0
    //D4        |
    byte: 0x34
    //F#4        |
    byte: 0x3c
    //A4        |
    byte: 0x42
    //D5        |
    byte: 0x4c
    //7/32 seconds    |
    byte: 0xb2
    //F#5        |
    byte: 0x54
    //E5        |
    byte: 0x50
    //D5        |
    byte: 0x4c
    //7/16 seconds    |
    byte: 0xb3
    //A4        | Repeat 2 times.
    byte: 0x42
    //F#4        |
    byte: 0x3c
    //7/16 seconds    |
    byte: 0xb3
    //B4        |
    byte: 0x46
    //7/32 seconds    |
    byte: 0xb2
    //D4        |
    byte: 0x34
    //7/64 seconds    |
    byte: 0xb1
    //D5        |
    byte: 0x4c
    //1/4 seconds    |
    byte: 0xb0
    //A4        |
    byte: 0x42
    //F#4        |
    byte: 0x3c
    //7/16 seconds    |
    byte: 0xb3
    //E4        |
    byte: 0x38
    //B4        +
    byte: 0x46
    byte: 0xff
    byte: 0xc2
    //7/16 seconds    +
    byte: 0xb3
    //E4        |
    byte: 0x38
    //7/32 seconds    |
    byte: 0xb2
    //F#4        |
    byte: 0x3c
    //D4        |
    byte: 0x34
    //D4        |
    byte: 0x34
    //C4        |
    byte: 0x30
    //E4        |
    byte: 0x38
    //D4        |
    byte: 0x34
    //A#4        | Repeat 2 times.
    byte: 0x44
    //E4        |
    byte: 0x38
    //D4        |
    byte: 0x34
    //A4        |
    byte: 0x42
    //7/64 seconds    |
    byte: 0xb1
    //F4        |
    byte: 0x3a
    //Ab4        |
    byte: 0x40
    //7/32 seconds    |
    byte: 0xb2
    //B4        |
    byte: 0x46
    //G4        |
    byte: 0x3e
    //G4        +
    byte: 0x3e
    byte: 0xff
    byte: 0xc4
    //7/32 seconds    +
    byte: 0xb2
    //F#4        |
    byte: 0x3c
    //A4        |
    byte: 0x42
    //D5        |
    byte: 0x4c
    //A4        | Repeat 4 times.
    byte: 0x42
    //G4        |
    byte: 0x3e
    //A4        |
    byte: 0x42
    //D5        |
    byte: 0x4c
    //G4        +
    byte: 0x3e
    byte: 0xff
    byte: 0xc2
    //A6        +
    byte: 0x72
    //G6        |
    byte: 0x6e
    //F#6        |
    byte: 0x6c
    //E6        |
    byte: 0x68
    //G6        |
    byte: 0x6e
    //F#6        |
    byte: 0x6c
    //D6        |
    byte: 0x64
    //E6        +
    byte: 0x68
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //D5
    byte: 0x4c
    //7/16 seconds
    byte: 0xb3
    //G5
    byte: 0x56
    //E5
    byte: 0x50
    //7/8 seconds
    byte: 0xb4
    //F#5
    byte: 0x54
    //7/16 seconds
    byte: 0xb3
    //G5
    byte: 0x56
    //A#5
    byte: 0x5c
    //7/8 seconds
    byte: 0xb4
    //D5
    byte: 0x4c
    //7/16 seconds
    byte: 0xb3
    //E5
    byte: 0x50
    //G5
    byte: 0x56
    //7/8 seconds
    byte: 0xb4
    //F#5
    byte: 0x54
    //7/16 seconds
    byte: 0xb3
    //G5
    byte: 0x56
    //A#5
    byte: 0x5c
    byte: 0xc4
    //7/64 seconds    +
    byte: 0xb1
    //A5        |
    byte: 0x5a
    //A4        |
    byte: 0x42
    //G5        |
    byte: 0x56
    //A4        |
    byte: 0x42
    //F#5        |
    byte: 0x54
    //A4        |
    byte: 0x42
    //E5        | Repeat 4 times.
    byte: 0x50
    //A4        |
    byte: 0x42
    //G5        |
    byte: 0x56
    //G4        |
    byte: 0x3e
    //F#5        |
    byte: 0x54
    //G4        |
    byte: 0x3e
    //D5        |
    byte: 0x4c
    //G4        |
    byte: 0x3e
    //E5        |
    byte: 0x50
    //G4        +
    byte: 0x3e
    byte: 0xff
    byte: 0xc8
    //1/4 seconds    +
    byte: 0xb0
    //F#4        |
    byte: 0x3c
    //G4        |
    byte: 0x3e
    //F#4        |
    byte: 0x3c
    //G4        |
    byte: 0x3e
    //A4        |
    byte: 0x42
    //B4        |
    byte: 0x46
    //A4        | Repeat 8 times.
    byte: 0x42
    //B4        |
    byte: 0x46
    //D5        |
    byte: 0x4c
    //E5        |
    byte: 0x50
    //D5        |
    byte: 0x4c
    //E5        |
    byte: 0x50
    //E5        |
    byte: 0x50
    //F#5        |
    byte: 0x54
    //E5        |
    byte: 0x50
    //F#5        +
    byte: 0x54
    byte: 0xff
    byte: 0xc3
    //1/4 seconds    +
    byte: 0xb0
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //No sound    |
    byte: 0x2
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        | Repeat 3 times.
    byte: 0x42
    //No sound    |
    byte: 0x2
    //F4        |
    byte: 0x3a
    //F4        |
    byte: 0x3a
    //F4        |
    byte: 0x3a
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //F4        |
    byte: 0x3a
    //F4        |
    byte: 0x3a
    //G4        |
    byte: 0x3e
    //No sound    |
    byte: 0x2
    //G4        |
    byte: 0x3e
    //G4        |
    byte: 0x3e
    //G4        |
    byte: 0x3e
    //G4        |
    byte: 0x3e
    //G4        |
    byte: 0x3e
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc2
    //A4        +
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //No sound    |
    byte: 0x2
    //A4        |
    byte: 0x42
    //A4        | Repeat 2 times.
    byte: 0x42
    //A4        |
    byte: 0x42
    //No sound    |
    byte: 0x2
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //A4        |
    byte: 0x42
    //No sound    +
    byte: 0x2
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //A3
    byte: 0x2a
    //7/32 seconds
    byte: 0xb2
    //No sound
    byte: 0x2
    //1/4 seconds
    byte: 0xb0
    //A3
    byte: 0x2a
    //No sound
    byte: 0x2
    //A3
    byte: 0x2a
    //A3
    byte: 0x2a
    //7/32 seconds
    byte: 0xb2
    //A3
    byte: 0x2a
    //End of end music.
    byte: 0x0

def endnoisedata:

    byte: 0xca
    //1/4 seconds    +
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    | Repeat 10 times.
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    +
    byte: 0x1
    byte: 0xff
    byte: 0xd8
    //7/32 seconds    +
    byte: 0xb2
    //Drumbeat 01    | Repeat 24 times.
    byte: 0x4
    //Drumbeat 02    +
    byte: 0x7
    byte: 0xff
    byte: 0xc4
    //1/4 seconds    +
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    | Repeat 4 times.
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    +
    byte: 0x1
    byte: 0xff
    byte: 0xc8
    //7/64 seconds    +
    byte: 0xb1
    //Drumbeat 01    |
    byte: 0x4
    //1/4 seconds    |
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //7/64 seconds    |
    byte: 0xb1
    //Drumbeat 01    |
    byte: 0x4
    //1/4 seconds    |
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    | Repeat 8 times.
    byte: 0x4
    //7/64 seconds    |
    byte: 0xb1
    //Drumbeat 01    |
    byte: 0x4
    //1/4 seconds    |
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //7/64 seconds    |
    byte: 0xb1
    //Drumbeat 02    |
    byte: 0x7
    //1/4 seconds    |
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff
    byte: 0xd0
    //7/32 seconds    + Repeat 16 times.
    byte: 0xb2
    //Drumbeat01    +
    byte: 0x4
    byte: 0xff
    byte: 0xe0
    //7/64 seconds    +
    byte: 0xb1
    //Drumbeat 01    | Repeat 32 times.
    byte: 0x4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff
    byte: 0xe0
    //1/4 seconds    +
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //7/64 seconds    |
    byte: 0xb1
    //Drumbeat 02    | Repeat 32 times.
    byte: 0x7
    //1/4 seconds    |
    byte: 0xb0
    //Drumbeat 03    |
    byte: 0xa
    //Drumbeat 01    |
    byte: 0x4
    //7/64 seconds    |
    byte: 0xb1
    //Drumbeat 02    +
    byte: 0x7
    byte: 0xff
    byte: 0xc8
    //1/4 seconds    +
    byte: 0xb0
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    | Repeat 8 times.
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    |
    byte: 0x1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 00    +
    byte: 0x1
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //Drumbeat 02
    byte: 0x7
    //7/32 seconds
    byte: 0xb2
    //Drumbeat 00
    byte: 0x1
    //1/4 seconds
    byte: 0xb0
    //Drumbeat 02
    byte: 0x7
    //Drumbeat 00
    byte: 0x1
    //Drumbeat 02
    byte: 0x7
    //Drumbeat 02
    byte: 0x7
    //7/32 seconds
    byte: 0xb2
    //Drumbeat 02
    byte: 0x7
    //End of end music.
    byte: 0x0

//Unused tile patterns.
    byte: 0x80, 0x40, 0x20, 0x10, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x4, 0x0, 0x2
    byte: 0x2, 0x0, 0x0, 0x0, 0x0, 0x7, 0x3, 0x3, 0x3, 0x1, 0x0, 0x0, 0x0, 0x84, 0xc4, 0x42
    byte: 0x62, 0x21, 0x31, 0x11, 0x11, 0x80, 0xc0, 0xc0, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x3, 0x3, 0x11, 0x11, 0x31
    byte: 0x21, 0x63, 0x62, 0xc4, 0x84, 0xf0, 0xf0, 0xf0, 0xe0, 0xe0, 0xe0, 0xc0, 0x80, 0x1, 0x13, 0x16
    byte: 0x2c, 0x78, 0xb3, 0xec, 0xf0, 0x7, 0x1f, 0x1e, 0x3c, 0x78, 0xf0, 0xe0, 0x0, 0x8, 0x10, 0x20
    byte: 0x40, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x82, 0xcc, 0x4e
    byte: 0x4c, 0x40, 0x4c, 0x4c, 0x4c, 0x82, 0xcc, 0xce, 0xcc, 0xc0, 0xcc, 0xcc, 0xcc, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x1, 0x3, 0x6, 0xc, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x7, 0xf, 0x3c, 0xe0
    byte: 0x84, 0x8, 0x30, 0x60, 0xe0, 0x0, 0x2, 0x1f, 0x7a, 0xf4, 0xc8, 0x98, 0x10, 0x19, 0x31, 0x33
    byte: 0x63, 0x63, 0x67, 0xe7, 0xe7, 0x6, 0xe, 0xc, 0x1c, 0x1c, 0x18, 0x18, 0x18, 0xc0, 0xc0, 0x80
    byte: 0x80, 0x80, 0x0, 0x0, 0x0, 0x30, 0x30, 0x60, 0x60, 0x60, 0xe0, 0xe0, 0xe0, 0xc7, 0xc7, 0xc7
    byte: 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x20, 0x20, 0x20
    byte: 0x20, 0x20, 0x20, 0x20, 0x20, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0

def introsq2data:

    byte: 0xc2
    //7/8 seconds    +
    byte: 0xb4
    //D6        |
    byte: 0x64
    //A#6        |
    byte: 0x74
    //F6        |
    byte: 0x6a
    //No sound    | Repeat 2 times.
    byte: 0x2
    //D6        |
    byte: 0x64
    //C7        |
    byte: 0x78
    //A#6        |
    byte: 0x74
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc2
    //7/32 seconds    +
    byte: 0xb2
    //A6        |
    byte: 0x72
    //A5        |
    byte: 0x5a
    //G6        |
    byte: 0x6e
    //G5        |
    byte: 0x56
    //F#6        |
    byte: 0x6c
    //F#5        |
    byte: 0x54
    //E6        | Repeat 2 times.
    byte: 0x68
    //E5        |
    byte: 0x50
    //G6        |
    byte: 0x6e
    //G5        |
    byte: 0x56
    //F#6        |
    byte: 0x6c
    //F#5        |
    byte: 0x54
    //E6        |
    byte: 0x68
    //E5        |
    byte: 0x50
    //D6        |
    byte: 0x64
    //D5        +
    byte: 0x4c
    byte: 0xff
    byte: 0xc4
    //A6        +
    byte: 0x72
    //A5        |
    byte: 0x5a
    //G6        |
    byte: 0x6e
    //A5        |
    byte: 0x5a
    //F#6        |
    byte: 0x6c
    //A5        |
    byte: 0x5a
    //E6        |
    byte: 0x68
    //A5        | Repeat 4 times.
    byte: 0x5a
    //G6        |
    byte: 0x6e
    //G5        |
    byte: 0x56
    //F#6        |
    byte: 0x6c
    //G5        |
    byte: 0x56
    //E6        |
    byte: 0x68
    //G5        |
    byte: 0x56
    //D6        |
    byte: 0x64
    //G5        +
    byte: 0x56
    byte: 0xff
    //7/32 seconds
    byte: 0xb2
    //A5
    byte: 0x5a
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //G5
    byte: 0x56
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //F#5
    byte: 0x54
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //E5
    byte: 0x50
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //A5
    byte: 0x5a
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //G5
    byte: 0x56
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //F5
    byte: 0x52
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //E5
    byte: 0x50
    //7/64 seconds
    byte: 0xb1
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //A5
    byte: 0x5a
    //7/64 seconds
    byte: 0xb1
    //A#4
    byte: 0x44
    //7/32 seconds
    byte: 0xb2
    //G5
    byte: 0x56
    //7/64 seconds
    byte: 0xb1
    //A#4
    byte: 0x44
    //7/32 seconds
    byte: 0xb2
    //F5
    byte: 0x52
    //7/64 seconds
    byte: 0xb1
    //A#4
    byte: 0x44
    //7/32 seconds
    byte: 0xb2
    //G5
    byte: 0x56
    //7/64 seconds
    byte: 0xb1
    //A#4
    byte: 0x44
    byte: 0xc4
    //A5        +
    byte: 0x5a
    //E5        | Repeat 4 times.
    byte: 0x50
    //B4        +
    byte: 0x46
    byte: 0xff
    byte: 0xc3
    //Ab5        +
    byte: 0x58
    //E5        | Repeat 3 times.
    byte: 0x50
    //B4        +
    byte: 0x46
    byte: 0xff
    //Ab5
    byte: 0x58
    //E5
    byte: 0x50
    //1/4 seconds
    byte: 0xb0
    //B4
    byte: 0x46
    //No sound
    byte: 0x2
    byte: 0xe0
    //21/32 seconds    +
    byte: 0xb6
    //D3        | Repeat 32 times.
    byte: 0x1c
    //7/32 seconds    |
    byte: 0xb2
    //No sound    +
    byte: 0x2
    byte: 0xff
    //End intro music.
    byte: 0x0

def introtriangledata:

    byte: 0xd0
    //21/32 seconds    +
    byte: 0xb6
    //A3        |
    byte: 0x2a
    //7/64 seconds    | Repeat 16 times.
    byte: 0xb1
    //A3        |
    byte: 0x2a
    //7/64 seconds    |
    byte: 0xb1
    //No sound    +
    byte: 0x2
    byte: 0xff
    //7/8 seconds
    byte: 0xb4
    //D5
    byte: 0x4c
    //C6
    byte: 0x60
    //B5
    byte: 0x5e
    //A#5
    byte: 0x5c
    //F#5
    byte: 0x54
    //C6
    byte: 0x60
    //A#5
    byte: 0x5c
    //G5
    byte: 0x56
    byte: 0xc2
    //D4        +
    byte: 0x34
    //C5        |
    byte: 0x48
    //B4        |
    byte: 0x46
    //A#4        | Repeat 2 times.
    byte: 0x44
    //F#4        |
    byte: 0x3c
    //C5        |
    byte: 0x48
    //A#4        |
    byte: 0x44
    //G4        +
    byte: 0x3e
    byte: 0xff
    byte: 0xc2
    //7/32 seconds    +
    byte: 0xb2
    //D4        |
    byte: 0x34
    //7/64 seconds    | Repeat 2 times.
    byte: 0xb1
    //A4        |
    byte: 0x42
    //1 13/16 seconds|
    byte: 0xb5
    //D5        +
    byte: 0x4c
    byte: 0xff
    byte: 0xc2
    //7/32 seconds    +
    byte: 0xb2
    //A#3        |
    byte: 0x2c
    //7/64 seconds    | Repeat 2 times.
    byte: 0xb1
    //F4        |
    byte: 0x3a
    //1 13/16 seconds|
    byte: 0xb5
    //C5        +
    byte: 0x48
    byte: 0xff
    byte: 0xc2
    //7/32 seconds    +
    byte: 0xb2
    //D#3        |
    byte: 0x1e
    //7/64 seconds    | Repeat 2 times.
    byte: 0xb1
    //A#3        |
    byte: 0x2c
    //1 13/16 seconds|
    byte: 0xb5
    //D#4        +
    byte: 0x36
    byte: 0xff
    byte: 0xc4
    //7/32 seconds    +
    byte: 0xb2
    //E3        |
    byte: 0x20
    //7/64 seconds    | Repeat 4 times.
    byte: 0xb1
    //B3        |
    byte: 0x2e
    //1 13/16 seconds|
    byte: 0xb5
    //E4        +
    byte: 0x38
    byte: 0xff
    byte: 0xe0
    //21/32 seconds    +
    byte: 0xb6
    //A3        |
    byte: 0x2a
    //7/64 seconds    | Repeat 32 times.
    byte: 0xb1
    //A3        |
    byte: 0x2a
    //7/64 seconds    |
    byte: 0xb1
    //No sound    +
    byte: 0x2
    byte: 0xff

def introsq1data:

def title_page_B0B9:
    byte: 0xd0
    //21/32 seconds    +
    byte: 0xb6
    //D2        | Repeat 16 times.
    byte: 0x6
    //7/32 seconds    |
    byte: 0xb2
    //No sound    +
    byte: 0x2
    byte: 0xff
    byte: 0xc8
    //7/8 seconds    + Repeat 8 times.
    byte: 0xb4
    //No sound    +
    byte: 0x2
    byte: 0xff
    //7/32 seconds
    byte: 0xb2
    //F#3
    byte: 0x24
    //G3
    byte: 0x26
    //A3
    byte: 0x2a
    //B3
    byte: 0x2e
    //D4
    byte: 0x34
    //E4
    byte: 0x38
    //F#4
    byte: 0x3c
    //G4
    byte: 0x3e
    //21/32 seconds
    byte: 0xb6
    //A4
    byte: 0x42
    //7/64 seconds
    byte: 0xb1
    //G4
    byte: 0x3e
    //F#4
    byte: 0x3c
    //21/32 seconds
    byte: 0xb6
    //G4
    byte: 0x3e
    //7/64 seconds
    byte: 0xb1
    //F#4
    byte: 0x3c
    //E4
    byte: 0x38
    //21/32 seconds
    byte: 0xb6
    //D4
    byte: 0x34
    //7/32 seconds
    byte: 0xb2
    //A4
    byte: 0x42
    //7/8 seconds
    byte: 0xb4
    //D5
    byte: 0x4c
    //7/16 seconds
    byte: 0xb3
    //A#4
    byte: 0x44
    //A4
    byte: 0x42
    //G4
    byte: 0x3e
    //F#4
    byte: 0x3c
    //21/32 seconds
    byte: 0xb6
    //E4
    byte: 0x38
    //7/32 seconds
    byte: 0xb2
    //F#4
    byte: 0x3c
    //21/32 seconds
    byte: 0xb6
    //A4
    byte: 0x42
    //7/32 seconds
    byte: 0xb2
    //D5
    byte: 0x4c
    //21/32 seconds
    byte: 0xb6
    //E4
    byte: 0x38
    //7/32 seconds
    byte: 0xb2
    //F#4
    byte: 0x3c
    //7/8 seconds
    byte: 0xb4
    //D4
    byte: 0x34
    //7/16 seconds
    byte: 0xb3
    //A3
    byte: 0x2a
    //B3
    byte: 0x2e
    //D4
    byte: 0x34
    //E4
    byte: 0x38
    //21/32 seconds
    byte: 0xb6
    //D4
    byte: 0x34
    //7/32 seconds
    byte: 0xb2
    //A#3
    byte: 0x2c
    //7/8 seconds
    byte: 0xb4
    //G3
    byte: 0x26
    //1 13/16 seconds
    byte: 0xb5
    //E4
    byte: 0x38
    //F#4
    byte: 0x3c
    //A4
    byte: 0x42
    //D5
    byte: 0x4c
    //D4
    byte: 0x34
    //F4
    byte: 0x3a
    //C5
    byte: 0x48
    //A4
    byte: 0x42
    //D#4
    byte: 0x36
    //G4
    byte: 0x3e
    //D5
    byte: 0x4c
    //A#4
    byte: 0x44
    //A4
    byte: 0x42
    //E4
    byte: 0x38
    //B3
    byte: 0x2e
    //E4
    byte: 0x38
    //Ab4
    byte: 0x40
    //E4
    byte: 0x38
    //B3
    byte: 0x2e
    //E4
    byte: 0x38
    byte: 0xe0
    //21/32 seconds    +
    byte: 0xb6
    //D2        | Repeat 32 times.
    byte: 0x6
    //7/32 seconds    |
    byte: 0xb2
    //No sound    +
    byte: 0x2
    byte: 0xff

def intronoiseindexdata:

    byte: 0xd0
    //7/8 Seconds    + Repeat 16 times.
    byte: 0xb4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff
    byte: 0xcc
    //7/32 Seconds    +
    byte: 0xb2
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //1 13/16 Seconds|
    byte: 0xb5
    //Drumbeat 02    |
    byte: 0x7
    //1/4 Seconds    |
    byte: 0xb0
    //Drumbeat 01    | Repeat 12 times.
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //21/32 Seconds    |
    byte: 0xb6
    //Drumbeat 01    |
    byte: 0x4
    //7/64 Seconds    |
    byte: 0xb1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff
    byte: 0xca
    //7/64 Seconds    +
    byte: 0xb1
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    | Repeat 10 times.
    byte: 0x4
    //Drumbeat 02    |
    byte: 0x7
    //Drumbeat 01    |
    byte: 0x4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff
    byte: 0xe0
    //7/8 Seconds    + Repeat 32 times.
    byte: 0xb4
    //Drumbeat 01    +
    byte: 0x4
    byte: 0xff

//Unused tile patterns.
    byte: 0xe0, 0xe0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x21, 0x80, 0x40, 0x2, 0x5
    byte: 0x26, 0x52, 0x63, 0x0, 0x0, 0x0, 0x6, 0x7, 0x67, 0x73, 0x73, 0xff, 0xaf, 0x2f, 0x7, 0xb
    byte: 0x8d, 0xa7, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x80, 0xf8, 0xb8, 0xf8, 0xf8, 0xf0
    byte: 0xf0, 0xf8, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x7, 0x7, 0x7, 0x7
    byte: 0x3, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xff, 0xc7, 0x83, 0x3, 0xc7
    byte: 0xcf, 0xfe, 0xec, 0x0, 0x30, 0x78, 0xf8, 0x30, 0x0, 0x1, 0x12, 0xf5, 0xea, 0xfb, 0xfd, 0xf9
    byte: 0x1e, 0xe, 0x44, 0x7, 0x3, 0x3, 0x1, 0x1, 0xe0, 0x10, 0x48, 0x2b, 0x3b, 0x1b, 0x5a, 0xd0
    byte: 0xd1, 0xc3, 0xc3, 0x3b, 0x3b, 0x9b, 0xda, 0xd0, 0xd0, 0xc0, 0xc0, 0x2c, 0x23, 0x20, 0x20, 0x30
    byte: 0x98, 0xcf, 0xc7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x1f, 0x80, 0xc0, 0xc0, 0x60
    byte: 0x70, 0xfc, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x80, 0x80, 0xc0, 0x78, 0x4c, 0xc7, 0x80, 0x80, 0xc4, 0xa5, 0x45, 0xb, 0x1b
    byte: 0x3, 0x3, 0x0, 0x3a, 0x13, 0x31, 0x63, 0xc3, 0x83, 0x3, 0x4, 0xe6, 0xe6, 0xc4, 0x8e, 0x1c
    byte: 0x3c, 0x18, 0x30, 0xe8, 0xe8, 0xc8, 0x90, 0x60, 0x0, 0x0, 0x0

//------------------------------------------[ Sound Engine ]------------------------------------------

//SFXdata. The top four entries are used by the noise music player for drum beats.
def title_page_B200:
    //Base for drum beat music data.
    byte: 0x0

def drumbeat00sfxdata:

def title_page_B201:
    //Noise channel music data #$01.
    byte: 0x10, 0x1, 0x18
def drumbeat01sfxdata:

    //Noise channel music data #$04.
    byte: 0x0, 0x1, 0x38
def drumbeat02sfxdata:

    //Noise channel music data #$07.
    byte: 0x1, 0x2, 0x40
def drumbeat03sfxdata:

    //Noise channel music data #$0A.
    byte: 0x0, 0x9, 0x58
def gamepausedsfxdata:

    byte: 0x80, 0x7f, 0x80, 0x48
def screwattsfxdata:

    byte: 0x35, 0x7f, 0x0, 0xb0
def missilelaunchsfxdata:

    byte: 0x19, 0x7f, 0xe, 0xa0
def bombexplodesfxdata:

    byte: 0xd, 0x7f, 0xf, 0x8
def samuswalksfxdata:

    byte: 0x16, 0x7f, 0xb, 0x18
def spitflamesfxdata:

    byte: 0x13, 0x7f, 0xe, 0xf8
def samushitsq1sq2sfxdata:

    byte: 0xc1, 0x89, 0x2, 0xf
def bosshitsq2sfxdata:

    byte: 0x34, 0xba, 0xe0, 0x5
def bosshitsq1sfxdata:

    byte: 0x34, 0xbb, 0xce, 0x5
def incorrectpasswordsq1sfxdata:

    byte: 0xb6, 0x7f, 0x0, 0xc2
def incorrectpasswordsq2sfxdata:

    byte: 0xb6, 0x7f, 0x4, 0xc2
def timebombticksfxdata:

    byte: 0x17, 0x7f, 0x66, 0x89
def energypickupsfxdata:

    byte: 0x89, 0x7f, 0x67, 0x18
def missilepickupsfxdata:

    byte: 0x8b, 0x7f, 0xfd, 0x28
def metalsfxdata:

    byte: 0x2, 0x7f, 0xa8, 0xf8
def longrangeshotsfxdata:

    byte: 0xd7, 0x83, 0x58, 0xf8
def shortrangeshotsfxdata:

    byte: 0xd6, 0x82, 0x58, 0xf8
def jumpsfxdata:

    byte: 0x95, 0x8c, 0x40, 0xb9
def enemyhitsfxdata:

    byte: 0x1d, 0x9a, 0x20, 0x8f
def bugoutofholesfxdata:

    byte: 0x16, 0x8d, 0xe0, 0x42
def wavebeamsfxdata:

    byte: 0x19, 0x7f, 0x6f, 0x40
def icebeamsfxdata:

    byte: 0x18, 0x7f, 0x80, 0x40
def bomblaunch1sfxdata:

    byte: 0x7, 0x7f, 0x40, 0x28
def bomblaunch2sfxdata:

    byte: 0x7, 0x7f, 0x45, 0x28
def samustoballsfxdata:

    byte: 0x7f, 0x7f, 0xdd, 0x3b
def metroidhitsfxdata:

    byte: 0x7f, 0x7f, 0xff, 0x98
def samusdiesfxdata:

    byte: 0x7f, 0x7f, 0x40, 0x8
def samusbeepsfxdata:

    byte: 0x9, 0x7f, 0x30, 0x48
def bigenemyhitsfxdata:

    byte: 0x3, 0x7f, 0x42, 0x18
def statueraisesfxdata:

    byte: 0x3, 0x7f, 0x11, 0x9
def doorsfxdata:

    byte: 0x7f, 0x7f, 0x30, 0xb2

//The following table is used by the CheckSFXFlag routine.  The first two bytes of each row
//are the address of the pointer table used for handling SFX and music  routines for set flags.
//The second pair of bytes is the address of the routine to next jump to if no SFX or music
//flags were found.  The final byte represents what type of channel is currently being
//processed: 0=Noise, 1=SQ1, 3=Triangle, 4=Multiple channels.

def choosenextsfxroutinetbl:


    //Noise init SFX        (1st).
    word: title_page_B2BB, 0xb322
    byte: 0x0
    
    //Noise continue SFX    (2nd).
    word: title_page_B2CB, title_page_B4EE
    byte: 0x0

    //SQ1 init SFX        (5th).
    word: title_page_B2DB, 0xb330
    byte: 0x1

    //SQ2 continue SFX    (6th).
    word: title_page_B2EB, title_page_B4EE
    byte: 0x1

    //Triangle init SFX    (7th).
    word: title_page_B2FB, 0xb344
    byte: 0x3

    //Triangle continue SFX    (8th).
    word: title_page_B30B, title_page_B4EE
    byte: 0x3

    //Multi init SFX        (3rd).
    word: title_page_BC06, 0xb35c
    byte: 0x4

    //Multi continue SFX    (4th).
    word: title_page_BC16, 0xb364
    byte: 0x4

    //temp flag Music    (10th).
    word: title_page_BC26, 0xbc4b
    byte: 0x0

    //Music            (9th).
    word: title_page_BC26, 0xbc3d
    byte: 0x0

//The tables below contain addresses for SFX handling routines.

//Noise Init SFX handling routine addresses:
def title_page_B2BB:
    //No sound.
    word: title_page_B4EE
    //Screw attack init SFX.
    word: title_page_B52B
    //Missile launch init SFX.
    word: title_page_B56E
    //Bomb explode init SFX.
    word: title_page_B583
    //Samus walk init SFX.
    word: title_page_B598
    //Spit flame init SFX.
    word: title_page_B50F
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE

//Noise Continue SFX handling routine addresses:

def title_page_B2CB:
    //No sound.
    word: title_page_B4EE
    //Screw attack continue SFX.
    word: title_page_B539
    //Missile launch continue SFX.
    word: title_page_B57B
    //Bomb explode continue SFX.
    word: title_page_B58A
    //Samus walk continue SFX.
    word: title_page_B58A
    //Spit flame continue SFX.
    word: title_page_B516
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE

//SQ1 Init SFX handling routine addresses:

def title_page_B2DB:
    //Missile pickup init SFX.
    word: title_page_B6CD
    //Energy pickup init SFX.
    word: title_page_B6E7
    //Metal init SFX.
    word: title_page_B735
    //Bullet fire init SFX.
    word: title_page_B716
    //Bird out of hole init SFX.
    word: title_page_B73C
    //Enemy hit init SFX.
    word: title_page_B710
    //Samus jump init SFX.
    word: title_page_B703
    //Wave beam init SFX.
    word: title_page_B77A

//SQ1 Continue SFX handling routine addresses:

def title_page_B2EB:
    //Missile pickup continue SFX.
    word: title_page_B6B0
    //Energy pickup continue SFX.
    word: title_page_B6D3
    //Metal continue SFX.
    word: title_page_B6ED
    //Bullet fire continue SFX.
    word: title_page_B74F
    //Bird out of hole continue SFX.
    word: title_page_B6ED
    //Enemy hit continue SFX.
    word: title_page_B6ED
    //Samus jump continue SFX.
    word: title_page_B6ED
    //Wave beam continue SFX.
    word: title_page_B781

//Triangle init handling routine addresses:

def title_page_B2FB:
    //Samus die init SFX.
    word: title_page_B8D2
    //Door open close init SFX.
    word: title_page_B7AC
    //Metroid hit init SFX.
    word: title_page_B8A7
    //Statue raise init SFX.
    word: title_page_B921
    //Beep init SFX.
    word: title_page_B7D9
    //Big enemy hit init SFX.
    word: title_page_B7EF
    //Samus to ball init SFX.
    word: title_page_B834
    //Bomb launch init SFX.
    word: title_page_B878

//Triangle continue handling routine addresses:

def title_page_B30B:
    //Samus die continue SFX.
    word: title_page_B8ED
    //Door open close continue SFX.
    word: title_page_B7CB
    //Metroid hit continue SFX.
    word: title_page_B8B1
    //Statue raise continue SFX.
    word: title_page_B940
    //Beep continue SFX.
    word: title_page_B7E7
    //Big enemy hit continue SFX.
    word: title_page_B80E
    //Samus to ball continue SFX.
    word: title_page_B84F
    //Bomb launch continue SFX.
    word: title_page_B87F

def loadnoisesfxinitflags:

    //Load A with Noise init SFX flags, (1st SFX cycle).
    a = [noisesfxflag]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0x89
    //Branch always.
    goto gotosfxcheckflags when ~zero

def loadnoisesfxcontflags:

    //Load A with Noise continue flags, (2nd SFX cycle).
    a = [noisecontsfx]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0x8e
    //Branch always.
    goto gotosfxcheckflags when ~zero

def loadsq1sfxinitflags:

    //Load A with SQ1 init flags, (5th SFX cycle).
    a = [sq1sfxflag]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0x93
    //Branch always.
    goto gotosfxcheckflags when ~zero

def loadsq1sfxcontflags:

    //Load A with SQ1 continue flags, (6th SFX cycle).
    a = [sq1contsfx]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0x98
    //Branch always.
    goto gotosfxcheckflags when ~zero

def gotosfxcheckflags:

    //($B4BD)Checks to see if SFX flags set.
    call checksfxflag
    //if no flag found, Jump to next SFX cycle,-->
    goto [0xe2]
                    //else jump to specific SFX handling routine.
def loadstrianglesfxinitflags:

    //Load A with Triangle init flags, (7th SFX cycle).
    a = [trianglesfxflag]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0x9d
    //Brach always.
    goto gotosfxcheckflags when ~zero

def loadtrianglesfxcontflags:

    //Load A with Triangle continue flags, (8th SFX cycle).
    a = [trianglecontsfx]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0xa2
    //Branch always.
    goto gotosfxcheckflags when ~zero

def loadmultisfxinitflags:

    //Load A with Multi init flags, (3rd SFX cycle).
    a = [multisfxflag]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0xa7
    //($B4BD)Checks to see if SFX or music flags set.
    call checksfxflag
    //($BC53)Find bit containing music init flag.
    call findmusicinitindex
    //($BC64)Add 8 to MusicInitIndex.
    call add8
    //If no flag found, Jump to next SFX cycle,-->
    goto [0xe2]
                    //else jump to specific SFX handling subroutine.
def loadmultisfxcontflags:

    //Load A with $68C flags (4th SFX cycle).
    a = [multicontsfx]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0xac
    //($B337)Checks to see if SFX or music flags set.
    goto gotosfxcheckflags

def loadsq1flags:

    //($B329)Check for SQ1 init flags.
    call loadsq1sfxinitflags
    return

def loadsq1channelsfx:
            //Used to determine which sound registers to change-->
    //($4000 - $4003) - SQ1.
    a = 0x0
    //Branch always.
    goto _00BF when zero

def loadtrianglechannelsfx:
            //Used to determine which sound registers to change-->
    //($4008 - $400B) - Triangle.
    a = 0x8
    //Branch always.
    goto _00BF when ~zero

def loadnoisechannelsfx:
            //Used to determine which sound registers to change-->
    //($400C - $400F) - Noise.
    a = 0xc
    //Branch always.
    goto _00BF when ~zero

def loadsq2channelsfx:
            //Used to determine which sound registers to change-->
    //($4004 - $4007) - SQ2.
    a = 0x4

def loadsfxdata:

def _00BF:
    //Lower address byte of desired APU control register.
    [0xe0] = a
    a = 0x40
    //Upper address byte of desired APU control register.
    [0xe1] = a
    //Lower address byte of data to load into sound channel.
    [0xe2] = y
    a = 0xb2
    //Upper address byte of data to load into sound channel.
    [0xe3] = a
    //Starting index for loading four byte sound data.
    y = 0x0

def loadsfxregisters:

def _00C0:
    //Load A with SFX data byte.
    a = [[0xe2]:y]
    //Store A in SFX register.
    [[0xe0]:y] = a
    y++
    //The four registers associated with each sound-->
    a = y
    //channel are loaded one after the other (the loop-->
    compare a to 0x4
    //repeats four times).
    goto _00C0 when ~zero
    return

def pausesfx:

def _00C1:
    //SFXPaused=#$01
    [sfxpaused]++
    //($B43E)Clear sound registers of data.
    call clearsounds
    //PauseSFXStatus=#$00
    [pausesfxstatus] = a
    return

def _00C2:
    //Has SFXPaused been set? if not, branch
    a = [sfxpaused]
    goto _00C1 when zero
    //For the first #$12 frames after the game has been-->
    a = [pausesfxstatus]
    //paused, play GamePaused SFX.  If paused for #$12-->
    compare a to 0x12
    //frames or more, branch to exit.
    goto _00C4 when zero
    a = a & 0x3
    //Every fourth frame, repeat GamePaused SFX
    compare a to 0x3
    goto _00C3 when ~zero
    //Lower address byte of GamePaused SFX data(Base=$B200)
    y = 0xd
    //($B368) Load GamePaused SFX data.
    call loadsq1channelsfx
def _00C3:
    [pausesfxstatus]++
def _00C4:
    return

//----------------------------------[ Sound Engine Entry Point ]-----------------------------------
//NOTES:  
//SFX take priority over music.
//
//There are 10 SFX cycles run every time the sound engine subroutine is called.  The cycles
//search for set sound flags in the following registers in order:
//$680, $688, $684, $68C, $681, $689, $683, $68B, $65D, $685 
//
//The sound channels are assigned SFX numbers.  Those SFX numbers are:
//Noise=0, sq1=1, sq2=2, triangle=3, Multi=4
//The sound channels are assigned music numbers.  Those music numbers are:
//SQ1=0, SQ2=1, Triangle=2, Noise=3

def soundengine:
 
    //Set APU to 5 frame cycle, disable frame interrupt.
    a = 0xc0
    [nes.apu.sequencer] = a
    //is bit zero is set in NoiseSFXFlag(Silence-->
    a = [noisesfxflag]
    //music)?  If yes, branch.
    a = a >> 1
    goto _00C6 when carry
    a = [mainroutine]
    //Is game paused?  If yes, branch.
    compare a to 0x5
    goto _00C2 when zero
    //Clear SFXPaused when game is running.
    a = 0x0
    [sfxpaused] = a
    //($B31B)Check noise SFX flags.
    call loadnoisesfxinitflags
    //($B34B)Check multichannel SFX flags.
    call loadmultisfxinitflags
    //($B33D)Check triangle SFX flags.
    call loadstrianglesfxinitflags
    //($BC36)Check music flags.
    call loadmusictempflags

def clearsfxflags:

def _00C5:
    a = 0x0
    [noisesfxflag] = a
    [sq1sfxflag] = a
    //Clear all SFX flags.
    [sq2sfxflag] = a
    [trianglesfxflag] = a
    [multisfxflag] = a
    [musicinitflag] = a
    return

def _00C6:
    //($B404)Prepare to start playing music.
    call initializesoundaddresses
    //Branch always.
    goto _00C5 when zero

def checkrepeatmusic:

    a = [musicrepeat]
    //If music is supposed to repeat, reset music,-->
    goto _00C7 when zero
    //flags else branch to exit.
    a = [currentmusic]
    [currentmusicrepeat] = a
    return

def checkmusicflags:

    //Loads A with current music flags and compares it-->
    a = [currentmusic]
    //with current SFX flags.  If both are equal,-->
    compare a to [currentsfxflags]
    //just clear music counters, else clear everything.
    goto _00C8 when zero

def initializesoundaddresses:
        //
def _00C7:
    //($B41D)Jumps to all subroutines needed to reset-->
    call clearmusicandsfxaddresses
    //($B43E)all sound addresses in order to start-->
    call clearsounds
def _00C8:
    //($B40E)playing music.
    call clearspecialaddresses
    return

def clearspecialaddresses:

    a = 0x0
    //Clears addresses used for repeating music,-->
    [trianglecountercntrl] = a
    //pausing music and controlling triangle length.
    [sfxpaused] = a
    [currentmusicrepeat] = a
    [musicrepeat] = a
    return

def clearmusicandsfxaddresses:
        //
    a = 0x0
    [sq1inuse] = a
    [sq2inuse] = a
    [triangleinuse] = a
    [writemultichanneldata] = a
    //Clears any SFX or music-->
    [noisecontsfx] = a
    //currently being played.
    [sq1contsfx] = a
    [sq2contsfx] = a
    [trianglecontsfx] = a
    [multicontsfx] = a
    [currentmusic] = a
    return

def clearsounds:
                //
    a = 0x10
    [nes.apu.square1.ctrl] = a
    [nes.apu.square2.ctrl] = a
    //Clears all sounds that might be in-->
    [nes.apu.noise.ctrl] = a
    //The sound channel registers.
    a = 0x0
    [nes.apu.triangle.ctrl] = a
    [nes.apu.dmc.load] = a
    return

def selectsfxroutine:

    x = [channeltype]
    //Stores frame length of SFX in corresponding address.
    [noisesfxlength:x] = a
    a = x
    //Branch if SFX uses noise channel.
    goto _00CA when zero
    compare a to 0x1
    //Branch if SFX uses SQ1 channel.
    goto _00C9 when zero
    compare a to 0x2
    //Branch if SFX uses SQ2 channel.
    goto musicbranch00 when zero
    compare a to 0x3
    //Branch if SFX uses triangle wave.
    goto musicbranch01 when zero
    //Exit if SFX routine uses no channels.
    return

def _00C9:
    //($B368)Prepare to load SQ1 channel with data.
    call loadsq1channelsfx
    //Branch always.
    goto _00CB when zero
def musicbranch00:
                //
    //($B374)Prepare to load SQ2 channel with data.
    call loadsq2channelsfx
    //Branch always.
    goto _00CB when zero
def musicbranch01:
                //
    //($B36C)Prepare to load triangle channel with data.
    call loadtrianglechannelsfx
    //Branch always.
    goto _00CB when zero
def _00CA:
    //($B370)Prepare to load noise channel with data.
    call loadnoisechannelsfx
def _00CB:
    //($B493)Set continuation flags for this SFX.
    call updatecontflags
    a = x
    //Indicate sound channel is in use.
    [noiseinuse:x] = a
    a = 0x0
    [thisnoiseframe:x] = a
    //Clears all the following addresses before going-->
    [noisesfxdata:x] = a
    //to the proper SFX handling routine.
    [multisfxdata:x] = a
    [screwattacksfxdata:x] = a
    [writemultichanneldata] = a
    return

def updatecontflags:

def _00CC:
    //Loads X register with sound channel just changed.
    x = [channeltype]
    //Clear existing continuation SFX-->
    a = [noisecontsfx:x]
    //flags for that channel.
    a = a & 0x0
    //Load new continuation flags.
    a = a | [currentsfxflags]
    //Save results.
    [noisecontsfx:x] = a
    return

def clearcurrentsfxflags:

    //Once SFX has completed, this block clears the-->
    a = 0x0
    //SFX flag from the current flag register.
    [currentsfxflags] = a
    goto _00CC when zero

def incrementsfxframe:

    //Load SFX channel number.
    x = [channeltype]
    //increment current frame to play on given channel.
    [thisnoiseframe:x]++
    //Load current frame to play on given channel.
    a = [thisnoiseframe:x]
    //Check to see if current frame is last frame to play.
    compare a to [noisesfxlength:x]
    goto _00CD when ~zero
    //If current frame is last frame,-->
    a = 0x0
    //reset current frame to 0.
    [thisnoiseframe:x] = a
def _00CD:
    return

//The CheckSFXFlag routine loads E0 thru E3 with the below values:
//1st  SFX cycle $E0=#$BB,$E1=#$B2,$E2=#$22,$E3=#$B3.  Base address=$B289
//2nd  SFX cycle $E0=#$CB,$E1=#$B2,$E2=#$EE,$E3=#$B4.  Base address=$B28E
//3rd  SFX cycle $E0=#$06,$E1=#$BC,$E2=#$5C,$E3=#$B3.  Base address=$B2A7
//4th  SFX cycle $E0=#$16,$E1=#$BC,$E2=#$64,$E3=#$B3.  Base address=$B2AC
//5th  SFX cycle $E0=#$DB,$E1=#$B2,$E2=#$30,$E3=#$B3.  Base address=$B293
//6th  SFX cycle $E0=#$EB,$E1=#$B2,$E2=#$EE,$E3=#$B4.  Base address=$B298
//7th  SFX cycle $E0=#$FB,$E1=#$B2,$E2=#$44,$E3=#$B3.  Base address=$B29D
//8th  SFX cycle $E0=#$0B,$E1=#$B3,$E2=#$EE,$E3=#$B4.  Base address=$B2A2
//9th  SFX cycle $E0=#$26,$E1=#$BC,$E2=#$3D,$E3=#$BC.  Base address=$B2B6
//10th SFX cycle $E0=#$26,$E1=#$BC,$E2=#$4B,$E3=#$BC.  Base address=$B2B1

def checksfxflag:

    //Store any set flags in $064D.
    [currentsfxflags] = a
    [0xe4] = x
    y = 0xb2
    [0xe5] = y
    //Y=0 for counting loop ahead.
    y = 0x0
def _00CE:
    a = [[0xe4]:y]
    //See table above for values loaded into $E0-->
    [0xe0:y] = a
    //thru $E3 during this loop.
    y++
    a = y
    //Loop repeats four times to load the values.
    compare a to 0x4
    goto _00CE when ~zero
    a = [[0xe4]:y]
    //#$00=SQ1,#$01=SQ2,#$02=Triangle,#$03=Noise
    [channeltype] = a
    //Set y to 0 for counting loop ahead.
    y = 0x0
    a = [currentsfxflags]
    //Push current SFX flags on stack.
    push a
def _00CF:
    [currentsfxflags] = [currentsfxflags] << 1
    //This portion of the routine loops a maximum of-->
    goto _00D0 when carry
    //eight times looking for any SFX flags that have-->
    y++
    //been set in the current SFX cycle.  If a flag-->
    y++
    //is found, Branch to SFXFlagFound for further-->
    a = y
    //processing, if no flags are set, continue to-->
    compare a to 0x10
    //next SFX cycle.
    goto _00CF when ~zero

def restoresfxflags:

    a = pop
    //Restore original data in CurrentSFXFlags.
    [currentsfxflags] = a
def title_page_B4EE:
    return

def sfxflagfound:
                //
def _00D0:
    //This routine stores the starting address of the-->
    a = [[0xe0]:y]
    //specific SFX handling routine for the SFX flag-->
    [0xe2] = a
    //found.  The address is stored in registers-->
    y++
    //$E2 and $E3.
    a = [[0xe0]:y]
    [0xe3] = a
    //($B4EA)Restore original data in CurrentSFXFlags.
    goto restoresfxflags

//-----------------------------------[ SFX Handling Routines ]---------------------------------------

//The following table is used by the SpitFlamesSFXContinue routine to change the volume-->
//on the SFX.  It starts out quiet, then becomes louder then goes quiet again.
def spitflamestbl:

def title_page_B4FB:
    byte: 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1b, 0x1a, 0x19, 0x17
    byte: 0x16, 0x15, 0x14, 0x12

def spitflamesfxstart:

def title_page_B50F:
    //Number of frames to play sound before a change.
    a = 0x14
    //Lower byte of sound data start address(base=$B200).
    y = 0x21
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def spitflamesfxcontinue:

def title_page_B516:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch.
    goto _00D1 when ~zero
    //($B58F)End SFX.
    goto endnoisesfx
def _00D1:
    y = [noisesfxdata]
    //Load data from table above and store in nes.apu.noise.ctrl.
    a = [title_page_B4FB:y]
    [nes.apu.noise.ctrl] = a
    //Increment to next entry in data table.
    [noisesfxdata]++
    return

def screwattacksfxstart:

def title_page_B52B:
    //Number of frames to play sound before a change.
    a = 0x5
    //Lower byte of sound data start address(base=$B200).
    y = 0x11
    //($B452)Setup registers for SFX.
    call selectsfxroutine
    //#$00.
    a = [0xb213]
    //Clear NoiseSFXData.
    [noisesfxdata] = a
def _00D2:
    return

def screwattacksfxcontinue:

def title_page_B539:
    //Prevents period index from being incremented until-->
    a = [screwattacksfxdata]
    //after the tenth frame of the SFX.
    compare a to 0x2
    //Branch if not ready to increment.
    goto _00D3 when zero
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto _00D2 when ~zero
    //Increment every fifth frame.
    [screwattacksfxdata]++
    return

def _00D3:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //Start increasing period index after first ten frames.
    goto incrementperiodindex when ~zero
    [noisesfxdata]--
    //Decrement NoiseSFXData by three every fifth frame.
    [noisesfxdata]--
    [noisesfxdata]--
    //Increment MultiSFXData.  When it is equal to #$0F-->
    [multisfxdata]++
    //end screw attack SFX.  MultiSFXData does not-->
    a = [multisfxdata]
    //appear to be linked to multi SFX channels in-->
    compare a to 0xf
    //this routine.
    goto _00D2 when ~zero
    //($B58F)End SFX.
    goto endnoisesfx

def incrementperiodindex:

    //Incrementing the period index has the effect of-->
    [noisesfxdata]++
    //lowering the frequency of the noise SFX.
    a = [noisesfxdata]
    [nes.apu.noise.random] = a
    return

def missilelaunchsfxstart:

def title_page_B56E:
    //Number of frames to play sound before a change.
    a = 0x18
    //Lower byte of sound data start address(base=$B200).
    y = 0x15
    //($B587)Prepare to setup registers for SFX.
    call gotoselectsfxroutine
    a = 0xa
    //Start increment index for noise channel at #$0A.
    [noisesfxdata] = a
    return

def missilelaunchsfxcontine:

def title_page_B57B:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto incrementperiodindex when ~zero
    //($B58F)End SFX.
    goto endnoisesfx

def bombexplodesfxstart:

def title_page_B583:
    //Number of frames to play sound before a change.
    a = 0x30
    //Lower byte of sound data start address(base=$B200).
    y = 0x19

def gotoselectsfxroutine:

def _00D4:
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

//The following routine is used to continue BombExplode and SamusWalk SFX.

def noisesfxcontinue:

def title_page_B58A:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto musicbranch02 when ~zero

def endnoisesfx:

    //($B4A2)Clear all SFX flags.
    call clearcurrentsfxflags
    a = 0x10
    //disable envelope generator(sound off).
    [nes.apu.noise.ctrl] = a

def musicbranch02:

    //Exit for multiple routines.
    return
 
def samuswalksfxstart:

def title_page_B598:
    //If MissileLaunch, SamusWalk or SpitFire SFX are-->
    a = [noisecontsfx]
    //already being played, branch to exit.
    a = a & 0x34
    goto musicbranch02 when ~zero
    //Number of frames to play sound before a change.
    a = 0x3
    //Lower byte of sound data start address(base=$B200).
    y = 0x1d
    //Branch always.
    goto _00D4 when ~zero

def multisfxinit:

    [multisfxlength] = a
    //($B374)Set SQ2 SFX data.
    call loadsq2channelsfx
    //($B493)Set continue SFX flag.
    call updatecontflags
    a = 0x1
    //Disable music from using SQ1 and SQ2 while-->
    [sq1inuse] = a
    //SFX are playing.
    a = 0x2
    [sq2inuse] = a
    a = 0x0
    [sq1contsfx] = a
    [sq1sfxdata] = a
    //Clear all listed memory addresses.
    [sq1sq2sfxdata] = a
    [sq1sfxperiodlow] = a
    [thismultiframe] = a
    [writemultichanneldata] = a
    return

def endmultisfx:

    a = 0x10
    //Disable SQ1 envelope generator(sound off).
    [nes.apu.square1.ctrl] = a
    //Disable SQ2 envelope generator(sound off).
    [nes.apu.square2.ctrl] = a
    a = 0x7f
    //Disable SQ1 sweep.
    [nes.apu.square1.sweep] = a
    //Disable SQ2 sweep.
    [nes.apu.square2.sweep] = a
    //($B4A2)Clear all SFX flags.
    call clearcurrentsfxflags
    a = 0x0
    [sq1inuse] = a
    //Allows music player to use SQ1 and SQ2 channels.
    [sq2inuse] = a
    [writemultichanneldata]++
    return

def bosshitsfxstart:

def title_page_B5EC:
    //Low byte of SQ1 sound data start address(base=$B200).
    y = 0x2d
    //($B368)Set SQ1 SFX data.
    call loadsq1channelsfx
    //Low byte of SQ2 sound data start address(base=$B200).
    y = 0x29
    //($B5A5)Initiate multi channel SFX.
    goto multisfxinit

def bosshitsfxcontinue:

def title_page_B5F6:
    //Increment index to data in table below.
    [sq1sfxdata]++
    y = [sq1sfxdata]
    a = [title_page_B63C:y]
    //Load SQ1Cntrl0 and SQ2Cntrl0 from table below.
    [nes.apu.square1.ctrl] = a
    [nes.apu.square2.ctrl] = a
    a = [sq1sfxdata]
    //After #$14 frames, end SFX.
    compare a to 0x14
    goto _00D6 when zero
    //After six or more frames of SFX, branch.
    compare a to 0x6
    goto _00D5 when ~carry
    a = [randomnumber1]
    //Set bit 5.
    a = a | 0x10
    //Randomly set bits 7, 3, 2, 1 and 0.
    a = a & 0x7f
    //Store in SQ1 period low.
    [sq1sfxperiodlow] = a
    a = a <<< 1
    [sq1sq2sfxdata] = a
    //($B62C)Write period low data to SQ1 and SQ2.
    goto writesq1sq2periodlow
def _00D5:
    [sq1sq2sfxdata]++
    //Increment SQ1 and SQ2 period low by two.
    [sq1sq2sfxdata]++
    [sq1sfxperiodlow]++
    [sq1sfxperiodlow]++

def writesq1sq2periodlow:

    a = [sq1sq2sfxdata]
    //Write new SQ1 and SQ2 period lows to SQ1 and SQ2-->
    [nes.apu.square2.low] = a
    //channels.
    a = [sq1sfxperiodlow]
    [nes.apu.square1.low] = a
    return

def _00D6:
    //($B5CD)End SFX.
    goto endmultisfx

def bosshitsfxdatatbl:

def title_page_B63C:
    byte: 0x38, 0x3d, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3d, 0x3b, 0x39, 0x3b, 0x3d, 0x3f, 0x3d, 0x3b, 0x39
    byte: 0x3b, 0x3d, 0x3f, 0x39

def samushitsfxcontinue:

def title_page_B650:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more SFX frames to process, branch.
    goto _00D7 when ~zero
    //($B5CD)End SFX.
    goto endmultisfx
def _00D7:
    //Low byte of SQ1 sound data start address(base=$B200).
    y = 0x25
    //($B368)Set SQ1 SFX data.
    call loadsq1channelsfx
    a = [randomnumber1]
    //Randomly set last four bits of SQ1 period low.
    a = a & 0xf
    [nes.apu.square1.low] = a
    //Low byte of SQ2 sound data start address(base=$B200).
    y = 0x25
    //($B374)Set SQ2 SFX data.
    call loadsq2channelsfx
    a = [randomnumber1]
    //Multiply random number by 4.
    a = a >> 1
    a = a >> 1
    a = a & 0xf
    //Randomly set bits 2 and 3 of SQ2 period low.
    [nes.apu.square2.low] = a
    return

def samushitsfxstart:

def title_page_B673:
    //Low byte of SQ1 sound data start address(base=$B200).
    y = 0x25
    //($B368)Set SQ1 SFX data.
    call loadsq1channelsfx
    a = [randomnumber1]
    //Randomly set last four bits of SQ1 period low.
    a = a & 0xf
    [nes.apu.square1.low] = a
    carry = 0
    //Randomly set last three bits of SQ2 period low+1.
    a = [randomnumber1]
    a = a & 0x3
    //Number of frames to play sound before a change.
    a = a +# 0x1
    //Low byte of SQ2 sound data start address(base=$B200).
    y = 0x25
    //($B5A5)Initiate multi channel SFX.
    call multisfxinit
    a = [randomnumber1]
    //Multiply random number by 4.
    a = a >> 1
    a = a >> 1
    a = a & 0xf
    //Randomly set bits 2 and 3 of SQ2 period low.
    [nes.apu.square2.low] = a
def _00D8:
    return

def incorrectpasswordsfxstart:

def title_page_B695:
    //Low byte of SQ1 sound data start address(base=$B200).
    y = 0x31
    //($B368)Set SQ1 SFX data.
    call loadsq1channelsfx
    //Number of frames to play sound before a change.
    a = 0x20
    //Low byte of SQ2 sound data start address(base=$B200).
    y = 0x35
    //($B5A5)Initiate multi channel SFX.
    goto multisfxinit

def incorrectpasswordsfxcontinue:

def title_page_B6A1:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto _00D8 when ~zero
    //($B5CD)End SFX.
    goto endmultisfx

//The following table is used by the below routine to load nes.apu.square1.low data in the
//MissilePickupSFXContinue routine.

def missilepickupsfxtbl:

    byte: 0xbd, 0x8d, 0x7e, 0x5e, 0x46, 0x3e, 0x0

def missilepickupsfxcontinue:

def title_page_B6B0:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto musicbranch03 when ~zero
    y = [sq1sfxdata]
    //Load SFX data from table above.
    a = [missilepickupsfxtbl:y]
    goto _00D9 when ~zero
    //($B6F2)SFX completed.
    goto endsq1sfx
def _00D9:
    [nes.apu.square1.low] = a
    //#$28.
    a = [0xb244]
    //load nes.apu.square1.high with #$28.
    [nes.apu.square1.high] = a
    //Increment index to data table above every 5 frames.
    [sq1sfxdata]++

def musicbranch03:

    //Exit from multiple routines.
    return

def missilepickupsfxstart:

def title_page_B6CD:
    //Number of frames to play sound before a change.
    a = 0x5
    //Lower byte of sound data start address(base=$B200).
    y = 0x41
    //Branch always.
    goto _00DC when ~zero

def energypickupsfxcontinue:

def title_page_B6D3:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto musicbranch03 when ~zero
    [sq1sfxdata]++
    //Every six frames, reload SFX info.  Does it-->
    a = [sq1sfxdata]
    //three times for a total of 18 frames.
    compare a to 0x3
    goto _00DA when zero
    y = 0x3d
    //($B368)Set SQ1 SFX data.
    goto loadsq1channelsfx

def energypickupsfxstart:

def title_page_B6E7:
    //Number of frames to play sound before a change.
    a = 0x6
    //Lower byte of sound data start address(base=$B200).
    y = 0x3d
    //Branch always.
    goto _00DC when ~zero

//The following continue routine is used by the metal, out of hole,
//enemy hit and the Samus jump SFXs.

def sq1sfxcontinue:

def title_page_B6ED:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto musicbranch03 when ~zero

def endsq1sfx:

def _00DA:
    a = 0x10
    //Disable envelope generator(sound off).
    [nes.apu.square1.ctrl] = a
    a = 0x0
    //Allows music to use SQ1 channel.
    [sq1inuse] = a
    //($B4A2)Clear all SFX flags.
    call clearcurrentsfxflags
    //Allows music routines to load SQ1 and SQ2 music.
    [writemultichanneldata]++
    return

def samusjumpsfxstart:

def title_page_B703:
    //If escape music is playing, exit without playing-->
    a = [currentmusic]
    //Samus jump SFX.
    compare a to 0x4
    goto musicbranch03 when zero
    //Number of frames to play sound before a change.
    a = 0xc
    //Lower byte of sound data start address(base=$B200).
    y = 0x51
    //Branch always.
    goto selectsfx1 when ~zero

def enemyhitsfxstart:

def title_page_B710:
    //Number of frames to play sound before a change.
    a = 0x8
    //Lower byte of sound data start address(base=$B200).
    y = 0x55
    //Branch always.
    goto selectsfx1 when ~zero

def bulletfiresfxstart:

def title_page_B716:
    a = [hasbeamsfx]
    //If Samus has ice beam, branch.
    a = a >> 1
    goto _00DF when carry
    //If MissilePickup, EnergyPickup, BirdOutOfHole-->
    a = [sq1contsfx]
    //or EnemyHit SFX already playing, branch to exit.
    a = a & 0xcc
    goto musicbranch03 when ~zero
    a = [hasbeamsfx]
    //If Samus has long beam, branch.
    a = a << 1
    goto _00DB when carry
    //Number of frames to play sound before a change.
    a = 0x3
    //Lower byte of sound data start address(base=$B200).
    y = 0x4d
    //Branch always (Plays ShortBeamSFX).
    goto selectsfx1 when ~zero

def haslongbeamsfxstart:

def _00DB:
    //Number of frames to play sound before a change.
    a = 0x7
    //Lower byte of sound data start address(base=$B200).
    y = 0x49
    //Branch always.
    goto selectsfx1 when ~zero

def metalsfxstart:

def title_page_B735:
    //Number of frames to play sound before a change.
    a = 0xb
    //Lower byte of sound data start address(base=$B200).
    y = 0x45

def selectsfx1:

def _00DC:
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def birdoutofholesfxstart:

def title_page_B73C:
    //If escape music is playing, use this SFX to make-->
    a = [currentmusic]
    //the bomb ticking sound, else play regular SFX.
    compare a to 0x4
    goto _00DD when zero
    //Number of frames to play sound before a change.
    a = 0x16
    //Lower byte of sound data start address(base=$B200).
    y = 0x59
    //Branch always.
    goto selectsfx1 when ~zero
def _00DD:
    //Number of frames to play sound before a change.
    a = 0x7
    //Lower byte of sound data start address(base=$B200).
    y = 0x39
    //Branch always.
    goto selectsfx1 when ~zero

def bulletfiresfxcontinue:

def title_page_B74F:
    a = [hasbeamsfx]
    //If Samus has ice beam, branch.
    a = a >> 1
    goto _00E0 when carry
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto _00DE when ~zero
    //($B6F2)If SFX finished, jump.
    goto endsq1sfx
def _00DE:
    return

def hasicebeamsfxstart:

def _00DF:
    //Number of frames to play sound before a change.
    a = 0x7
    //Lower byte of sound data start address(base=$B200).
    y = 0x61
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def hasicebeamsfxcontinue:

def _00E0:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch.
    goto _00E1 when ~zero
    //($B6F2)If SFX finished, jump.
    goto endsq1sfx
def _00E1:
    a = [sq1sfxdata]
    //Determine index for IceBeamSFXDataTbl below.
    a = a & 0x1
    y = a
    //Loads A with value from IceBeamSFXDataTbl below.
    a = [icebeamsfxdatatbl:y]
    goto _00E3 when ~zero

def icebeamsfxdatatbl:

    //Ice beam SFX period low data.
    byte: 0x93
    byte: 0x81

def wavebeamsfxstart:

def title_page_B77A:
    //Number of frames to play sound before a change.
    a = 0x8
    //Lower byte of sound data start address(base=$B200).
    y = 0x5d
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def wavebeamsfxcontinue:

def title_page_B781:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch.
    goto _00E2 when ~zero
    y = [sq1sq2sfxdata]
    //Load wave beam SFXDisable/enable envelope length-->
    [sq1sq2sfxdata]++
    //data from WaveBeamSFXDisableLengthTbl.
    a = [wavebeamsfxdislngthtbl:y]
    [nes.apu.square1.ctrl] = a
    //If at end of WaveBeamSFXDisableLengthTbl, end SFX.
    goto musicbranch10 when ~zero
    //($B6F2)If SFX finished, jump.
    goto endsq1sfx
def _00E2:
    a = [sq1sfxdata]
    a = a & 0x1
    //Load wave beam SFX period low data from-->
    y = a
    //WaveBeamSFXPeriodLowTbl.
    a = [wavebeamsfxperiodlowtbl:y]

def loadsq1periodlow:

def _00E3:
    //Change the period low data for SQ1 channel.
    [nes.apu.square1.low] = a
    [sq1sfxdata]++

def musicbranch10:

    //Exit for multiple routines.
    return
 
def wavebeamsfxperiodlowtbl:

    //Wave beam SFX period low data.
    byte: 0x58
    byte: 0x6f

def wavebeamsfxdislngthtbl:

    byte: 0x93
    //Wave beam SFX Disable/enable envelope length data.
    byte: 0x91
    byte: 0x0

def dooropenclosesfxstart:

def title_page_B7AC:
    //#$30.
    a = [0xb287]
    //Set triangle period low data byte.
    [triangleperiodlow] = a
    //#$B2.
    a = [0xb288]
    //Set triangle period high data byte.
    a = a & 0x7
    //#$B7.
    [triangleperiodhigh] = a
    a = 0xf
    //Change triangle channel period low every frame by #$0F.
    [trianglechangelow] = a
    a = 0x0
    //No change in triangle channel period high.
    [trianglechangehigh] = a
    //Number of frames to play sound before a change.
    a = 0x1f
    //Lower byte of sound data start address(base=$B200).
    y = 0x85
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def dooropenclosesfxcontinue:

def title_page_B7CB:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto _00E4 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx
def _00E4:
    //($B98C)Decrease periods.
    call decreasetriangleperiods
    //($B869)Save new periods.
    goto writetriangleperiods

def beepsfxstart:

def title_page_B7D9:
    //If BombLaunchSFX is already playing, branch-->
    a = [trianglecontsfx]
    //without playing BeepSFX.
    a = a & 0x80
    goto musicbranch10 when ~zero
    //Number of frames to play sound before a change.
    a = 0x3
    //Lower byte of sound data start address(base=$B200).
    y = 0x79
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def beepsfxcontinue:

def title_page_B7E7:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto musicbranch10 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx

def bigenemyhitsfxstart:

def title_page_B7EF:
    //Increase triangle low period by #$12 every frame.
    a = 0x12
    [trianglechangelow] = a
    a = 0x0
    //Does not change triangle period high.
    [trianglechangehigh] = a
    //#$42.
    a = [0xb27f]
    //Save new triangle period low data.
    [triangleperiodlow] = a
    //#$18.
    a = [0xb280]
    //#$1F.
    a = a & 0x7
    //Save new triangle period high data.
    [triangleperiodhigh] = a
    //Number of frames to play sound before a change.
    a = 0xa
    //Lower byte of sound data start address(base=$B200).
    y = 0x7d
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def bigenemyhitsfxcontinue:

def title_page_B80E:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch
    goto _00E5 when ~zero
    //($B896)End SFX
    goto endtrianglesfx
def _00E5:
    //($B978)Increase periods.
    call increasetriangleperiods
    a = [randomnumber1]
    a = a & 0x3c
    [trianglesfxdata] = a
    //Randomly set or clear bits 2, 3, 4 and 5 in-->
    a = [triangleperiodlow]
    //triangle channel period low.
    a = a & 0xc3
    a = a | [trianglesfxdata]
    [nes.apu.triangle.low] = a
    a = [triangleperiodhigh]
    //Set 4th bit in triangle channel period high.
    a = a | 0x40
    [nes.apu.triangle.high] = a
    return

def samustoballsfxstart:

def title_page_B834:
    //Number of frames to play sound before a change.
    a = 0x8
    //Lower byte of sound data start address(base=$B200).
    y = 0x6d
    //($B452)Setup registers for SFX.
    call selectsfxroutine
    a = 0x5
    //Stores percent difference. In this case 5 = 1/5 = 20%.
    [percentdifference] = a
    //#$DD.
    a = [0xb26f]
    //Save new triangle period low data.
    [triangleperiodlow] = a
    //#$3B.
    a = [0xb270]
    //#$02.
    a = a & 0x7
    //Save new triangle period high data.
    [triangleperiodhigh] = a
    return

def samustoballsfxcontinue:

def title_page_B84F:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch.
    goto _00E6 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx
def _00E6:
    //($B9A0)reduces triangle period low by 20% each frame.
    call dividetriangleperiods
    a = [trianglelowpercentage]
    //Store new values to change triangle periods.
    [trianglechangelow] = a
    a = [trianglehighpercentage]
    [trianglechangehigh] = a
    //($B98C)Decrease periods.
    call decreasetriangleperiods

def writetriangleperiods:

    //Write TrianglePeriodLow to triangle channel.
    a = [triangleperiodlow]
    [nes.apu.triangle.low] = a
    a = [triangleperiodhigh]
    //Write TrianglePeriodHigh to triangle channel.
    a = a | 0x8
    [nes.apu.triangle.high] = a
    return

def bomblaunchsfxstart:

def title_page_B878:
    //Number of frames to play sound before a change.
    a = 0x4
    //Lower byte of sound data start address(base=$B200).
    y = 0x65
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def bomblaunchsfxcontinue:

def title_page_B87F:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    //If more frames to process, branch to exit.
    goto musicbranch04 when ~zero
    [trianglesfxdata]++
    //After four frames, load second part of SFX.
    a = [trianglesfxdata]
    compare a to 0x2
    goto _00E7 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx
def _00E7:
    //Lower byte of sound data start address(base=$B200).
    y = 0x69
    //($B36C)Prepare to load triangle channel with data.
    goto loadtrianglechannelsfx

def endtrianglesfx:

    a = 0x0
    //clear TriangleCntr0(sound off).
    [nes.apu.triangle.ctrl] = a
    //Allows music to use triangle channel.
    [triangleinuse] = a
    a = 0x18
    //Set length index to #$03.
    [nes.apu.triangle.high] = a
    //($B4A2)Clear all SFX flags.
    call clearcurrentsfxflags

def musicbranch04:

    //Exit from for multiple routines.
    return

def metroidhitsfxstart:

def title_page_B8A7:
    //Number of frames to play sound before a change.
    a = 0x3
    //Lower byte of sound data start address(base=$B200).
    y = 0x71
    //($B452)Setup registers for SFX.
    call selectsfxroutine
    //($B8C3)MetroidHit SFX has several different sounds.
    goto rndtriangleperiods

def metroihitsfxcontinue:

def title_page_B8B1:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto _00E8 when zero
    [trianglesfxdata]++
    //Randomize triangle periods nine times throughout-->
    a = [trianglesfxdata]
    //the course of the SFX.
    compare a to 0x9
    //If SFX not done, branch.
    goto musicbranch04 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx

def rndtriangleperiods:

def _00E8:
    //Randomly set or reset bits 7, 4, 2 and 1 of-->
    a = [randomnumber1]
    //triangle channel period low.
    a = a | 0x6c
    [nes.apu.triangle.low] = a
    a = a & 0x1
    //Randomly set or reset last bit of triangle-->
    a = a | 0xf8
    //channel period high.
    [nes.apu.triangle.high] = a
    return

def samusdiesfxstart:

def title_page_B8D2:
    //($B404)Clear all sound addresses.
    call initializesoundaddresses
    //Number of frames to play sound before a change.
    a = 0xe
    //Lower byte of sound data start address(base=$B200).
    y = 0x75
    //($B452)Setup registers for SFX.
    call selectsfxroutine
    //Decrease triangle SFX periods by 4.8% every frame.
    a = 0x15
    [percentdifference] = a
    //#$40.
    a = [0xb277]
    [triangleperiodlow] = a
    //Initial values of triangle periods.
    a = 0x0
    [triangleperiodhigh] = a
def _00E9:
    return

def samusdiesfxcontinue:

def title_page_B8ED:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto _00EA when ~zero
    //Store change in triangle period low.
    a = 0x20
    [trianglechangelow] = a
    a = 0x0
    //No change in triangle period high.
    [trianglechangehigh] = a
    //($B98C)Decrease periods.
    call decreasetriangleperiods
    [trianglesfxdata]++
    a = [trianglesfxdata]
    compare a to 0x6
    //If more frames to process, branch to exit.
    goto _00E9 when ~zero
    //($B896)End SFX.
    goto endtrianglesfx
def _00EA:
    //($B9A0)reduces triangle period low.
    call dividetriangleperiods
    a = [trianglelowpercentage]
    //Update triangle periods.
    [trianglechangelow] = a
    a = [trianglehighpercentage]
    [trianglechangehigh] = a
    //($B978)Increase periods.
    call increasetriangleperiods
    //($B869)Save new periods.
    goto writetriangleperiods

def statueraisesfxstart:

def title_page_B921:
    //#$11.
    a = [0xb283]
    //Save period low data.
    [triangleperiodlow] = a
    //#$09.
    a = [0xb284]
    a = a & 0x7
    //Store last three bits in $B284.
    [triangleperiodhigh] = a
    a = 0x0
    //No change in Triangle period high.
    [trianglechangehigh] = a
    a = 0xb
    [trianglechangelow] = a
    //Number of frames to play sound before a change.
    a = 0x6
    //Lower byte of sound data start address(base=$B200).
    y = 0x81
    //($B452)Setup registers for SFX.
    goto selectsfxroutine

def statueraisesfxcontinue:

def title_page_B940:
    //($B4A9)Get next databyte to process in SFX.
    call incrementsfxframe
    goto _00EC when ~zero
    //Increment TriangleSFXData every 6 frames.
    [trianglesfxdata]++
    a = [trianglesfxdata]
    //When TriangleSFXData = #$09, end SFX.
    compare a to 0x9
    goto _00EB when ~zero
    //($B896)End SFX.
    goto endtrianglesfx
def _00EB:
    a = [trianglechangelow]
    //Save triangle periods.
    push a
    a = [trianglechangehigh]
    push a
    a = 0x25
    [trianglechangelow] = a
    //No change in triangle period high.
    a = 0x0
    [trianglechangehigh] = a
    //($B978)Increase periods.
    call increasetriangleperiods
    a = pop
    //Restore triangle periods.
    [trianglechangehigh] = a
    a = pop
    [trianglechangelow] = a
    //($B869)Save new periods.
    goto writetriangleperiods
def _00EC:
    //($B98C)Decrease periods.
    call decreasetriangleperiods
    //($B869)Save new periods.
    goto writetriangleperiods

def increasetriangleperiods:

    carry = 0
    a = [triangleperiodlow]
    //Calculate new TrianglePeriodLow.
    a = a +# [trianglechangelow]
    [triangleperiodlow] = a
    a = [triangleperiodhigh]
    //Calculate new TrianglePeriodHigh.
    a = a +# [trianglechangehigh]
    [triangleperiodhigh] = a
    return

def decreasetriangleperiods:

    carry = 1
    a = [triangleperiodlow]
    //Calculate new TrianglePeriodLow.
    a = a -# [trianglechangelow]
    [triangleperiodlow] = a
    a = [triangleperiodhigh]
    //Calculate new TrianglePeriodHigh.
    a = a -# [trianglechangehigh]
    [triangleperiodhigh] = a
    return

def dividetriangleperiods:

    a = [triangleperiodlow]
    //Store TrianglePeriodLow and TrianglePeriodHigh.
    push a
    a = [triangleperiodhigh]
    push a
    a = 0x0
    [dividedata] = a
    x = 0x10
    [triangleperiodlow] = [triangleperiodlow] <<< 1
    [triangleperiodhigh] = [triangleperiodhigh] <<< 1
def _00ED:
    //The following routine takes the triangle period-->
    [dividedata] = [dividedata] <<< 1
    //high and triangle period low values and reduces-->
    a = [dividedata]
    //them by a certain percent.  The percent is-->
    compare a to [percentdifference]
    //determined by the value stored in-->
    goto _00EE when ~carry
    //PercentDifference.  If PercentDifference=#$05,-->
    a = a -# [percentdifference]
    //then the values will be reduced by 20%(1/5).-->
    [dividedata] = a
def _00EE:
    //If PercentDifference=#$0A,Then the value will-->
    [triangleperiodlow] = [triangleperiodlow] <<< 1
    //be reduced by 10%(1/10), etc. This function is-->
    [triangleperiodhigh] = [triangleperiodhigh] <<< 1
    //basically a software emulation of a sweep function.
    x--
    goto _00ED when ~zero
    a = [triangleperiodlow]
    [trianglelowpercentage] = a
    a = [triangleperiodhigh]
    [trianglehighpercentage] = a
    a = pop
    //Restore TrianglePerodLow and TrianglePeriodHigh.
    [triangleperiodhigh] = a
    a = pop
    [triangleperiodlow] = a
    return

//--------------------------------------[ End SFX routines ]-------------------------------------
 
def setvolumeanddisablesweep:

    a = 0x7f
    //Disable sweep generator on SQ1 and SQ2.
    [musicsq1sweep] = a
    [musicsq2sweep] = a
    //Store duty cycle and volume data for SQ1 and SQ2.
    [sq1dutyenvelope] = x
    [sq2dutyenvelope] = y
    return

def resetvolumeindex:

    //If at the beginning of a new SQ1 note, set-->
    a = [sq1musicframecount]
    //SQ1VolumeIndex = #$01.
    compare a to 0x1
    goto _00EF when ~zero
    [sq1volumeindex] = a
def _00EF:
    a = [sq2musicframecount]
    //If at the beginning of a new SQ2 note, set-->
    compare a to 0x1
    //SQ2VolumeIndex = #$01.
    goto _00F0 when ~zero
    [sq2volumeindex] = a
def _00F0:
    return

def loadsq1sq2periods:

    //If a Multi channel data does not need to be-->
    a = [writemultichanneldata]
    //loaded, branch to exit.
    goto _00F1 when zero
    a = 0x0
    //Clear multi channel data write flag.
    [writemultichanneldata] = a
    a = [musicsq1sweep]
    [nes.apu.square1.sweep] = a
    a = [musicsq1periodlow]
    //Loads SQ1 channel addresses $4001, $4002, $4003.
    [nes.apu.square1.low] = a
    a = [musicsq1periodhigh]
    [nes.apu.square1.high] = a
    a = [musicsq2sweep]
    [nes.apu.square2.sweep] = a
    a = [musicsq2periodlow]
    //Loads SQ2 channel addresses $4005, $4006, $4007.
    [nes.apu.square2.low] = a
    a = [musicsq2periodhigh]
    [nes.apu.square2.high] = a
def _00F1:
    return

def loadsq1sq2channels:

    //Load SQ1 channel data.
    x = 0x0
    //($BA41)Write Cntrl0 data.
    call writesqcntrl0
    //Load SQ2 channel data.
    x++
    //($BA41)Write Cntrl0 data.
    call writesqcntrl0
    return

def writesqcntrl0:

    //Load SQ channel volume data. If zero, branch to exit.
    a = [sq1volumecntrl:x]
    goto _00F6 when zero
    [volumecntrladdress] = a
    //($BA08)Load SQ1 and SQ2 control information.
    call loadsq1sq2periods
    a = [sq1volumedata:x]
    //If sound channel is not currently-->
    compare a to 0x10
    //playing sound, branch.
    goto _00F8 when zero
    y = 0x0
def _00F2:
    //Desired entry in VolumeCntrlAdressTbl.
    [volumecntrladdress]--
    goto _00F3 when zero
    //*2(2 byte address to find voulume control data).
    y++
    y++
    //Keep decrementing until desired address is found.
    goto _00F2 when ~zero
def _00F3:
    //Base is $BCB0.
    a = [volumecntrladdresstbl:y]
    //Volume data address low byte.
    [0xec] = a
    //Base is $BCB1.
    a = [volumecntrladdresstbl+1:y]
    //Volume data address high byte.
    [0xed] = a
    //Index to desired volume data.
    y = [sq1volumeindex:x]
    //Load desired volume for current channel into-->
    a = [[0xec]:y]
    //Cntrl0Data.
    [cntrl0data] = a
    //If last entry in volume table is #$FF, restore-->
    compare a to 0xff
    //volume to its original level after done reading-->
    goto musicbranch05 when zero
    //Volume data.  If #$F0 is last entry, turn sound-->
    compare a to 0xf0
    //off on current channel until next note.
    goto musicbranch06 when zero
    //Remove duty cycle data For current channel and-->
    a = [sq1dutyenvelope:x]
    //add this frame of volume data and store results-->
    a = a & 0xf0
    //in Cntrl0Data.
    a = a | [cntrl0data]
    y = a
def _00F4:
    //Increment Index to volume data.
    [sq1volumeindex:x]++
def _00F5:
    //If SQ1 or SQ2(depends on loop iteration) in use,-->
    a = [sq1inuse:x]
    //branch to exit, else write SQ(1 or 2)Cntrl0.
    goto _00F6 when ~zero
    a = x
    //If currently on SQ1, branch to write SQ1 data.
    goto _00F7 when zero

def writesq2cntrl0:
                //
    //Write SQ2Cntrl0 data.
    [nes.apu.square2.ctrl] = y
def _00F6:
    return

def writesq1cntrl0:
                //
def _00F7:
    //Write SQ1Cntrl0 data.
    [nes.apu.square1.ctrl] = y
    return

def musicbranch05:

    //Restore original volume of sound channel.
    y = [sq1dutyenvelope:x]
    //Branch always.
    goto _00F5 when ~zero

def musicbranch06:

    //Disable envelope generator and set volume to 0.
    y = 0x10
    //Branch always.
    goto _00F5 when ~zero
def _00F8:
    //Disable envelope generator and set volume to 0.
    y = 0x10
    //Branch always.
    goto _00F4 when ~zero

def gotocheckrepeatmusic:

def _00F9:
    //($B3F0)Resets music flags if music repeats.
    call checkrepeatmusic
    return

def gotoloadsq1sq2channels:

def _00FA:
    //($BA37)Load SQ1 and SQ2 channel data.
    call loadsq1sq2channels
    return

def loadcurrentmusicframedata:

    //($B9F3)Reset index if at the beginning of a new note.
    call resetvolumeindex
    a = 0x0
    //X = #$00.
    x = a
    //(#$00, #$04, #$08 or #$0C).
    [thissoundchannel] = a
    goto _00FC when zero
def _00FB:
    a = x
    a = a >> 1
    //Increment to next sound channel(1,2 or 3).
    x = a
                    //
def incrementtonextchannel:
            //
    x++
    a = x
    //If done with four sound channels, branch to load-->
    compare a to 0x4
    //sound channel SQ1 SQ2 data.
    goto _00FA when zero
    //Add 4 to the least significant byte of the current-->
    a = [thissoundchannel]
    //sound channel start address.  This moves to next-->
    carry = 0
    //sound channel address ranges to process.
    a = a +# 0x4
    [thissoundchannel] = a
def _00FC:
    a = x
    //*2(two bytes for sound channel info base address).
    a = a << 1
    x = a
    a = [sq1lowbasebyte:x]
    //Load sound channel info base address into $E6-->
    [0xe6] = a
    //and $E7. ($E6=low byte, $E7=high byte).
    a = [sq1highbasebyte:x]
    [0xe7] = a
    //If no data for this sound channel, branch-->
    a = [sq1highbasebyte:x]
    //to find data for next sound channel.
    goto _00FB when zero
    a = x
    ///2. Determine current sound channel (0,1,2 or3).
    a = a >> 1
    x = a
    //Decrement the current sound channel frame count-->
    [sq1musicframecount:x]--
    //If not zero, branch to check next channel, else-->
    goto incrementtonextchannel when ~zero
                    //load the next set of sound channel data.
def loadnextchannelindexdata:

    //Load current channel index to music data index.
    y = [sq1musicindexindex:x]
    //Increment current channel index to music data index.
    [sq1musicindexindex:x]++
    a = [[0xe6]:y]
    //Branch if music has reached the end.
    goto _00F9 when zero
    //Transfer music data index to Y (base=$BE77) .
    y = a
    compare a to 0xff
    //At end of loop? If yes, branch.
    goto _00FD when zero
    a = a & 0xc0
    //At beginnig of new loop? if yes, branch.
    compare a to 0xc0
    goto _00FE when zero
    //($BB1C)Load music data into channel.
    goto loadmusicchannel

def repeatmusicloop:

def _00FD:
    //If loop counter has reached zero, branch to exit.
    a = [sq1repeatcounter:x]
    goto _00FF when zero
    //Decrement loop counter.
    [sq1repeatcounter:x]--
    //Load loop index for proper channel and store it in-->
    a = [sq1loopindex:x]
    //music index index address.
    [sq1musicindexindex:x] = a
    //Branch unless music has reached the end.
    goto _00FF when ~zero

def startnewmusicloop:

def _00FE:
    a = y
    //Remove last six bits of loop controller and save-->
    a = a & 0x3f
    //in repeat counter addresses.  # of times to loop.
    [sq1repeatcounter:x] = a
    //Decrement loop counter.
    [sq1repeatcounter:x]--
    //Store location of loop start in loop index address.
    a = [sq1musicindexindex:x]
    [sq1loopindex:x] = a
def _00FF:
    //($BADC)Load next channel index data.
    goto loadnextchannelindexdata

def _0100:
    //($BBDE)Load data for noise channel music.
    goto loadnoisechannelmusic

def _0101:
    //($BBB7)Load Cntrl0 byte of triangle channel.
    goto loadtrianglecntrl0

def loadmusicchannel:

    a = y
    a = a & 0xb0
    //Is data byte music note length data?  If not, branch.
    compare a to 0xb0
    goto _0102 when ~zero
    a = y
    //Separate note length data.
    a = a & 0xf
    carry = 0
    //Find proper note lengths table for current music.
    a = a +# [notelengthtbloffset]
    y = a
    //(Base is $BEF7)Load note length and store in-->
    a = [notelengths0tbl:y]
    //frame count init address.
    [sq1framecountinit:x] = a
    //Y now contains note length.
    y = a
    a = x
    //If loading Triangle channel data, branch.
    compare a to 0x2
    goto _0101 when zero

def loadsounddataindexindex:

    //Load current index to sound data index.
    y = [sq1musicindexindex:x]
    //Increment music index index address.
    [sq1musicindexindex:x]++
    //Load index to sound channel music data.
    a = [[0xe6]:y]
    y = a
def _0102:
    a = x
    //If loading Noise channel data, branch.
    compare a to 0x3
    goto _0100 when zero
    //Push music channel number on stack(0, 1 or 2).
    push a
    x = [thissoundchannel]
    //(Base=$BE78)Load A with music channel period low data.
    a = [musicnotestbl+1:y]
    //If data is #$00, skip period high and low loading.
    goto _0103 when zero
    //Store period low data in proper period low address.
    [musicsq1periodlow:x] = a
    //(Base=$BE77)Load A with music channel period high data.
    a = [musicnotestbl:y]
    //Ensure minimum index length of 1.
    a = a | 0x8
    //Store period high data in proper period high address.
    [musicsq1periodhigh:x] = a
def _0103:
    y = a
    //Pull stack and restore channel number to X.
    a = pop
    x = a
    a = y
    //If period information was present, branch.
    goto _0104 when ~zero
                
def noperiodinformation:

    //Turn off channel volume since no period data present.
    a = 0x0
    [cntrl0data] = a
    a = x
    //If loading triangle channel data, branch.
    compare a to 0x2
    goto _0105 when zero
    //Turn off volume and disable env. generator(SQ1,SQ2).
    a = 0x10
    [cntrl0data] = a
    //Branch always.
    goto _0105 when ~zero

def periodinformationfound:

def _0104:
    //Store channel duty cycle and volume info in $EA.
    a = [sq1dutyenvelope:x]
    [cntrl0data] = a
def _0105:
    a = x
    [sq1inuse:x]--
    //If SQ1 or SQ2 are being used by SFX routines, branch.
    compare a to [sq1inuse:x]
    goto _0108 when zero
    //Restore not in use status of SQ1 or SQ2.
    [sq1inuse:x]++
    y = [thissoundchannel]
    a = x
    //If loading triangle channel data, branch.
    compare a to 0x2
    goto _0106 when zero
    //If $062E or $062F has volume data, skip writing-->
    a = [sq1volumecntrl:x]
    //Cntrl0Data to SQ1 or SQ2.
    goto _0107 when ~zero
def _0106:
    a = [cntrl0data]
    //Write Cntrl0Data.
    [nes.apu.square1.ctrl:y] = a
def _0107:
    a = [cntrl0data]
    //Store volume data index to volume data.
    [sq1volumedata:x] = a
    a = [musicsq1periodlow:y]
    [nes.apu.square1.low:y] = a
    //Write data to three sound channel addresses.
    a = [musicsq1periodhigh:y]
    [nes.apu.square1.high:y] = a
    a = [musicsq1sweep:x]
    [nes.apu.square1.sweep:y] = a

def loadnewmusicframecount:

    //Load new music frame count and store it in music-->
    a = [sq1framecountinit:x]
    //frame count address.
    [sq1musicframecount:x] = a
    //($BAB3)Move to next sound channel.
    goto incrementtonextchannel

def sq1sq2inuse:

def _0108:
    //Restore in use status of SQ1 or SQ1.
    [sq1inuse:x]++
    //($BBA8)Load new music frame count.
    goto loadnewmusicframecount

def loadtrianglecntrl0:

    a = [trianglecountercntrl]
    //If lower bits set, branch to play shorter note.
    a = a & 0xf
    goto _010A when ~zero
    a = [trianglecountercntrl]
    //If upper bits are set, branch to play longer note.
    a = a & 0xf0
    goto _0109 when ~zero
    a = y
    //($BBCD)Calculate length to play note.
    goto addtrianglelength
def _0109:
    //Disable length cntr(play until triangle data changes).
    a = 0xff
    //Branch always.
    goto _010A when ~zero

def addtrianglelength:

    carry = 0
    //Add #$FF(Effectively subtracts 1 from A).
    a = a +# 0xff
    //*2.
    a = a << 1
    //*2.
    a = a << 1
    compare a to 0x3c
    //If result is greater than #$3C, store #$3C(highest-->
    goto _010A when ~carry
    //triangle linear count allowed).
    a = 0x3c
def _010A:
    [trilinearcount] = a
def _010B:
    //($BB37)Load index to sound data index.
    goto loadsounddataindexindex

def loadnoisechannelmusic:

    a = [noisecontsfx]
    //If playing any Noise SFX, branch to exit.
    a = a & 0xfc
    goto _010C when ~zero
    a = [title_page_B200:y]
    //Load noise channel with drum beat SFX starting-->
    [nes.apu.noise.ctrl] = a
    //at address B201.  The possible values of Y are-->
    a = [title_page_B201:y]
    //#$01, #$04, #$07 or #$0A.
    [nes.apu.noise.random] = a
    a = [0xb202:y]
    [nes.apu.noise.length] = a
def _010C:
    //($BBA8)Load new music frame count.
    goto loadnewmusicframecount

//The following table is used by the InitializeMusic routine to find the index for loading
//addresses $062B thru $0637.  Base is $BD31.

def initmusicindextbl:

    //Ridley area music.
    byte: 0x41
    //Tourian music.
    byte: 0x8f
    //Item room music.
    byte: 0x34
    //Kraid area music.
    byte: 0x27
    //Norfair music.
    byte: 0x1a
    //Escape music.
    byte: 0xd
    //Mother brain music.
    byte: 0x0
    //Brinstar music.
    byte: 0x82
    //Fade in music.
    byte: 0x68
    //Power up music.
    byte: 0x75
    //End music.
    byte: 0x4e
    //Intro music.
    byte: 0x5b

//The tables below contain addresses for SFX and music handling routines.
//Multi channel Init SFX and music handling routine addresses:

def title_page_BC06:
    //Fade in music.
    word: title_page_BC80
    //Power up music.
    word: title_page_BC7A
    //End game music.
    word: title_page_BC86
    //Intro music.
    word: title_page_BC7A
    //No sound.
    word: title_page_B4EE
    //Samus hit init SFX.
    word: title_page_B673
    //Boss hit init SFX.
    word: title_page_B5EC
    //Incorrect password init SFX.
    word: title_page_B695

//Multi channel continue SFX handling routine addresses:

def title_page_BC16:
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE
    //No sound.
    word: title_page_B4EE
    //Samus hit continue SFX.
    word: title_page_B650
    //Boss hit continue SFX.
    word: title_page_B5F6
    //Incorrect password continue SFX.
    word: title_page_B6A1

//Music handling routine addresses:

def title_page_BC26:
    //Ridley area music.
    word: title_page_BC83
    //Tourian music.
    word: title_page_BC77
    //Item room music.
    word: title_page_BC77
    //Kraid area music.
    word: title_page_BC77
    //Norfair music.
    word: title_page_BC80
    //Escape music.
    word: title_page_BC7D
    //Mother brain music.
    word: title_page_BC77
    //Brinstar music.
    word: title_page_BC80

//-----------------------------------[ Entry point for music routines ]--------------------------------

def loadmusictempflags:

    //Load A with temp music flags, (9th SFX cycle).
    a = [currentmusicrepeat]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0xb6
    //Branch always.
    goto _010D when ~zero

def loadmusicinitflags:

    //Load A with Music flags, (10th SFX cycle).
    a = [musicinitflag]
    //Lower address byte in ChooseNextSFXRoutineTbl.
    x = 0xb1
def _010D:
    //($B4BD)Checks to see if SFX or music flags set.
    call checksfxflag
    //($BC53)Find bit containing music init flag.
    call findmusicinitindex
    //If no flag found, Jump to next SFX cycle,-->
    goto [0xe2]
                    //else jump to specific SFX handling subroutine.

def continuemusic:
                //11th and last SFX cycle.
    a = [currentmusic]
    //Branch to exit of no music playing.
    goto _0110 when zero
    //($BAA5)Load info for current frame of music data.
    goto loadcurrentmusicframedata

//MusicInitIndex values correspond to the following music:
//#$00=Ridley area music, #$01=Tourian music, #$02=Item room music, #$03=Kraid area music,
//#$04=Norfair music, #$05=Escape music, #$06=Mother brain music, #$07=Brinstar music,
//#$08=Fade in music, #$09=Power up music, #$0A=End game music, #$0B=Intro music.

def findmusicinitindex:

    //Load MusicInitIndex with #$FF.
    a = 0xff
    [musicinitindex] = a
    a = [currentsfxflags]
    //Branch to exit if no SFX flags set for Multi SFX.
    goto _010F when zero
def _010E:
    [musicinitindex]++
    //Shift left until bit flag is in carry bit.
    a = a << 1
    //Loop until SFX flag found.  Store bit-->
    goto _010E when ~carry
def _010F:
    //number of music in MusicInitIndex.
    return

//The following routine is used to add eight to the music index when looking for music flags
//in the MultiSFX address.  
def add8:

    a = [musicinitindex]
    carry = 0
    //Add #$08 to MusicInitIndex.
    a = a +# 0x8
    [musicinitindex] = a
    return

    a = [currentmusic]
    //This code does not appear to be used in this page.
    a = a | 0xf0
    [currentmusic] = a
def _0110:
    return

def music00start:

def title_page_BC77:
    //($BCAA)Initialize music 00.
    goto music00init

def music01start:

def title_page_BC7A:
    //($BCA4)Initialize music 01.
    goto music01init

def music02start:

def title_page_BC7D:
    //($BC9A)Initialize music 02.
    goto music02init

def msic03start:

def title_page_BC80:
    //($BC96)Initialize music 03.
    goto music03init

def music04start:

def title_page_BC83:
    //($BC89)Initialize music 04.
    goto music04init

def music05start:

def title_page_BC86:
    //($BC9E)Initialize music 05.
    goto music05init

def music04init:

    //Duty cycle and volume data for SQ1 and SQ2.
    a = 0xb3

def xymusicinit:

def _0111:
    //Duty cycle and volume data for SQ1.
    x = a
    //Duty cycle and volume data for SQ2.
    y = a

def _0112:
    //($B9E4)Set duty cycle and volume data for SQ1 and SQ2.
    call setvolumeanddisablesweep
    //($BF19)Setup music registers.
    call initializemusic
    //($BAA5)Load info for current frame of music data.
    goto loadcurrentmusicframedata

def music03init:

    //Duty cycle and volume data for SQ1 and SQ2.
    a = 0x34
    //Branch always
    goto _0111 when ~zero

def music02init:

    //Duty cycle and volume data for SQ1 and SQ2.
    a = 0xf4
    //Branch always
    goto _0111 when ~zero

def music05init:

    //Duty cycle and volume data for SQ1.
    x = 0xf5
    //Duty cycle and volume data for SQ2.
    y = 0xf6
    //Branch always
    goto _0112 when ~zero

def music01init:

    //Duty cycle and volume data for SQ1.
    x = 0xb6
    //Duty cycle and volume data for SQ2.
    y = 0xf6
    //Branch always
    goto _0112 when ~zero

def music00init:

    //Duty cycle and volume data for SQ1.
    x = 0x92
    //Duty cycle and volume data for SQ2.
    y = 0x96
    //Branch always
    goto _0112 when ~zero

//The following address table provides starting addresses of the volume data tables below:
def volumecntrladdresstbl:

    word: title_page_BCBA, 0xbcc5, 0xbccf, 0xbcda, 0xbd03

def volumedatatbl1:

def title_page_BCBA:
    byte: 0x1, 0x2, 0x2, 0x3, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0xff

def volumedatatbl2:

    byte: 0x2, 0x4, 0x5, 0x6, 0x7, 0x8, 0x7, 0x6, 0x5, 0xff

def volumedatatbl3:

    byte: 0x0, 0xd, 0x9, 0x7, 0x6, 0x5, 0x5, 0x5, 0x4, 0x4, 0xff

def volumedatatbl4:

    byte: 0x2, 0x6, 0x7, 0x7, 0x7, 0x6, 0x6, 0x6, 0x6, 0x5, 0x5, 0x5, 0x4, 0x4, 0x4, 0x3
    byte: 0x3, 0x3, 0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2
    byte: 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0xf0

def volumedatatbl5:

    byte: 0xa, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x7, 0x7, 0x6, 0x5, 0x4, 0x4
    byte: 0x3, 0x2, 0x2, 0x2, 0x5, 0x5, 0x5, 0x4, 0x3, 0x2, 0x2, 0x2, 0x1, 0x1, 0x4, 0x4
    byte: 0x3, 0x2, 0x1, 0x2, 0x2, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x1, 0x1, 0xf0

//The init music table loads addresses $062B thru $0637 with the initial data needed to play the
//selected music.  The data for each entry in the table have the following format:
//.byte $xx, $xx, $xx, $xx, $xx : .word $xxxx, $xxxx, $xxxx, $xxxx.
//The first five bytes have the following functions:
//Byte 0=index to proper note length table.  Will be either #$00, #$0B or #$17.
//Byte 1=Repeat music byte. #$00=no repeat, any other value and the music repeats.
//Byte 2=Controls length counter for triangle channel.
//Byte 3=Volume control byte for SQ1.
//Byte 4=Volume control byte for SQ2.
//Address 0=Base address of SQ1 music data.
//Address 1=Base address of SQ2 music data.
//Address 2=Base address of triangle music data.
//Address 3=Base address of noise music data.

def initmusictbl:


//Mother brain music(not used this memory page).
    byte: 0xb, 0xff, 0xf5, 0x0, 0x0
    word: 0x100, 0x300, 0x500, 0x0

//Escape music(not used this memory page).
    byte: 0xb, 0xff, 0x0, 0x2, 0x2
    word: 0x100, 0x300, 0x500, 0x700

//Norfair music(not used this memory page).
    byte: 0xb, 0xff, 0xf0, 0x4, 0x4
    word: 0x100, 0x300, 0x500, 0x700

//Kraid area music(not used this memory page).
    byte: 0x0, 0xff, 0xf0, 0x0, 0x0
    word: 0x100, 0x300, 0x500, 0x0

//Item room music.
    byte: 0xb, 0xff, 0x3, 0x0, 0x0
    word: title_page_BDDA, 0xbddc, 0xbdcd, 0x0

//Ridley area music(not used this memory page).
    byte: 0xb, 0xff, 0xf0, 0x1, 0x1
    word: 0x100, 0x300, 0x500, 0x0

//End game music
    byte: 0x17, 0x0, 0x0, 0x2, 0x1
    word: title_page_AC00, 0xadc5, 0xacf5, 0xae8e

//Intro music
    byte: 0x17, 0x0, 0xf0, 0x2, 0x5
    word: title_page_B0B9, 0xb000, 0xb076, 0xb115

//Fade in music
    byte: 0xb, 0x0, 0xf0, 0x2, 0x0
    word: title_page_BE3E, 0xbe1d, 0xbe36, 0x0

//Power up music
    byte: 0x0, 0x0, 0xf0, 0x1, 0x0
    word: title_page_BDF7, 0xbe0d, 0xbe08, 0x0

//Brinstar music(not used this memory page).
    byte: 0xb, 0xff, 0x0, 0x2, 0x3
    word: 0x100, 0x300, 0x500, 0x700

//Tourian music
    byte: 0xb, 0xff, 0x3, 0x0, 0x0
    word: title_page_BE59, 0xbe47, 0xbe62, 0x0

def itemroomtriangleindexdata:

    byte: 0xc8
    //3/32 seconds    +
    byte: 0xb0
    //E3        |
    byte: 0x38
    //F3        |
    byte: 0x3a
    //F#3        |
    byte: 0x3c
    //G3        |
    byte: 0x3e
    //Ab3        | Repeat 8 times
    byte: 0x40
    //G3        |
    byte: 0x3e
    //F#3        |
    byte: 0x3c
    //F3        |
    byte: 0x3a
    //1 3/16 seconds    |
    byte: 0xb6
    //no sound    +
    byte: 0x2
    byte: 0xff

def itemroomsq1indexdata:

def title_page_BDDA:
    //1/4 seconds
    byte: 0xb8
    //No sound
    byte: 0x2

def itemroomsq2indexdata:

    //3/4 seconds
    byte: 0xb3
    //No sound
    byte: 0x2
    //3/8 seconds
    byte: 0xb2
    //A#6
    byte: 0x74
    //No sound
    byte: 0x2
    //F5
    byte: 0x6a
    //No sound
    byte: 0x2
    //A6
    byte: 0x72
    //No sound
    byte: 0x2
    //C#5
    byte: 0x62
    //1 1/2 seconds
    byte: 0xb4
    //No sound
    byte: 0x2
    //3/8 seconds
    byte: 0xb2
    //C5
    byte: 0x60
    //No sound
    byte: 0x2
    //F#5
    byte: 0x6c
    //No sound
    byte: 0x2
    //B6
    byte: 0x76
    //3/4 seconds
    byte: 0xb3
    //No sound
    byte: 0x2
    //3/8 seconds
    byte: 0xb2
    //F6
    byte: 0x7e
    //No sound
    byte: 0x2
    //D6
    byte: 0x7c
    //3/4 seconds
    byte: 0xb3
    //No sound
    byte: 0x2
    //End item room music.
    byte: 0x0

def powerupsq1indexdata:

def title_page_BDF7:
    //1/2 seconds
    byte: 0xb3
    //C4
    byte: 0x48
    //A4
    byte: 0x42
    //1/4 seconds
    byte: 0xb2
    //G3
    byte: 0x3e
    //E3
    byte: 0x38
    //C3
    byte: 0x30
    //E3
    byte: 0x38
    //D4
    byte: 0x4c
    //A#4
    byte: 0x44
    //G3
    byte: 0x3e
    //D#3
    byte: 0x36
    byte: 0xc8
    //1/16 seconds    +
    byte: 0xb0
    //E3        | Repeat 8 times
    byte: 0x38
    //F#3        +
    byte: 0x3c
    byte: 0xff

def poweruptriangleindexdata:

    //1 second
    byte: 0xb4
    //A#3
    byte: 0x2c
    //A3
    byte: 0x2a
    //D#2
    byte: 0x1e
    //D2
    byte: 0x1c

def powerupsq2indexdata:

    //1/4 seconds
    byte: 0xb2
    //F2
    byte: 0x22
    //A#3
    byte: 0x2c
    //C3
    byte: 0x30
    //D3
    byte: 0x34
    //E3
    byte: 0x38
    //C3
    byte: 0x30
    //G2
    byte: 0x26
    //C3
    byte: 0x30
    //F3
    byte: 0x3a
    //D3
    byte: 0x34
    //A#3
    byte: 0x2c
    //G2
    byte: 0x26
    //1 second
    byte: 0xb4
    //A3
    byte: 0x2a
    //End power up music.
    byte: 0x0

def fadeinsq2indexdata:

    byte: 0xc4
    //3/32 seconds    +
    byte: 0xb0
    //G3        | Repeat 4 times
    byte: 0x3e
    //C3        +
    byte: 0x30
    byte: 0xff
    byte: 0xc4
    //A4        + Repeat 4 times
    byte: 0x42
    //C3        +
    byte: 0x30
    byte: 0xff
    byte: 0xc4
    //F3        + Repeat 4 times
    byte: 0x3a
    //A#3        +
    byte: 0x2c
    byte: 0xff
    byte: 0xc4
    //E3        + Repeat 4 times
    byte: 0x38
    //G2        +
    byte: 0x26
    byte: 0xff
    byte: 0xc4
    //D3        + Repeat 4 times
    byte: 0x34
    //E2        +
    byte: 0x20
    byte: 0xff
    byte: 0xe0
    //D3        + Repeat 32 times
    byte: 0x34
    //F#2        +
    byte: 0x24
    byte: 0xff

def fadeintriangleindexdata:

    //3/4 seconds
    byte: 0xb3
    //D#3
    byte: 0x36
    //D3
    byte: 0x34
    //C3
    byte: 0x30
    //A3
    byte: 0x2a
    //1 1/2 seconds
    byte: 0xb4
    //D2
    byte: 0x1c
    //D2
    byte: 0x1c

def fadeinsq1indexdata:

def title_page_BE3E:
    //3/4 seconds
    byte: 0xb3
    //D3
    byte: 0x34
    //F3
    byte: 0x3a
    //D3
    byte: 0x34
    //C3
    byte: 0x30
    //1 1/2 seconds
    byte: 0xb4
    //A3
    byte: 0x2a
    //A3
    byte: 0x2a
    //End fade in music.
    byte: 0x0

def touriansq2indexdata:

    //1 1/2 seconds
    byte: 0xb4
    //A2
    byte: 0x12
    //3/4 seconds
    byte: 0xb3
    //Ab1
    byte: 0x10
    //C2
    byte: 0x18
    //B2
    byte: 0x16
    //F1
    byte: 0xa
    //1 1/2 seconds
    byte: 0xb4
    //A#2
    byte: 0x14
    //A2
    byte: 0x12
    //3/4 seconds
    byte: 0xb3
    //Ab1
    byte: 0x10
    //D1
    byte: 0x6
    //G1
    byte: 0xe
    //C#1
    byte: 0x4
    //1 1/2 seconds
    byte: 0xb4
    //F#1
    byte: 0xc
    //End Tourian music.
    byte: 0x0

def touriansq1indexdata:

def title_page_BE59:
    byte: 0xe0
    //3/32 seconds    +
    byte: 0xb0
    //F#4        |
    byte: 0x54
    //D#4        |
    byte: 0x4e
    //C4        | Repeat 32 times
    byte: 0x48
    //A4        |
    byte: 0x42
    //C4        |
    byte: 0x48
    //D#4        +
    byte: 0x4e
    byte: 0xff

def touriantriangleindexdata:

    byte: 0xe0
    //3/4 seconds    +
    byte: 0xb3
    //No sound    |
    byte: 0x2
    //3/32 seconds    |
    byte: 0xb0
    //F#3        |
    byte: 0x3c
    //Ab3        |
    byte: 0x40
    //A#4        |
    byte: 0x44
    //C#4        |
    byte: 0x4a
    //D#4        |
    byte: 0x4e
    //F#4        |
    byte: 0x54
    //Ab4        | Repeat 32 times
    byte: 0x58
    //A#5        |
    byte: 0x5c
    //C#5        |
    byte: 0x62
    //D#5        |
    byte: 0x66
    //F#5        |
    byte: 0x6c
    //Ab5        |
    byte: 0x70
    //A#6        |
    byte: 0x74
    //C#6        |
    byte: 0x7a
    //3/4 seconds    |
    byte: 0xb3
    //No sound    +
    byte: 0x2
    byte: 0xff

//The following table contains the musical notes used by the music player.  The first byte is
//the period high information(3 bits) and the second byte is the period low information(8 bits).
//The formula for figuring out the frequency is as follows: 1790000/16/(hhhllllllll + 1)

def musicnotestbl:

    //55.0Hz (A1)    Index #$00 (Not used)
    byte: 0x7
    byte: 0xf0

    //No sound    Index #$02
    byte: 0x0
    byte: 0x0

    //69.3Hz (C#2)    Index #$04
    byte: 0x6
    byte: 0x4e

    //73.4Hz (D2)    Index #$06
    byte: 0x5
    byte: 0xf3

    //82.4Hz (E2)    Index #$08
    byte: 0x5
    byte: 0x4d

    //87.3Hz (F2)    Index #$0A
    byte: 0x5
    byte: 0x1

    //92.5Hz (F#2)    Index #$0C
    byte: 0x4
    byte: 0xb9

    //98.0Hz (G2)    Index #$0E
    byte: 0x4
    byte: 0x75

    //103.8Hz (Ab2)    Index #$10
    byte: 0x4
    byte: 0x35

    //110.0Hz (A2)    Index #$12
    byte: 0x3
    byte: 0xf8

    //116.5Hz (A#2)    Index #$14
    byte: 0x3
    byte: 0xbf

    //123.5Hz (B2)    Index #$16
    byte: 0x3
    byte: 0x89

    //130.7Hz (C3)    Index #$18
    byte: 0x3
    byte: 0x57

    //138.5Hz (C#3)    Index #$1A
    byte: 0x3
    byte: 0x27

    //146.8Hz (D3)    Index #$1C
    byte: 0x2
    byte: 0xf9

    //155.4Hz (D#3)    Index #$1E
    byte: 0x2
    byte: 0xcf

    //164.8Hz (E3)    Index #$20
    byte: 0x2
    byte: 0xa6

    //174.5Hz (F3)    Index #$22
    byte: 0x2
    byte: 0x80

    //184.9Hz (F#3)    Index #$24
    byte: 0x2
    byte: 0x5c

    //196.0Hz (G3)    Index #$26
    byte: 0x2
    byte: 0x3a
    
    //207.6Hz (Ab3)    Index #$28
    byte: 0x2
    byte: 0x1a

    //219.8Hz (A3)    Index #$2A
    byte: 0x1
    byte: 0xfc

    //233.1Hz (A#3)    Index #$2C
    byte: 0x1
    byte: 0xdf

    //247.0Hz (B3)    Index #$2E
    byte: 0x1
    byte: 0xc4

    //261.4Hz (C4)    Index #$30
    byte: 0x1
    byte: 0xab

    //276.9Hz (C#4)    Index #$32
    byte: 0x1
    byte: 0x93

    //293.6Hz (D4)    Index #$34
    byte: 0x1
    byte: 0x7c

    //310.8Hz (D#4)    Index #$36
    byte: 0x1
    byte: 0x67

    //330.0Hz (E4)    Index #$38
    byte: 0x1
    byte: 0x52

    //349.6Hz (F4)    Index #$3A
    byte: 0x1
    byte: 0x3f

    //370.4Hz (F#4)    Index #$3C
    byte: 0x1
    byte: 0x2d

    //392.5Hz (G4)    Index #$3E
    byte: 0x1
    byte: 0x1c

    //415.9Hz (Ab4)    Index #$40
    byte: 0x1
    byte: 0xc

    //440.4Hz (A4)    Index #$42
    byte: 0x0
    byte: 0xfd

    //468.1Hz (A#4)    Index #$44
    byte: 0x0
    byte: 0xee

    //495.0Hz (B4)    Index #$46
    byte: 0x0
    byte: 0xe1

    //525.2Hz (C5)    Index #$48
    byte: 0x0
    byte: 0xd4

    //556.6Hz (C#5)    Index #$4A
    byte: 0x0
    byte: 0xc8

    //588.8Hz (D5)    Index #$4C
    byte: 0x0
    byte: 0xbd

    //625.0Hz (D#5)    Index #$4E
    byte: 0x0
    byte: 0xb2

    //662.0Hz (E5)    Index #$50
    byte: 0x0
    byte: 0xa8

    //699.2Hz (F5)    Index #$52
    byte: 0x0
    byte: 0x9f

    //740.9Hz (F#5)    Index #$54
    byte: 0x0
    byte: 0x96

    //787.9Hz (G5)    Index #$56
    byte: 0x0
    byte: 0x8d

    //834.9Hz (Ab5)    Index #$58
    byte: 0x0
    byte: 0x85

    //880.9HZ (A5)    Index #$5A
    byte: 0x0
    byte: 0x7e

    //940.1Hz (A#5)    Index #$5C
    byte: 0x0
    byte: 0x76

    //990.0Hz (B5)    Index #$5E
    byte: 0x0
    byte: 0x70

    //1055Hz (C6)    Index #$60
    byte: 0x0
    byte: 0x69

    //1118Hz (C#6)    Index #$62
    byte: 0x0
    byte: 0x63

    //1178Hz (D6)    Index #$64
    byte: 0x0
    byte: 0x5e

    //1257Hz (D#6)    Index #$66
    byte: 0x0
    byte: 0x58

    //1332Hz (E6)    Index #$68
    byte: 0x0
    byte: 0x53

    //1398Hz (F6)    Index #$6A
    byte: 0x0
    byte: 0x4f

    //1492Hz (F#6)    Index #$6C
    byte: 0x0
    byte: 0x4a

    //1576Hz (G6)    Index #$6E
    byte: 0x0
    byte: 0x46

    //1670Hz (Ab6)    Index #$70
    byte: 0x0
    byte: 0x42

    //1776Hz (A6)    Index #$72
    byte: 0x0
    byte: 0x3e

    //1896Hz (A#6)    Index #$74
    byte: 0x0
    byte: 0x3a

    //1998Hz (B6)    Index #$76
    byte: 0x0
    byte: 0x37

    //2111Hz (C7)    Index #$78
    byte: 0x0
    byte: 0x34

    //2238Hz (C#7)    Index #$7A
    byte: 0x0
    byte: 0x31

    //2380Hz (D7)    Index #$7C
    byte: 0x0
    byte: 0x2e

    //2796Hz (F7)    Index #$7E
    byte: 0x0
    byte: 0x27

//The following tables are used to load the music frame count addresses ($0640 thru $0643). The
//larger the number, the longer the music will play a solid note.  The number represents how
//many frames the note will play.  There is a small discrepancy in time length because the
//Nintendo runs at 60 frames pers second and I am using 64 frames per second to make the
//numbers below divide more evenly.

//Used by power up music and Kraid area music.

def notelengths0tbl:

    //About    1/16 seconds ($B0)
    byte: 0x4
    //About    1/8  seconds ($B1)
    byte: 0x8
    //About    1/4  seconds ($B2)
    byte: 0x10
    //About    1/2  seconds ($B3)
    byte: 0x20
    //About 1       seconds ($B4)
    byte: 0x40
    //About    3/8  seconds ($B5)
    byte: 0x18
    //About    3/4  seconds ($B6)
    byte: 0x30
    //About    3/16 seconds ($B7)
    byte: 0xc
    //About   11/64 seconds ($B8)
    byte: 0xb
    //About    5/64 seconds ($B9)
    byte: 0x5
    //About    1/32 seconds ($BA)
    byte: 0x2

//Used by item room, fade in, Brinstar music, Ridley area music, Mother brain music,
//escape music, Norfair music and Tourian music.

def notelengths1tbl:

    //About    3/32 seconds ($B0)
    byte: 0x6
    //About    3/16 seconds ($B1)
    byte: 0xc
    //About    3/8  seconds ($B2)
    byte: 0x18
    //About    3/4  seconds ($B3)
    byte: 0x30
    //About 1  1/2  seconds ($B4)
    byte: 0x60
    //About    9/16 seconds ($B5)
    byte: 0x24
    //About 1  3/16 seconds ($B6)
    byte: 0x48
    //About    9/32 seconds ($B7)
    byte: 0x12
    //About    1/4  seconds ($B8)
    byte: 0x10
    //About    1/8  seconds ($B9)
    byte: 0x8
    //About    3/64 seconds ($BA)
    byte: 0x3

//Used by intro and end game music.

def notelengths2tbl:

    //About    1/4  seconds ($B0)
    byte: 0x10
    //About    7/64 seconds ($B1)
    byte: 0x7
    //About    7/32 seconds ($B2)
    byte: 0xe
    //About    7/16 seconds ($B3)
    byte: 0x1c
    //About    7/8  seconds ($B4)
    byte: 0x38
    //About 1 13/16 seconds ($B5)
    byte: 0x70
    //About   21/32 seconds ($B6)
    byte: 0x2a
    //About 1  5/16 seconds ($B7)
    byte: 0x54
    //About   21/64 seconds ($B8)
    byte: 0x15
    //About    9/32 seconds ($B9)
    byte: 0x12
    //About    1/32 seconds ($BA)
    byte: 0x2
    //About    3/64 seconds ($BB)
    byte: 0x3

def initializemusic:
                    
    //($B3FC)Check to see if restarting current music.
    call checkmusicflags
    //Load current SFX flags and store CurrentMusic address.
    a = [currentsfxflags]
    [currentmusic] = a
    a = [musicinitindex]
    y = a
    //($BBFA)Find index for music in InitMusicInitIndexTbl.
    a = [initmusicindextbl:y]
    y = a
    x = 0x0

def _0113:
    //Base is $BD31.
    a = [initmusictbl:y]
    [notelengthtbloffset:x] = a
    //The following loop repeats 13 times to-->
    y++
    //load the initial music addresses -->
    x++
    //(registers $062B thru $0637).
    a = x
    compare a to 0xd
    goto _0113 when ~zero

    //Resets addresses $0640 thru $0643 to #$01.-->
    a = 0x1
    //These addresses are used for counting the-->
    [sq1musicframecount] = a
    //number of frames music channels have been playing.
    [sq2musicframecount] = a
    [trianglemusicframecount] = a
    [noisemusicframecount] = a
    a = 0x0
    [sq1musicindexindex] = a
    //Resets addresses $0638 thru $063B to #$00.-->
    [sq2musicindexindex] = a
    //These are the index to find sound channel data index.
    [trianglemusicindexindex] = a
    [noisemusicindexindex] = a
    return

//Not used.
    byte: 0x10, 0x7, 0xe, 0x1c, 0x38, 0x70, 0x2a, 0x54, 0x15, 0x12, 0x2, 0x3, 0x20, 0x2c, 0xb4, 0xad
    byte: 0x4d, 0x6, 0x8d, 0x8d, 0x6, 0xad, 0x5e, 0x6, 0xa8, 0xb9, 0x2a, 0xbc, 0xa8, 0xa2, 0x0, 0xb9
    byte: 0x61, 0xbd, 0x9d, 0x2b, 0x6, 0xc8, 0xe8, 0x8a, 0xc9, 0xd, 0xd0, 0xf3, 0xa9, 0x1, 0x8d, 0x40
    byte: 0x6, 0x8d, 0x41, 0x6, 0x8d, 0x42, 0x6, 0x8d, 0x43, 0x6, 0xa9, 0x0, 0x8d, 0x38, 0x6, 0x8d
    byte: 0x39, 0x6, 0x8d, 0x3a, 0x6, 0x8d, 0x3b, 0x6, 0x60, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0

//----------------------------------------------[ RESET ]--------------------------------------------

def reset:

    //Disables interrupt.
    interrupt = 1
    //Sets processor to binary mode.
    decimal = 0
    x = 0x0
    //Clear PPU control registers.
    [nes.ppu.ctrl] = x
    [nes.ppu.mask] = x
def _0114:
    a = [nes.ppu.status]
    //Wait for VBlank.
    goto _0114 when ~negative
def _0115:
    a = [nes.ppu.status]
    goto _0115 when ~negative
    a = a | 0xff
    //Reset MMC1 chip.-->
    [nes.mmc1.ctrl] = a
    //(MSB is set).
    [nes.mmc1.chr1] = a
    [nes.mmc1.chr2] = a
    [nes.mmc1.prg] = a
    //($C01A)Does preliminry housekeeping.
    goto startup

//Not used.
    byte: 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
    byte: 0x0, 0x0, 0x0, 0x0, 0x0

//----------------------------------------[ Interrupt vectors ]--------------------------------------

    //($C0D9)NMI vector.
    word: vblank
    //($FFB0)Reset vector.
    word: reset
    //($FFB0)IRQ vector.
    word: reset
end
